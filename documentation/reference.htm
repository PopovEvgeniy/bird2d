<html>
 <head>
  <meta http-equiv="content-type" content="text/html; charset=us-ascii">
  <title>Programmer Reference</title>
 </head>
 <body>
  <div align="center"><big>Bird 2D: Programmer Reference</big><br>
  </div>
  <big><br>
  </big>
  <ol id="mozToc">
   <!--mozToc h1 1 h2 2 h3 3 h4 4 h5 5 h6 6-->
   <li><a href="#mozTocId168425">Part 1. Welcome</a>
    <ol>
     <li><a href="#mozTocId515651">Chapter 1. The introduction</a></li>
     <li><a href="#mozTocId712481">Chapter 2. A special thanks</a></li>
     <li><a href="#mozTocId714927">Chapter 3. The license</a></li>
     <li><a href="#mozTocId607623">Chapter 4. The dependencies</a></li>
     <li><a href="#mozTocId87585">Chapter 5. The engine namespace</a></li>
     <li><a href="#mozTocId979940">Chapter 6. The custom data types</a></li>
    </ol>
   </li>
   <li><a href="#mozTocId211240">Part 2. Basic things</a>
    <ol>
     <li><a href="#mozTocId878435">Chapter 1. The coordinate system</a></li>
     <li><a href="#mozTocId787305">Chapter 2. A game loop</a></li>
    </ol>
   </li>
   <li><a href="#mozTocId506974">Part 3. Graphics</a>
    <ol>
     <li><a href="#mozTocId104881">Chapter 1. The sub-namespace</a></li>
     <li><a href="#mozTocId65720">Chapter 2. The base graphics subsystem</a></li>
     <li><a href="#mozTocId517211">Chapter 3. The picture subsystem</a></li>
     <li><a href="#mozTocId172222">Chapter 4. The animation subsystem</a></li>
     <li><a href="#mozTocId943391">Chapter 5. The vertex index</a></li>
     <li><a href="#mozTocId389323">Chapter 6. The image kind</a></li>
     <li><a href="#mozTocId512412">Chapter 7. The ordinary background</a></li>
     <li><a href="#mozTocId541338">Chapter 8. The static background</a></li>
     <li><a href="#mozTocId462914">Chapter 9. The parallax background</a></li>
     <li><a href="#mozTocId303369">Chapter 10. The base sprite subsystem</a></li>
     <li><a href="#mozTocId435092">Chapter 11. The ordinary sprites</a></li>
     <li><a href="#mozTocId396888">Chapter 12. The static sprites</a></li>
     <li><a href="#mozTocId745477">Chapter 13. The sprite sheet</a></li>
     <li><a href="#mozTocId623302">Chapter 14. The text</a></li>
     <li><a href="#mozTocId124177">Chapter 15. Loading an image</a></li>
     <li><a href="#mozTocId845590">Chapter 16. Camera</a></li>
    </ol>
   </li>
   <li><a href="#mozTocId47390">Part 4. The transformation</a>
    <ol>
     <li><a href="#mozTocId771051">Chapter 1. The sub-namespace</a></li>
     <li><a href="#mozTocId151671">Chapter 2. The Cartesian coordinates and the screen coordinates</a></li>
     <li><a href="#mozTocId148985">Chapter 3. The Cartesian coordinates and the isometric coordinates</a></li>
     <li><a href="#mozTocId962088">Chapter 4. An isometric level</a></li>
    </ol>
   </li>
   <li><a href="#mozTocId456967">Part 5. The common things</a>
    <ol>
     <li><a href="#mozTocId370034">Chapter 1. The sub-namespace</a></li>
     <li><a href="#mozTocId389651">Chapter 2. The abnormal program termination</a></li>
     <li><a href="#mozTocId649102">Chapter 3. The timers</a></li>
     <li><a href="#mozTocId241190">Chapter 4. The collision detector</a></li>
     <li><a href="#mozTocId994359">Chapter 5. The tilemaps</a></li>
    </ol>
   </li>
   <li><a href="#mozTocId373029">Part 6. The other important things</a>
    <ol>
     <li><a href="#mozTocId53728">Chapter 1. The sub-namespace</a></li>
     <li><a href="#mozTocId854878">Chapter 2. The Memory</a></li>
     <li><a href="#mozTocId188208">Chapter 3. The audio</a></li>
    </ol>
   </li>
   <li><a href="#mozTocId15273">Part 7. Misc</a>
    <ol>
     <li><a href="#mozTocId422364">Chapter 1. The Filesystem</a></li>
     <li><a href="#mozTocId83537">Chapter 2. A tool</a></li>
     <li><a href="#mozTocId301368">Chapter 3. The resource manager</a></li>
    </ol>
   </li>
   <li><a href="#mozTocId443113">Part 8. The binary files</a>
    <ol>
     <li><a href="#mozTocId843024">Chapter 1. The sub-namespace</a></li>
     <li><a href="#mozTocId294133">Chapter 2. The base binary file subsystem</a></li>
     <li><a href="#mozTocId308140">Chapter 3. The file reader</a></li>
     <li><a href="#mozTocId270683">Chapter 4. The file writer</a></li>
    </ol>
   </li>
   <li><a href="#mozTocId638974">Part 9. The input</a>
    <ol>
     <li><a href="#mozTocId524142">Chapter 1. The sub-namespace</a></li>
     <li><a href="#mozTocId515445">Chapter 2. The keyboard</a></li>
     <li><a href="#mozTocId873525">Chapter 3. The mouse</a></li>
     <li><a href="#mozTocId771509">Chapter 4. A joystick</a></li>
    </ol>
   </li>
   <li><a href="#mozTocId104989">Part 10. The internal details of the engine subsystems</a>
    <ol>
     <li><a href="#mozTocId841757">Chapter 1. A few words for a curious programmer</a></li>
     <li><a href="#mozTocId136763">Chapter 2. The internal classes</a></li>
     <li><a href="#mozTocId388620">Chapter 3. The base graphics subsystem</a></li>
     <li><a href="#mozTocId762700">Chapter 4. The joystick</a></li>
     <li><a href="#mozTocId341329">Chapter 5. The input</a></li>
     <li><a href="#mozTocId784958">Chapter 6. The audio</a></li>
    </ol>
   </li>
   <li><a href="#mozTocId707314">Version history</a></li>
  </ol>
  <h1><a id="mozTocId168425" class="mozTocH1"></a><big> Part 1. Welcome</big></h1>
  <h2><a id="mozTocId515651" class="mozTocH2"></a><big> Chapter 1. The introduction</big></h2>
  <big> <u>The introduction.</u><br>
   <br>
   Hello! My name is Popov Evgeniy Alekseyevich. I am an
   individual programmer. I enjoy creating software. I also like
   old-school video games. Do you want to develop video games for <a href="https://en.wikipedia.org/wiki/Linux">Linux</a>?
   You need a good game engine to do it. I made my own engine. I hope that my
   C++ game engine will be useful for many programmers.<br>
   <br>
   <u>Features.</u><br>
   <br>
   Let me show you the engine features. Let's go.<br>
   <br>
  </big>
  <ul>
   <li><big> Open source code.</big></li>
   <li><big> Very fast.</big></li>
   <li><big> The easy-to-use object-oriented design.</big></li>
   <li><big> The minimum number of external dependencies: <a href="https://gitlab.freedesktop.org/xorg/lib/libx11">Xlib</a>, <a href="https://mesa3d.org">Mesa 3D</a>, and <a href="https://www.videolan.org/vlc/libvlc.html">libVLC</a> libraries.</big></li>
  </ul>
  <big><u><br>
    Installation.</u><br>
   <br>
   How to install this engine? Follow these steps:<br>
   <br>
   Copy these files to your project directory:<br>
   <br>
  </big>
  <ul>
   <li><big> bird2d.h</big></li>
   <li><big> bird2d.cpp</big></li>
  </ul>
  <big><br>
   Add it to your project.<br>
   Add this directive to your code: <i>#include "bird2d.h"</i><br>
   <br>
   Yes. This is really all you need to do.<br>
  </big>
  <h2><a id="mozTocId712481" class="mozTocH2"></a><big> Chapter 2. A special thanks</big></h2>
  <big> I want to say «Big thanks for the technical consultation» to these people:<br>
   <br>
  </big>
  <ul>
   <li><big> <a href="https://github.com/dmitrysmagin">Dmitry Smagin</a></big></li>
   <li><big> <a href="https://bsg.org.ua">Pavel Samko</a></big></li>
   <li><big> <a href="https://github.com/EXL">EXL</a></big></li>
   <li><big> <a href="http://www.almost-university.com">Vladimir Mozhenkov</a></big></li>
   <li><big> <a href="https://vk.com/strong666">Vitaliy Molochkov</a></big></li>
   <li><big> <a href="mailto:eyegem@mail.ru">Evgenia Germanova</a></big></li>
   <li><big> DDMZ</big></li>
   <li><big> Anastasiya</big></li>
  </ul>
  <big><br>
   Thanks to the PVS-Studio team for the <a href="https://www.viva64.com/en/b/0614/">free license</a>.<br>
  </big>
  <h2><a id="mozTocId714927" class="mozTocH2"></a><big> Chapter 3. The license</big></h2>
  <big> Copyright (C) 2023 – 2025 Popov Evgeniy Alekseyevich<br>
   <br>
   This software is provided 'as–is', without any express or implied<br>
   warranty. In no event will the authors be held liable for any damages<br>
   arising from the use of this software.<br>
   Permission is granted to anyone to use this software for any purpose,<br>
   including commercial applications, and to alter it and redistribute it<br>
   freely, subject to the following restrictions:<br>
   1. The origin of this software must not be misrepresented; you must not<br>
   claim that you wrote the original software. If you use this software<br>
   in a product, an acknowledgment in the product documentation would be<br>
   appreciated but is not required.<br>
   2. Altered source versions must be plainly marked as such, and must not be<br>
   misrepresented as being the original software.<br>
   3. This notice may not be removed or altered from any source distribution.<br>
  </big>
  <h2><a id="mozTocId607623" class="mozTocH2"></a><big> Chapter 4. The dependencies</big></h2>
  <big> You need libx11-dev, libgl1-mesa-dev and libvlc-dev packages to compile this game engine.<br>
  </big>
  <h2><a id="mozTocId87585" class="mozTocH2"></a><big> Chapter 5. The engine namespace</big></h2>
  <big><i> BIRD2D</i> is the main namespace. All the engine classes are declared in a few nested namespaces.<br>
  </big>
  <h2><a id="mozTocId979940" class="mozTocH2"></a><big> Chapter 6. The custom data types</big></h2>
  <big> Almost all custom data types are declared in the <i>BIRD2D</i> namespace.<br>
  </big>
  <h1><a id="mozTocId211240" class="mozTocH1"></a><big> Part 2. Basic things</big></h1>
  <h2><a id="mozTocId878435" class="mozTocH2"></a><big> Chapter 1. The coordinate system</big></h2>
  <big><br>
   The engine uses the standard coordinate system by default. The coordinates
   start at the top-left corner. Look at this picture to understand it.<br>
   <br>
   <img alt="" src="coordinate_system.png" height="111" width="107"><br>
   <br>
  </big>
  <h2><a id="mozTocId787305" class="mozTocH2"></a><big> Chapter 2. A game loop</big></h2>
  <big> What is the main point in your game? A game loop. You can see the structure of a typical game loop below.<br>
   <br>
   <img alt="" src="game_loop.png" height="354" width="379"><br>
   <br>
  </big>
  <h1><a id="mozTocId506974" class="mozTocH1"></a><big> Part 3. Graphics</big></h1>
  <h2><a id="mozTocId104881" class="mozTocH2"></a><big> Chapter 1. The sub-namespace</big></h2>
  <big> <br>
   All classes in this section are declared in the Graphics sub-namespace.<br>
  </big>
  <h2><a id="mozTocId65720" class="mozTocH2"></a><big> Chapter 2. The base graphics subsystem</big></h2>
  <big> <u>The introduction.</u><br>
   <br>
   The base graphics subsystem does render a game scene. This subsystem uses
   <a href="http://OpenGL.org">OpenGL</a> for rendering. All modern video
   cards support hardware acceleration. The software implementation
   will be activated if the acceleration is not available.<br>
   <u><br>
    The render performance.</u><br>
   <br>
   Always use the latest video card drivers. It may increase the rendering
   performance. You can also try to change the screen resolution if you have low rendering performance.<br>
   <br>
   <u>The FPS limitation.</u><br>
   <br>
   FPS is an important thing. Many FPS are needed for a good animation, but
   it also needs high processor usage. The FPS limit is 60 by default. It has an ideal value.<br>
   <u><br>
    Work with the base graphics subsystem.</u><br>
   <br>
   The <i>Screen</i> class provides access to the base graphics subsystem.
   Let's look at the publicly available methods.<br>
   <br>
   <i>void Screen::clear_screen(); -</i> Clear the screen. Fill it with black color.<br>
   <i><br>
    void Screen::initialize(); -</i> Initialize the base graphic subsystem.<br>
   <i><br>
    bool Screen::sync(); -</i> Show the current content of the back buffer
   on the screen. Return false if a game is terminated. This method uses the FPS limits and waits between frames.<br>
   <br>
   <i>bool Screen::update(); -</i> Show the current content of the back
   buffer on the screen. Return false if a game is terminated. This method ignores the FPS limit and needs high processor usage.<br>
   <i><br>
    bool Screen::sync(const bool limit); -</i> Show the current content of
   the back buffer on the screen. Return false if a game is terminated.<br>
   <i><br>
    bool Screen::is_ready(); -</i> Return true if the subsystem has already been initialized.<br>
   <br>
   <i> unsigned int Screen::get_fps() const; -</i> Return the current FPS value.<br>
   <i><br>
    unsigned int Screen::get_color() const; -</i> Return the current color depth in bits per pixel.<br>
   <br>
   <i>unsigned int Screen::get_width() const; -</i> Return the screen width in pixels.<br>
   <br>
   <i>unsigned int Screen::get_height() const; -</i> Return the screen height in pixels.<br>
   <i><br>
    bool Screen::check_x(const unsigned int x) const; -</i> Return true if the x-coordinate is valid.<br>
   <br>
   <i>bool Screen::check_y(const unsigned int y) const; -</i> Return true if the y-coordinate is valid.<br>
   <br>
   <i>bool Screen::check_horizontal_border(const BIRD2D::BOX target) const; -</i> Return true if a game object has collided with the horizontal screen border.<br>
   <i><br>
    bool Screen::check_vertical_border(const BIRD2D::BOX target) const; -</i> Return true if a game object has collided with the vertical screen border.<br>
   <br>
   <i>Screen *Screen::get_handle(); -</i> Return the handle to the base graphics subsystem object.<br>
  </big>
  <h2><a id="mozTocId517211" class="mozTocH2"></a><big> Chapter 3. The picture subsystem</big></h2>
  <big> <u>An important subsystem.</u><br>
   <br>
   The picture subsystem implements an image storage.<br>
   <br>
   <u> Work with the picture subsystem.</u><br>
   <br>
   The <i>Picture</i> class provides simple access to the picture subsystem.
   Don't use it directly. Let's look at the publicly available methods.<br>
   <br>
   <i>unsigned int *Picture::get_image(); -</i> Return the handle to the image storage.<br>
   <i><br>
    void Picture::destroy_image(); -</i> Destroy an image in the storage.<br>
   <br>
   <i> bool Picture::is_storage_empty() const; -</i> Return true if the storage is empty.<br>
   <i><br>
    unsigned int Picture::get_image_width() const; -</i> Return the image width in pixels.<br>
   <br>
   <i>unsigned int Picture::get_image_height() const; -</i> Return the image height in pixels.<br>
   <br>
   <i>size_t Picture::get_pixel_amount() const; -</i> Return the amount of the image pixels.<br>
   <br>
   <i>size_t Picture::get_image_lenght() const; -</i> Return the image length in bytes.<br>
  </big>
  <h2><a id="mozTocId172222" class="mozTocH2"></a><big> Chapter 4. The animation subsystem</big></h2>
  <big> <u> An important subsystem.</u><br>
   <br>
   The animation subsystem lets you control the animation frames.<br>
   <u><br>
    The frame index.</u><br>
   <br>
   The first frame index is 1.<br>
   <br>
   <u>Work with the animation subsystem.</u><br>
   <br>
   The <i>Animation</i> class provides simple access to the animation
   subsystem. Don't use it directly. Let's look at the publicly available methods.<br>
   <br>
   <i> unsigned int Animation::get_frames() const; -</i> Return the number of the frames.<br>
   <i><br>
    unsigned int Animation::get_frame() const; -</i> Return the current frame.<br>
   <i><br>
    bool Animation::is_last_frame() const; -</i> Return true if the current frame is the last frame.<br>
   <br>
   <i>bool Animation::check_frame(const unsigned int target) const; - </i>Return true if the target frame is valid.<br>
  </big>
  <h2><a id="mozTocId943391" class="mozTocH2"></a><big> Chapter 5. The vertex index</big></h2>
  <big> <br>
   The vertex index looks like the predefined constants. You can see it below.<br>
   <br>
  </big>
  <table style="width: 358px; height: 139px;" border="1">
   <tbody>
    <tr>
     <td><big>Vertex index<br>
      </big></td>
     <td><big>Description</big></td>
    </tr>
    <tr>
     <td><big>FIRST_VERTEX<br>
      </big></td>
     <td><big>The first vertex<br>
      </big></td>
    </tr>
    <tr>
     <td><big>SECOND_VERTEX</big></td>
     <td><big>The second vertex<br>
      </big></td>
    </tr>
    <tr>
     <td style="vertical-align: top;"><big>THIRD_VERTEX</big></td>
     <td style="vertical-align: top;"><big>The third vertex<br>
      </big></td>
    </tr>
    <tr>
     <td style="vertical-align: top;"><big>LAST_VERTEX</big></td>
     <td style="vertical-align: top;"><big>The last vertex</big></td>
    </tr>
   </tbody>
  </table>
  <big><br>
  </big>
  <h2><a id="mozTocId389323" class="mozTocH2"></a><big> Chapter 6. The image kind</big></h2>
  <big> <br>
   The image types look like the predefined constants. You can see it below.<br>
   <br>
  </big>
  <table style="width: 711px; height: 106px;" border="1">
   <tbody>
    <tr>
     <td><big>Image type<br>
      </big></td>
     <td><big>Description</big></td>
    </tr>
    <tr>
     <td><big>HORIZONTAL_ANIMATED</big></td>
     <td><big>The horizontal animated background or the horizontal strip</big></td>
    </tr>
    <tr>
     <td><big>VERTICAL_ANIMATED</big></td>
     <td><big>The vertical animated background or the vertical strip</big></td>
    </tr>
   </tbody>
  </table>
  <big><br>
  </big>
  <h2><a id="mozTocId512412" class="mozTocH2"></a><big> Chapter 7. The ordinary background</big></h2>
  <big> <u>The decoration for a level.</u><br>
   <br>
   A background is a big image with a few frames. Any game has a background.
   The background will be stretched to the screen resolution before rendering
   the game scene. The background transparency is always disabled.<br>
   <br>
   The horizontal animated backgrounds look like the horizontal photo
   ribbons. The vertical animated backgrounds look like the vertical photo ribbons.<br>
   <br>
   <u>Work with the background.</u><br>
   <br>
   Just use the <i>Background</i> class to work with the background. Let's look at the publicly available methods.<br>
   <br>
   <i>Background *Background::get_handle(); -</i> Return the handle to the background object.<br>
   <br>
   <i>void Background::prepare(const Screen *screen); -</i> Prepare for drawing.<br>
   <br>
   <i>void Background::prepare(Screen &amp;screen); -</i> Prepare for drawing.<br>
   <br>
   <i>void Background::prepare(const unsigned int width, const unsigned int height); -</i> Prepare for drawing.<br>
   <i><br>
    void Background::disable_mirror(); -</i> Disable the background mirroring mode.<br>
   <i><br>
    void Background::horizontal_mirror(); -</i> Set the horizontal background mirroring mode.<br>
   <br>
   <i> void Background::vertical_mirror(); -</i> Set the vertical background mirroring mode.<br>
   <br>
   <i> void Background::complex_mirror(); -</i> Set both the horizontal
   background mirroring mode and vertical background mirroring mode.<br>
   <br>
   <i>unsigned int Background::set_target(const unsigned int target); -</i> Set the target frame and return it.<br>
   <i><br>
    void Background::step(); -</i> Increase the target frame. Set it to 1 if the target is more than the number of frames.<br>
   <i><br>
    void Background::set_settings(const BIRD2D::IMAGE_KIND kind, const unsigned int frames); -</i> Set the background settings.<br>
   <br>
   <i>bool Background::load(Image *background, const BIRD2D::IMAGE_KIND kind, const unsigned int frames); -</i> Load a background from the buffer and return true if it is loaded.<br>
   <br>
   <i>bool Background::load(Image &amp;background, const BIRD2D::IMAGE_KIND kind, const unsigned int frames); -</i> Load a background from the buffer and return true if it is loaded.<br>
   <i><br>
    bool Background::load(const char *name, const BIRD2D::IMAGE_KIND kind, const unsigned int frames); -</i> Load a background from the target file and return true if it is loaded.<br>
   <br>
   <i>void Background::draw(); -</i> Draw a background.<br>
   <i><br>
    void Background::draw(const unsigned int target); -</i> Draw the target frame.<br>
   <br>
   <i>void Background::destroy_image(); -</i> Destroy a background image.<br>
   <br>
   <i>void Background::destroy(); -</i> Destroy a background image and the texture.<br>
   <br>
   <i>bool Background::is_load() const; -</i> Return true if a background has already been loaded.<br>
   <i><br>
    bool Background::is_last_frame() const; -</i> Return true if the current frame is the last frame.<br>
   <br>
   <i>bool Background::check_frame(const unsigned int target) const; -</i> Return true if the target frame is valid.<br>
   <i><br>
    unsigned int Background::get_frame() const; -</i> Return the current frame.<br>
   <i><br>
    unsigned int Background::get_frames() const; -</i> Return the number of the frames.<br>
   <i><br>
    unsigned int Background::get_width() const; -</i> Return the width of the background.<br>
   <br>
   <i>unsigned int Background::get_height() const; -</i> Return the height of the background.<br>
   <br>
   <i>BIRD2D::IMAGE_KIND Background::get_kind() const; -</i> Get the background kind.<br>
   <u><br>
    A background texture.</u><br>
   <br>
   The background doesn't draw if the background texture doesn't exist. It will be automatically created when you load an image.<br>
   <br>
   <u>An important notice.</u><br>
   <br>
   Always call the <i>prepare</i> after the background has been loaded.<br>
  </big>
  <h2><a id="mozTocId541338" class="mozTocH2"></a><big> Chapter 8. The static background</big></h2>
  <big> <u> A few words about the static background.</u><br>
   <br>
   The static background is a simple kind of background. It contains only one frame.<br>
   <u><br>
    Work with the background.</u><br>
   <br>
   Just use the <i>Scene</i> class to work with the static background. Let's look at the publicly available methods.<br>
   <i><br>
    Scene *Scene::get_handle(); -</i> Return the handle to the background object.<br>
   <i><br>
    void Scene::prepare(const Screen *screen); -</i> Prepare for drawing.<br>
   <i><br>
    void Scene::prepare(Screen &amp;screen); -</i> Prepare for drawing.<br>
   <br>
   <i>void Scene::prepare(const unsigned int width, const unsigned int height); -</i> Prepare for drawing.<br>
   <br>
   <i>void Scene::disable_mirror(); -</i> Disable the background mirroring mode.<br>
   <i><br>
    void Scene::horizontal_mirror(); -</i> Set the horizontal background mirroring mode.<br>
   <br>
   <i>void Scene::vertical_mirror(); -</i> Set the vertical background mirroring mode.<br>
   <br>
   <i>void Scene::complex_mirror(); -</i> Set both the horizontal background
   mirroring mode and the vertical background mirroring mode.<br>
   <br>
   <i>bool Scene::load(Image *background); -</i> Load a background from the buffer and return true if it is loaded.<br>
   <i><br>
    bool Scene::load(Image &amp; background); -</i> Load a background from the buffer and return true if it is loaded.<br>
   <br>
   <i>bool Scene::load(const char *name); -</i> Load a background from the target file and return true if it is loaded.<br>
   <br>
   <i>void Scene::draw(); -</i> Draw a background.<br>
   <i><br>
    void Scene::destroy_image(); -</i> Destroy a background image.<br>
   <br>
   <i>void Scene::destroy(); -</i> Destroy a background image and destroy the texture.<br>
   <br>
   <i>bool Scene::is_load() const; -</i> Return true if a static background has already been loaded.<br>
   <i><br>
    unsigned int Scene::get_width() const; -</i> Return the width of the background.<br>
   <i><br>
    unsigned int Scene::get_height() const; -</i> Return the height of the background.<br>
   <i><br>
   </i><u>A background texture.</u><br>
   <br>
   The background doesn't draw if the background texture doesn't exist. It will be automatically created when you load an image.<br>
   <u><br>
    An important notice.</u><br>
   <br>
   Always call the <i>prepare</i> after the background has been loaded.<br>
  </big>
  <h2><a id="mozTocId462914" class="mozTocH2"></a><big> Chapter 9. The parallax background<br></big></h2>
  <big> <u> A few words about the parallax background.</u><br>
   <br>
   The parallax background is a background with scrolling support.<br>
   <u><br>
    The speed.</u><br>
   <br>
   The scrolling speed should be a positive number.<br>
   <br>
   <u>Work with the background.</u><br>
   <br>
   Just use the <i>Parallax</i> class to work with the parallax background.
   Let's look at the publicly available methods.<br>
   <br>
   <i>Parallax *Parallax::get_handle(); -</i> Return the handle to the background object.<br>
   <br>
   <i>void Parallax::prepare(const Screen *screen); -</i> Prepare for drawing.<br>
   <br>
   <i>void Parallax::prepare(Screen &amp;screen); -</i> Prepare for drawing.<br>
   <br>
   <i>void Parallax::prepare(const unsigned int width, const unsigned int height); -</i> Prepare for drawing.<br>
   <br>
   <i>void Parallax::disable_mirror(); -</i> Disable the background mirroring mode.<br>
   <br>
   <i>void Parallax::horizontal_mirror(); -</i> Set the horizontal background mirroring mode.<br>
   <br>
   <i>void Parallax::vertical_mirror(); -</i> Set the vertical background mirroring mode.<br>
   <i><br>
    void Parallax::complex_mirror(); -</i> Set both the horizontal
   background mirroring mode and the vertical background mirroring mode.<br>
   <br>
   <i>bool Parallax::load(Image *background); -</i> Load a background from the buffer and return true if it is loaded.<br>
   <br>
   <i>bool Parallax::load(Image &amp; background); -</i> Load a background from the buffer and return true if it is loaded.<br>
   <br>
   <i>bool Parallax::load(const char *name); -</i> Load a background from the target file and return true if it is loaded.<br>
   <br>
   <i>void Parallax::set_horizontal_speed(const float speed); -</i> Set the horizontal scrolling speed.<br>
   <br>
   <i>void Parallax::set_vertical_speed(const float speed); -</i> Set the vertical scrolling speed.<br>
   <br>
   <i>void Parallax::set_speed(const float horizontal, const float vertical); -</i> Set the scrolling speed.<br>
   <br>
   <i>float Parallax::get_horizontal_speed() const; -</i> Return the horizontal speed.<br>
   <br>
   <i>float Parallax::get_vertical_speed() const; -</i> Return the vertical speed.<br>
   <i><br>
    void Parallax::draw(); -</i> Draw a background.<br>
   <i><br>
    void Parallax::destroy_image(); -</i> Destroy a background image.<br>
   <i><br>
    void Parallax::destroy(); -</i> Destroy a background image and destroy the texture.<br>
   <i><br>
    bool Parallax::is_load() const; -</i> Return true if a parallax background has already been loaded.<br>
   <br>
   <i>unsigned int Parallax::get_width() const; -</i> Return the width of the background.<br>
   <i><br>
    unsigned int Parallax::get_height() const; -</i> Return the height of the background.<br>
   <br>
   <u>A background texture.</u><br>
   <br>
   The background doesn't draw if the background texture doesn't exist. It will be automatically created when you load an image.<br>
   <br>
   <u>An important notice.</u><br>
   <br>
   Always call the prepare after the background has been loaded.<br>
  </big>
  <h2><a id="mozTocId303369" class="mozTocH2"></a><big> Chapter 10. The base sprite subsystem</big></h2>
  <big> <u>A small, important thing.</u><br>
   <br>
   A sprite is a transparent image. It is useful for many things: enemies, bonuses, etc.<br>
   <br>
   <u> Work with the base sprite subsystem.</u><br>
   <br>
   The <i>Billboard</i> class provides simple access to the base sprite
   subsystem. Don't use it directly. Let's look at the publicly available methods.<br>
   <br>
   <i>void Billboard::set_texture_coordinates(const BIRD2D::VERTEX_INDEX index, const float u, const float v); -</i> Set the texture coordinates.<br>
   <br>
   <i>void Billboard::set_transparent(const bool enabled); -</i> Enable or disable the transparent mode.<br>
   <br>
   <i>bool Billboard::get_transparent() const; -</i> Return true if the transparent mode is enabled.<br>
   <i><br>
    void Billboard::set_position(const unsigned int x, const unsigned int y); -</i> Set the sprite position.<br>
   <br>
   <i>void Billboard::set_start(const unsigned int x, const unsigned int y); -</i> Set the start position of the sprite.<br>
   <i><br>
    void Billboard::set_size(const unsigned int width, const unsigned int height); -</i> Change the sprite size.<br>
   <i><br>
    void Billboard::set_x(const unsigned int x); -</i> Set the x-coordinate of the sprite position.<br>
   <i><br>
    void Billboard::set_y(const unsigned int y); -</i> Set the y-coordinate of the sprite position.<br>
   <i><br>
    void Billboard::set_width(const unsigned int width); -</i> Change the sprite width.<br>
   <i><br>
    void Billboard::set_height(const unsigned int height); -</i> Change the sprite height.<br>
   <i><br>
    unsigned int Billboard::increase_x(); -</i> Increase the x-coordinate and return it.<br>
   <br>
   <i>unsigned int Billboard::decrease_x(); -</i> Decrease the x-coordinate and return it.<br>
   <i><br>
    unsigned int Billboard::increase_y(); -</i> Increase the y-coordinate and return it.<br>
   <br>
   <i>unsigned int Billboard::decrease_y(); -</i> Decrease the y-coordinate and return it.<br>
   <br>
   <i>unsigned int Billboard::increase_x(const unsigned int increment); -</i> Increase the x-coordinate with the user value and return it.<br>
   <br>
   <i>unsigned int Billboard::decrease_x(const unsigned int decrement); -</i> Decrease the x-coordinate with the user value and return it.<br>
   <br>
   <i>unsigned int Billboard::increase_y(const unsigned int increment); -</i> Increase the y-coordinate with the user value and return it.<br>
   <br>
   <i>unsigned int Billboard::decrease_y(const unsigned int decrement); -</i> Decrease the y-coordinate with the user value and return it.<br>
   <br>
   <i>unsigned int Billboard::get_start_x() const; -</i> Return the x-coordinate of the start position.<br>
   <br>
   <i>unsigned int Billboard::get_start_y() const; -</i> Return the y-coordinate of the start position.<br>
   <br>
   <i>unsigned int Billboard::get_x() const; -</i> Return the x-coordinate of the sprite position.<br>
   <br>
   <i>unsigned int Billboard::get_y() const; -</i> Return the y-coordinate of the sprite position.<br>
   <br>
   <i>unsigned int Billboard::get_width() const; -</i> Return the width of the sprite.<br>
   <br>
   <i>unsigned int Billboard::get_height() const; -</i> Return the height of the sprite.<br>
   <br>
   <i>bool Billboard::is_load() const; -</i> Return true if the sprite has already been loaded.<br>
   <br>
   <i>BIRD2D::BOX Billboard::get_box() const; -</i> Return the collision-related information.<br>
   <br>
   <i>void Billboard::disable_mirror(); -</i> Disable the sprite mirroring mode.<br>
   <i><br>
    void Billboard::horizontal_mirror(); -</i> Set the horizontal sprite mirroring mode.<br>
   <br>
   <i>void Billboard::vertical_mirror(); -</i> Set the vertical sprite mirroring mode.<br>
   <br>
   <i>void Billboard::complex_mirror(); -</i> Set both the horizontal sprite
   mirroring mode and the vertical sprite mirroring mode.<br>
   <br>
   <i>bool Billboard::is_horizontally_mirrored(); -</i> Return true if the sprite is horizontally mirrored.<br>
   <br>
   <i>bool Billboard::is_vertically_mirrored(); -</i> Return true if the sprite is vertically mirrored.<br>
   <br>
   <i>bool Billboard::is_complex_mirrored(); -</i> Return true if the sprite is both horizontally and vertically mirrored.<br>   
   <br>
   <i>void Billboard::go_start(); -</i> Set the sprite position to the start position.<br>
   <br>
   <i>void Billboard::go_start_x(); -</i> Set the x-coordinate of the sprite position to the x-coordinate of the start position.<br>
   <br>
   <i>void Billboard::go_start_y(); -</i> Set the y-coordinate of the sprite position to the y-coordinate of the start position.<br>
   <br>
   <i>bool Billboard::draw(); -</i> Draw a sprite and return the transparent mode status.<br>
   <br>
   <i>bool Billboard::draw(const unsigned int x, const unsigned int y); -</i> Draw a sprite at the target position and return the transparent mode status.<br>
   <i><br>
    void Billboard::draw(const bool transparency); -</i> Set the transparent mode and draw a sprite.<br>
   <br>
   <i>void Billboard::draw(const bool transparency, const unsigned int x, const unsigned int y); -</i> Set the transparent mode and draw a sprite at the target position.<br>
  </big>
  <h2><a id="mozTocId435092" class="mozTocH2"></a><big> Chapter 11. The ordinary sprites</big></h2>
  <big> <u>The sprite types.</u><br>
   <br>
   There are two kinds of ordinary sprites: the horizontal strips and the
   vertical strips. It is a small image with a few frames.<br>
   The horizontal strip looks like the horizontal photo ribbon. The vertical strip looks like the vertical photo ribbon.<br>
   <u><br>
    Work with the sprites.</u><br>
   <br>
   Just use the <i>Sprite</i> class to work with a sprite. It is derived
   from three classes: <i>Billboard</i>, <i>Animation</i>, and <i>Picture</i>.
   Let's look at the publicly available methods.<br>
   <br>
   <i>void Sprite::set_settings(const BIRD2D::IMAGE_KIND kind, const unsigned int frames); -</i> Set the sprite settings.<br>
   <br>
   <i>bool Sprite::load(Image *buffer, const BIRD2D::IMAGE_KIND kind, const unsigned int frames); -</i> Load a sprite from the buffer and return true if it is loaded.<br>
   <i><br>
    bool Sprite::load(Image &amp;buffer, const BIRD2D::IMAGE_KIND kind, const unsigned int frames); -</i> Load a sprite from the buffer and return true if it is loaded.<br>
   <br>
   <i>bool Sprite::load(const char *name, const BIRD2D::IMAGE_KIND kind, const unsigned int frames); -</i> Load a sprite from the target file and return true if it is loaded.<br>
   <br>
   <i>unsigned int Sprite::set_target(const unsigned int target); -</i> Set the target frame and return it.<br>
   <br>
   <i>void Sprite::step(); -</i> Increase the target frame. Set it to 1 if the target is more than the number of frames.<br>
   <br>
   <i>BIRD2D::IMAGE_KIND Sprite::get_kind() const; -</i> Get the sprite kind.<br>
   <i><br>
    Sprite *Sprite::get_handle(); -</i> Return the handle to the sprite object.<br>
   <br>
   <i>void Sprite::clone(Sprite *target); -</i> Create a copy of the sprite if the storage of the target sprite is not empty.<br>
   <br>
   <i>void Sprite::clone(Sprite &amp;target); -</i> Create a copy of the sprite if the storage of the target sprite is not empty.<br>
   <i><br>
    void Sprite::destroy(); -</i> Destroy a sprite image and destroy the texture.<br>
   <br>
   <u>A sprite texture.</u><br>
   <br>
   A sprite doesn't draw if the sprite texture doesn't exist. It will automatically be created when you load or clone a sprite.<br>
  </big>
  <h2><a id="mozTocId396888" class="mozTocH2"></a><big> Chapter 12. The static sprites</big></h2>
  <big> <u> A few words about the static sprites.</u><br>
   <br>
   The static sprite is a simple kind of sprite. It contains only one frame.<br>
   <br>
   <u> Work with the static sprites.</u><br>
   <br>
   Just use the <i>Cartoon</i> class to work with a static sprite. It is
   derived from two classes: <i>Billboard</i> and <i>Picture</i>. Let's look at the publicly available methods.<br>
   <br>
   <i>bool Cartoon::load(Image *buffer); -</i> Load a sprite from the buffer and return true if it is loaded.<br>
   <br>
   <i>bool Cartoon::load(Image &amp;buffer); -</i> Load a sprite from the buffer and return true if it is loaded.<br>
   <br>
   <i>bool Cartoon::load(const char *name); -</i> Load a sprite from the target file and return true if it is loaded.<br>
   <br>
   <i>Cartoon *Cartoon::get_handle(); -</i> Return the handle to the sprite object.<br>
   <br>
   <i>void Cartoon::clone(Cartoon *target); -</i> Create a copy of the sprite if the storage of the target sprite is not empty.<br>
   <br>
   <i>void Cartoon::clone(Cartoon &amp;target); -</i> Create a copy of the sprite if the storage of the target sprite is not empty.<br>
   <br>
   <i>void Cartoon::destroy(); -</i> Destroy a sprite image and the texture.<br>
   <br>
   <u>A sprite texture.<br>
   </u> <br>
   A sprite doesn't draw if the sprite texture doesn't exist. It will
   automatically be created when you load or clone a sprite.<br>
  </big>
  <h2><a id="mozTocId745477" class="mozTocH2"></a><big> Chapter 13. The sprite sheet</big></h2>
  <big> <u> Some words about the sprite sheet</u><br>
   <br>
   A sprite sheet is a special kind of animated sprite. Each frame has a
   fixed size. The sheet is a matrix of frames. Look at this picture to understand it.<br>
   <br>
   <img alt="" src="sheet.png" height="249" width="380"><br>
   <br>
   <u>The rows and columns.</u><br>
   <br>
   The first row index is 1. The first column index is 1.<br>
   <br>
   <u> Work with the sheet.</u><br>
   <br>
   The <i>Sheet</i> class provides access to the sprite sheet subsystem. It
   is derived from three classes: <i>Billboard</i>, <i>Picture</i>, and <i>Animation</i>.
   Let's look at the publicly available methods.<br>
   <i><br>
    bool Sheet::check_row(const unsigned int target) const; -</i> Return true if the target row is valid.<br>
   <i><br>
    bool Sheet::check_column(const unsigned int target) const; -</i> Return true if the target column is valid.<br>
   <i><br>
    unsigned int Sheet::get_row(const unsigned int target) const; -</i> Return the row of the target frame.<br>
   <i><br>
    unsigned int Sheet::get_column(const unsigned int target) const; -</i> Return column of the target frame.<br>
   <br>
   <i>unsigned int Sheet::calculate(const unsigned int row, const unsigned int column) const; -</i> Calculate the frame by row and column.<br>
   <br>
   <i>unsigned int Sheet::get_rows() const; -</i> Return the number of rows.<br>
   <i><br>
    unsigned int Sheet::get_columns() const; -</i> Return the number of columns.<br>
   <br>
   <i>void Sheet::destroy(); -</i> Destroy a sprite sheet image and the texture.<br>
   <br>
   <i>void Sheet::select(const unsigned int row, const unsigned int column); -</i> Select the target frame by row and column.<br>
   <i><br>
    unsigned int Sheet::set_target(const unsigned int target); -</i> Set the target frame and return it.<br>
   <br>
   <i>void Sheet::step(); -</i> Increase the target frame. Set it to 1 if the target is more than the number of frames.<br>
   <i><br>
    void Sheet::load(Image *sheet, const unsigned int row_amount, const unsigned int column_amount); -</i> Load a sprite sheet from the buffer.<br>
   <i><br>
    bool Sheet::load(Image &amp;sheet, const unsigned int row_amount, const unsigned int column_amount); -</i> Load a sprite sheet from the buffer and return true if it is loaded.<br>
   <br>
   <i>bool Sheet::load(const char *name, const unsigned int row_amount, const unsigned int column_amount); -</i> Load a sprite sheet from a target file and return true if it is loaded.<br>
   <i><br>
    Sheet *Sheet::get_handle(); -</i> Return the handle to the sprite sheet.<i><br>
    <br>
    void Sheet::clone(Sheet *target); -</i> Create a copy of the sprite sheet if the storage of the target sprite sheet is not empty.<br>
   <i><br>
    void Sheet::clone(Sheet &amp;target); -</i> Create a copy of the sprite sheet if the storage of the target sprite sheet is not empty.<br>
   <br>
   <u>A sprite sheet texture.</u><br>
   <br>
   A sprite sheet doesn't draw if the sprite sheet texture doesn't exist. It will be automatically created when you load a sheet.<br>
  </big>
  <h2><a id="mozTocId623302" class="mozTocH2"></a><big> Chapter 14. The text</big></h2>
  <big> <u>How to print a text?</u><br>
   <br>
   Just use the text subsystem to print the text. This subsystem needs a font
   for text printing. You must load a font before starting to print the text.
   The font is just a sprite sheet with 16 rows and 16 columns.<br>
   <br>
   <u>The valid characters.</u><br>
   <br>
   Only 8-bit characters are supported.<br>
   <br>
   <u>The text orientation.</u><br>
   <br>
   The text orientation looks like the predefined constants. You can see it below.<br>
   <br>
  </big>
  <table style="width: 437px; height: 85px;" border="1">
   <tbody>
    <tr>
     <td><big>Text orientation<br>
      </big></td>
     <td><big>Description</big></td>
    </tr>
    <tr>
     <td><big>HORIZONTAL_TEXT</big></td>
     <td><big>The horizontally oriented text<br>
      </big></td>
    </tr>
    <tr>
     <td><big>VERTICAL_TEXT</big></td>
     <td><big>The vertically oriented text</big></td>
    </tr>
   </tbody>
  </table>
  <big><br>
   <u> Work with the text.</u><br>
   <br>
   The <i>Text</i> class provides a simple interface to the text subsystem.
   Let's look at the publicly available methods.<br>
   <i><br>
    Text *Text::get_handle(); -</i> Return the handle to the text printing subsystem.<br>
   <br>
   <i>BIRD2D::TEXT_KIND Text::get_orientation() const; -</i> Get the current text orientation.<br>
   <br>
   <i>void Text::set_orientation(const BIRD2D::TEXT_KIND target); -</i> Set the current text orientation.<br>
   <br>
   <i>bool Text::is_font_load() const; -</i> Return true if the font has already been loaded.<br>
   <br>
   <i>unsigned int Text::get_font_width() const; -</i> Get the current font width in pixels.<br>
   <br>
   <i>unsigned int Text::get_font_height() const; -</i> Get the current font height in pixels.<br>
   <br>
   <i>unsigned int Text::get_x() const; -</i> Get the x-coordinate of the text output position.<br>
   <br>
   <i>unsigned int Text::get_y() const; -</i> Get the y-coordinate of the text output position.<br>
   <i><br>
    void Text::set_position(const unsigned int x, const unsigned int y); -</i> Set the output position.<br>
   <br>
   <i>void Text::set_size(const unsigned int width, const unsigned int height); -</i> Change the font size.<br>
   <br>
   <i>void Text::set_width(const unsigned int width); -</i> Set the font width.<br>
   <br>
   <i>void Text::set_height(const unsigned int height); -</i> Set the font height.<br>
   <i><br>
    void Text::set_settings(const unsigned int width, const unsigned int height, const BIRD2D::TEXT_KIND kind); -</i> Set the text output settings.<br>
   <br>
   <i>bool Text::load_font(Image *font); -</i> Load a font from the buffer and return true if it is loaded.<br>
   <i><br>
    bool Text::load_font(Image &amp;font); -</i> Load a font from the buffer and return true if it is loaded.<br>
   <br>
   <i>bool Text::load_font(const char *name); -</i> Load a font from the target file and return true if it is loaded.<br>
   <br>
   <i>void Text::print(const char target); -</i> Print a single character at the current position.<br>
   <br>
   <i>void Text::print(const unsigned int x, const unsigned int y, const char target); -</i> Print a single character at the specific position.<br>
   <br>
   <i> size_t Text::print(const char *target); -</i> Print a text at the current position and return the text length.<br>
   <br>
   <i>size_t Text::print(const unsigned int x, const unsigned int y, const char *target); -</i> Print a text at the specific position and return the text length.<br>
   <i><br>
    void Text::destroy_image(); -</i> Destroy a font image.<br>
   <i><br>
    void Text::destroy_font(); -</i> Destroy a font image and the texture.<br>
  </big>
  <h2><a id="mozTocId124177" class="mozTocH2"></a><big> Chapter 15. Loading an image</big></h2>
  <big> <u>Load an image from a file.</u><br>
   <br>
   Use the image loader to load an image from a file. The <i>Image</i> class
   provides simple access to the image loader. It is a simple class with a few methods.<br>
   <br>
   <i> unsigned char *Image::load(const char *name); -</i> Load a Truevision TGA image and return the handle to the image buffer.<br>
   <i><br>
    unsigned char *Image::get_data(); -</i> Return the handle to the image buffer.<br>
   <br>
   <i>unsigned int Image::get_width() const; -</i> Return the width of the current image.<br>
   <i><br>
    unsigned int Image::get_height() const; -</i> Return the height of the current image.<br>
   <br>
   <i>size_t Image::get_length() const; -</i> Return length of the image buffer in bytes.<br>
   <br>
   <i>Image *Image::get_handle(); -</i> Return the handle to the image loader.<br>
   <i><br>
    void Image::destroy_image(); -</i> Destroy the current image and free the image buffer.<br>
   <u><br>
    An important remark.</u><br>
   <br>
   A new image will replace the current image if the current image already
   exists. An incorrect image will be ignored and won't load.<br>
   The source image will be converted to <a href="https://en.wikipedia.org/wiki/RGBA">RGBA</a>
   format. The pixels equal to the top-left pixel will be marked as transparent.<br>
   <u><br>
    The supported format.</u><br>
   <br>
   All loading images must have the correct specification. You can load an
   image from a 24-bit <a href="https://en.wikipedia.org/wiki/Truevision_TGA">Truevision TGA</a> picture.<br>
   <u><br>
    The recommended software.</u><br>
   <br>
   You can use a wide range of graphics software to convert your images to
   the correct format. I recommend using <a href="https://www.gimp.org">GIMP</a>
   to do it. It is a powerful image editor.<br>
  </big>
  <h2><a id="mozTocId845590" class="mozTocH2"></a><big> Chapter 16. Camera</big></h2>
  <big><u> A few words about the camera.</u><br>
   <br>
   The 2D camera defines the size of the visible area. It will be stretched to the screen resolution before rendering the game scene.<br>
   <u><br>
    Work with the camera.</u><br>
   <br>
   The <i>Camera</i> class provides simple access to the camera subsystem.
   Let's look at the publicly available methods.<br>
   <br>
   <i>Camera *Camera::get_handle(); -</i> Return the handle to the camera subsystem.<br>
   <br>
   <i>unsigned int Camera::increase_x(); -</i> Increase the x-coordinate of the camera offset and return it.<br>
   <i><br>
    unsigned int Camera::decrease_x(); -</i> Decrease the x-coordinate of the camera offset and return it.<br>
   <i><br>
    unsigned int Camera::increase_y(); -</i> Increase the y-coordinate of the camera offset and return it.<br>
   <i><br>
    unsigned int Camera::decrease_y(); -</i> Decrease the y-coordinate of the camera offset and return it.<br>
   <br>
   <i>unsigned int Camera::increase_x(const unsigned int increment); -</i> Increase the x-coordinate of the camera offset with the user value and return it.<br>
   <i><br>
    unsigned int Camera::decrease_x(const unsigned int decrement); -</i> Decrease the x-coordinate of the camera offset with the user value and return it.<br>
   <i><br>
    unsigned int Camera::increase_y(const unsigned int increment); -</i> Increase the y-coordinate of the camera offset with the user value and return it.<br>
   <i><br>
    unsigned int Camera::decrease_y(const unsigned int decrement); -</i> Decrease the y-coordinate of the camera offset with the user value and return it.<br>
   <br>
   <i>unsigned int Camera::get_x() const; -</i> Return the x-coordinate of the camera offset.<br>
   <br>
   <i>unsigned int Camera::get_y() const; -</i> Return the y-coordinate of the camera offset.<br>
   <br>
   <i>unsigned int Camera::get_screen_width() const; -</i> Return the screen width in pixels.<br>
   <i><br>
    unsigned int Camera::get_screen_height() const; -</i> Return the screen height in pixels.<br>
   <br>
   <i>unsigned int Camera::get_viewport_width() const; -</i> Return the viewport width in pixels.<br>
   <i><br>
    unsigned int Camera::get_viewport_height() const; -</i> Return the viewport height in pixels.<br>
   <br>
   <i>unsigned int Camera::get_highest_x() const; -</i> Return the highest allowable x-coordinate of the current visible area.<br>
   <i><br>
    unsigned int Camera::get_highest_y() const; -</i> Return the highest allowable y-coordinate of the current visible area.<br>
   <i><br>
    unsigned int Camera::get_highest_x_offset() const; -</i> Return the highest allowable x-offset of the camera.<br>
   <i><br>
    unsigned int Camera::get_highest_y_offset() const; -</i> Return the highest allowable y-offset of the camera.<br>
   <i><br>
    unsigned int Camera::get_world_x(const unsigned screen_int x) const; -</i> Convert the screen x-coordinate to the world x-coordinate.<br>
   <i><br>
    unsigned int Camera::get_world_y(const unsigned screen_int y) const; -</i> Convert the screen y-coordinate to the world y-coordinate.<br>
   <br>
   <i>unsigned int Camera::set_x(const unsigned int x); -</i> Set the x-coordinate of the camera offset and return it.<br>
   <br>
   <i>unsigned int Camera::set_y(const unsigned int y); -</i> Set the y-coordinate of the camera offset and return it.<br>
   <br>
   <i>void Camera::initialize(const unsigned int width, const unsigned int height); -</i> Initialize the subsystem and set the screen size.<br>
   <br>
   <i>void Camera::initialize(Screen *screen); -</i> Initialize the subsystem and set the screen size.<br>
   <br>
   <i>void Camera::initialize(Screen &amp;screen); -</i> Initialize the subsystem and set the screen size.<br>
   <br>
   <i>void Camera::set_viewport(const unsigned int width, const unsigned int height); -</i> Set the viewport settings.<br>
   <br>
   <i>void Camera::set_offset(const unsigned int x, const unsigned int y); -</i> Set the camera offset.<br>
   <br>
   <i>bool Camera::check_horizontal_border(const BIRD2D::BOX target) const; -</i> Return true if a game object has collided with the horizontal visible area border.<br>
   <br>
   <i>bool Camera::check_vertical_border(const BIRD2D::BOX target) const; -</i> Return true if a game object has collided with the vertical visible area border.<br>
   <br>
   <i> void Camera::update(); -</i> Update the camera.<br>
   <i><br>
    void Camera::update(const unsigned int x, const unsigned int y); -</i> Set the offsets and update the camera.<br>
   <br>
   <i> void Camera::reset(); -</i> Reset the camera settings.<br>
   <br>
   <u>An important remark.</u><br>
   <br>
   Always set the viewport size after initializing the camera. Always update the camera before drawing.<br>
  </big>
  <h1><a id="mozTocId47390" class="mozTocH1"></a><big> Part 4. The transformation</big></h1>
  <h2><a id="mozTocId771051" class="mozTocH2"></a><big> Chapter 1. The sub-namespace</big></h2>
  <big> All classes in this section are declared in the <i>Transformation</i> sub-namespace.<br>
  </big>
  <h2><a id="mozTocId151671" class="mozTocH2"></a><big> Chapter 2. The Cartesian coordinates and the screen coordinates</big></h2>
  <big> <u>The Cartesian coordinates.</u><br>
   <br>
   The Cartesian coordinates start at the center of the screen. Look at this picture to understand it.<br>
   <br>
   <img alt="" src="cartesian_system.png" height="111" width="107"><br>
   <br>
   <u>The coordinates conversion.</u><br>
   <br>
   You can convert the Cartesian coordinates to the screen coordinates. You
   can also convert the screen coordinates to the Cartesian coordinates.<br>
   <br>
   Just use the <i>Coordinates</i> class to do it. Let's look at the publicly available methods.<br>
   <i><br>
    Coordinates *Coordinates::get_handle(); -</i> Return the handle to the coordinates conversion subsystem.<br>
   <i><br>
    void Coordinates::initialize(const int viewport_width, const int viewport_height); -</i> Initialize the subsystem.<br>
   <br>
   <i>int Coordinates::get_viewport_width() const; -</i> Return the viewport width in pixels.<br>
   <br>
   <i>int Coordinates::get_viewport_height() const; -</i> Return the viewport height in pixels.<br>
   <i><br>
    int Coordinates::get_lowest_cartesian_x() const; -</i> Return the lowest allowable Cartesian x-coordinate.<br>
   <i><br>
    int Coordinates::get_highest_cartesian_x() const; -</i> Return the highest allowable Cartesian x-coordinate.<br>
   <br>
   <i>int Coordinates::get_lowest_cartesian_y() const; -</i> Return the lowest allowable Cartesian y-coordinate.<br>
   <br>
   <i>int Coordinates::get_highest_cartesian_y() const; -</i> Return the highest allowable Cartesian y-coordinate.<br>
   <i><br>
    bool Coordinates::check_cartesian_x(const int x) const; -</i> Return true if the Cartesian x-coordinate is valid.<br>
   <i><br>
    bool Coordinates::check_cartesian_y(const int y) const; -</i> Return true if the Cartesian y-coordinate is valid.<br>
   <br>
   <i>int Coordinates::get_screen_x(const int x) const; -</i> Convert the Cartesian x-coordinate to the screen x-coordinate.<br>
   <br>
   <i>int Coordinates::get_screen_y(const int y) const; -</i> Convert the Cartesian y-coordinate to the screen y-coordinate.<br>
   <br>
   <i>int Coordinates::get_cartesian_x(const int x) const; -</i> Convert the screen x-coordinate to the Cartesian x-coordinate.<br>
   <br>
   <i>int Coordinates::get_cartesian_y(const int y) const; -</i> Convert the screen y-coordinate to the Cartesian y-coordinate.<br>
  </big>
  <h2><a id="mozTocId148985" class="mozTocH2"></a><big> Chapter 3. The Cartesian coordinates and the isometric coordinates</big></h2>
  <big> <u> A few words about the isometric games.</u><br>
   <br>
   <a href="https://en.wikipedia.org/wiki/Isometric_projection">Isometric
    projection</a> is a very popular way for pseudo-3D games. Many old-school games are isometric games.<br>
   <br>
   <u>The coordinates conversion.</u><br>
   <br>
   You can convert the Cartesian coordinates to the isometric coordinates.
   You can also convert the isometric coordinates to the Cartesian
   coordinates. Just use the <i>Isometric</i> class to do it. Let's look at the publicly available methods.<br>
   <i><br>
    static int Isometric::get_isometric_x(const int x, const int y); -</i> Convert the x-coordinate from the Cartesian system to the isometric system.<br>
   <i><br>
    static int Isometric::get_isometric_y(const int x, const int y); -</i> Convert the y-coordinate from the Cartesian system to the isometric system.<br>
   <i><br>
    static int Isometric::get_cartesian_x(const int x, const int y); -</i> Convert the x-coordinate from the isometric system to the Cartesian system.<br>
   <i><br>
    static int Isometric::get_cartesian_y(const int x, const int y); -</i> Convert the y-coordinate from the isometric system to the Cartesian system.<br>
  </big>
  <h2><a id="mozTocId962088" class="mozTocH2"></a><big> Chapter 4. An isometric level</big></h2>
  <big> The isometric level subsystem is intended to help you create an
   isometric level. Just use the <i>Level</i> class to do it. Let's look at the publicly available methods.<br>
   <br>
   <i>Level *Level::get_handle(); -</i> Return the handle to the isometric level subsystem.<br>
   <i><br>
    void Level::initialize(const int tile_width, const int tile_height); -</i> Initialize the subsystem.<br>
   <br>
   <i>void Level::set_offset(const int x_offset, const int y_offset); -</i> Set the coordinates offset.<br>
   <br>
   <i>int Level::get_x_offset() const; -</i> Return the x-offset.<br>
   <br>
   <i>int Level::get_y_offset() const; -</i> Return the y-offset.<br>
   <br>
   <i>int Level::get_x(const int row, const int column) const; -</i> Return the target x-coordinate.<br>
   <i><br>
    int Level::get_y(const int row, const int column) const; -</i> Return the target y-coordinate.<br>
  </big>
  <h1><a id="mozTocId456967" class="mozTocH1"></a><big> Part 5. The common things</big></h1>
  <h2><a id="mozTocId370034" class="mozTocH2"></a><big> Chapter 1. The sub-namespace</big></h2>
  <big> All classes in this section are declared in the <i>Common</i> sub-namespace.<br>
  </big>
  <h2><a id="mozTocId389651" class="mozTocH2"></a><big> Chapter 2. The abnormal program termination</big></h2>
  <big> You can use the <i>Halt</i> function to terminate a program. This function is declared in the <i>BIRD2D</i> namespace.<br>
   <br>
   <i>void BIRD2D::Halt(const char *message); -</i> Terminate the program. Write an error message to the log file if logging is enabled.<br>
  </big>
  <h2><a id="mozTocId649102" class="mozTocH2"></a><big> Chapter 3. The timers</big></h2>
  <big>A timer is a very useful thing. Just use the <i>Timer</i> class to
   work with the timer. Let's look at the publicly available methods.<br>
   <br>
   <i>Timer *Timer::get_handle(); -</i> Return the handle to the timer.<br>
   <br>
   <i>void Timer::set_timer(const double seconds); -</i> Set the timer interval and initialize the start point.<br>
   <br>
   <i>double Timer::get_interval() const; -</i> Return the current timer interval.<br>
   <i><br>
    bool Timer::check_timer(); -</i> Return true and reinitialize the start
   point if the interval between the stop and start points is larger than or
   equal to a specific number of seconds.<br>
  </big>
  <h2><a id="mozTocId241190" class="mozTocH2"></a><big> Chapter 4. The collision detector<br></big></h2>
  <big> <u> An important thing for any game.</u><br>
   <br>
   What is an important thing for a video game? A collision.<br>
   <br>
   <u>The collision details.</u><br>
   <br>
   The detector uses the bounding box collision method to detect a collision.
   The collision-related information is stored in a custom data type.<br>
   <br>
   <i> typedef struct<br>
    {<br>
    unsigned int x;<br>
    unsigned int y;<br>
    unsigned int width;<br>
    unsigned int height;<br>
    } BOX;</i><br>
   <u><br>
    Work with the collision detector.</u><br>
   <br>
   The <i>Collision</i> class provides easy access to the collision
   detectors. It is a simple class with a few methods. Let's look at the publicly available methods.<br>
   <br>
   <i>Collision *Collision::get_handle(); -</i> Return the handle to the collision detector.<br>
   <br>
   <i>void Collision::set_target(const BIRD2D::BOX first_target, const BIRD2D::BOX second_target); -</i> Set the targets for the collision detector.<br>
   <br>
   <i>bool Collision::check_collision() const; -</i> Return true if the collision between two objects is accepted.<br>
   <br>
   <i> bool Collision::check_collision(const BIRD2D::BOX first_target, const BIRD2D::BOX second_target); -</i> Set the targets and check the collision between them.<br>
  </big>
  <h2><a id="mozTocId994359" class="mozTocH2"></a><big> Chapter 5. The tilemaps</big></h2>
  <big> <u>A few words about the tilemap.</u><br>
   <br>
   The tilemap is a tile matrix. A tile is a small, non-transparent sprite. A tilemap is a very useful thing for the background.<br>
   <u><br>
    The rows and columns.</u><br>
   <br>
   The first row index is 0. The first column index is 0.<br>
   <br>
   <u> Work with the tilemap.</u><br>
   <br>
   The <i>Tilemap</i> class provides easy access to the tilemap. It is a
   simple class with a few methods. Let's look at the publicly available methods.<br>
   <br>
   <i>Tilemap *Tilemap::get_handle(); -</i> Return the handle to the tilemap subsystem.<br>
   <br>
   <i>void Tilemap::initialize(const unsigned int tile_width, const unsigned int tile_height); -</i> Initialize the subsystem.<br>
   <br>
   <i>unsigned int Tilemap::get_tile_width() const; -</i> Return the tile width in pixels.<br>
   <i><br>
    unsigned int Tilemap::get_tile_height() const; -</i> Return the tile height in pixels.<br>
   <i><br>
    unsigned int Tilemap::get_x(const unsigned int row) const; -</i> Get the x-coordinate from the target row.<br>
   <i><br>
    unsigned int Tilemap::get_y(const unsigned int column) const; -</i> Get the y-coordinate from the target column.<br>
   <br>
   <i>unsigned int Tilemap::get_row(const unsigned int x) const; -</i> Get the row from the x-coordinate.<br>
   <i><br>
    unsigned int Tilemap::get_column(const unsigned int y) const; -</i> Get the column from the y-coordinate.<br>
   <i><br>
    unsigned int Tilemap::get_row_amount(const unsigned int viewport_width) const; -</i> Get the maximum number of the visible rows.<br>
   <br>
   <i>unsigned int Tilemap::get_column_amount(const unsigned int viewport_width) const; -</i> Get the maximum number of the visible columns.<br>
   <br>
   <i>unsigned int Tilemap::get_tile_amount(const unsigned int viewport_width, const unsigned int viewport_height) const; -</i> Get the maximum number of the visible tiles.<br>
   <br>
   <i>bool Tilemap::check_row(const unsigned int row, const unsigned int
    viewport_width) const; -</i> Return true if the row is valid.<br>
   <br>
   <i>bool Tilemap::check_column(const unsigned int column, const unsigned int viewport_height) const; -</i> Return true if the column is valid.<br>
   <br>
   <i>BIRD2D::BOX Tilemap::get_box(const unsigned int row, const unsigned int column) const; -</i> Return the collision-related information.<br>
  </big>
  <h1><a id="mozTocId373029" class="mozTocH1"></a><big> Part 6. The other important things</big></h1>
  <h2><a id="mozTocId53728" class="mozTocH2"></a><big> Chapter 1. The sub-namespace</big></h2>
  <big> All classes in this section are declared in the <i>Misc</i> sub-namespace.<br>
  </big>
  <h2><a id="mozTocId854878" class="mozTocH2"></a><big> Chapter 2. The Memory</big></h2>
  <big> RAM is an important resource. Just use the <i>Memory</i> class to get
   the total memory size and the free memory size. Let's look at the publicly available methods.<br>
   <br>
   <i>unsigned long long int Memory::get_total_physical(); -</i> Return the total physical memory size in bytes.<br>
   <br>
   <i>unsigned long long int Memory::get_free_physical(); -</i> Return the free physical memory size in bytes.<br>
   <br>
   <i>unsigned long long int Memory::get_total_virtual(); -</i> Return the total virtual memory size in bytes.<br>
   <br>
   <i>unsigned long long int Memory::get_free_virtual(); -</i> Return the free virtual memory size in bytes.<br>
   <br>
   <i>unsigned long long int Memory::get_physical_usge(); -</i> Return the physical memory usage in bytes.<br>
   <br>
   <i>unsigned long long int Memory::get_virtual_usge(); -</i> Return the virtual memory usage in bytes.<br>
  </big>
  <h2><a id="mozTocId188208" class="mozTocH2"></a><big> Chapter 3. The audio</big></h2>
  <big> <u>A few words about the audio subsystem.</u><br>
   <br>
   This subsystem is intended for playing music and sounds.<br>
   <br>
   <u>Working with the audio.</u><br>
   <br>
   Just use the <i>Audio</i> class to work with the audio. Let's look at the publicly available methods.<br>
   <br>
   <i>void Audio::initialize(); -</i> Initialize the subsystem.<br>
   <br>
   <i>void Audio::initialize(const char *target); -</i> Initialize the subsystem and load a sound file.<br>
   <br>
   <i>void Audio::load(const char *target); -</i> Load a sound file.<br>
   <br>
   <i>void Audio::play(); -</i> Play a sound.<br>
   <br>
   <i>void Audio::play_loop(); -</i> Checking the playback status and restarting playback if needed.<br>
   <br>
   <i>void Audio::play(const bool loop); -</i> Play a sound. You can set loop mode if you want.<br>
   <i><br>
    void Audio::stop(); -</i> Stop playing the content of the target file.<br>
   <i><br>
    bool Audio::check_playing(); -</i> Return true if the sound resource is playing.<br>
  </big>
  <h1><a id="mozTocId15273" class="mozTocH1"></a><big> Part 7. Misc</big></h1>
  <h2><a id="mozTocId422364" class="mozTocH2"></a><big> Chapter 1. The Filesystem</big></h2>
  <big> This module is implemented as two simple functions. All these functions are declared in the <i>Filesystem</i> sub-namespace.<br>
   <br>
   <i>file_exist</i>: Check the target file to see if one exists.<br>
   <br>
   <i>delete_file</i>: Deletes the target file.<br>
   <br>
   All functions take the target file name as an argument and return false if the operation failed.<br>
  </big>
  <h2><a id="mozTocId83537" class="mozTocH2"></a><big> Chapter 2. A tool</big></h2>
  <big> This module is implemented as a few functions. All these functions are declared in the <i>Tools</i> sub-namespace.<br>
   <br>
   <i>void quit(); -</i> Exit from your program and return the user to the operating system.<br>
   <br>
   <i>bool enable_logging(const char *name); -</i> Enable redirecting error messages to a log file and return false if the operation failed.<br>
   <br>
   <i>void randomize(); -</i> Initialize the random number generator.<br>
   <i><br>
    unsigned int get_random(const unsigned int number); -</i> Return a random value between zero and the number.<br>
   <br>
   <i>unsigned int get_texture_size(); -</i> Return the maximum width or height of the texture.<br>
   <br>
   <i> BIRD2D::BOX generate_box(const unsigned int x, const unsigned int y, const unsigned int width, const unsigned int height); -</i> Generate the collision-related information.<br>
  </big>
  <h2><a id="mozTocId301368" class="mozTocH2"></a><big> Chapter 3. The resource manager</big></h2>
  <big>A resource is an instance of a user-defined class or structure. The
   resource manager is implemented as a few template functions. All these
   functions are declared in the <i>Resource</i> sub-namespace.<br>
   <br>
   <i>create</i>: Create a resource. The first form of this function creates
   a single resource. It takes a handle to a resource handle as an argument.
   The second form creates an array of the resources. It takes a handle to a resource handle and a resource amount.<br>
   <br>
   <i>destroy</i>: Delete a resource if it already exists. This function takes a resource handle as an argument.<br>
   <br>
   <i>destroy_array</i>: Deletes the resource array if it already exists. This function takes a resource array handle as an argument.<br>
  </big>
  <h1><a id="mozTocId443113" class="mozTocH1"></a><big> Part 8. The binary files</big></h1>
  <h2><a id="mozTocId843024" class="mozTocH2"></a><big> Chapter 1. The sub-namespace</big></h2>
  <big> All classes in this section are declared in the <i>File</i> sub-namespace.<br>
  </big>
  <h2><a id="mozTocId294133" class="mozTocH2"></a><big> Chapter 2. The base binary file subsystem</big></h2>
  <big> <u>Work with the binary files.</u><br>
   <br>
   The <i>Binary_File</i> class provides simple access to the base binary
   subsystem. Don't use it directly. Let's look at the publicly available methods.<br>
   <br>
   <i>void Binary_File::close(); -</i> Close the file.<br>
   <br>
   <i>void Binary_File::set_position(const long int offset); -</i> Set the file position.<br>
   <br>
   <i>long int Binary_File::get_position(); -</i> Return the current file position.<br>
   <br>
   <i>long int Binary_File::get_length(); -</i> Return the file length in bytes.<br>
   <br>
   <i>bool Binary_File::check_error(); -</i> Return true if the last file operation failed.<br>
   <br>
   <i>bool Binary_File::is_open() const; -</i> Return true if the file was successfully opened.<br>
   <br>
   <u>An important notice.</u><br>
   <br>
   The target file size limit is 2 gigabytes.<br>
  </big>
  <h2><a id="mozTocId308140" class="mozTocH2"></a><big> Chapter 3. The file reader</big></h2>
  <big> The file reader is intended to read data from the binary files. The <i>Input_File</i>
   class provides access to a file reader. It is derived from the <i>Binary_File</i>
   class. Let's look at the publicly available methods.<br>
   <i><br>
    Input_File* Input_File::get_handle(); -</i> Return the handle to the file reader.<br>
   <br>
   <i>void Input_File::open(const char *name); -</i> Open a file to read.<br>
   <br>
   <i>void Input_File::read(void *buffer, const size_t length); -</i> Read data from the file.<br>
  </big>
  <h2><a id="mozTocId270683" class="mozTocH2"></a><big> Chapter 4. The file writer</big></h2>
  <big> The file writer is intended to write data to the binary files. The <i>Output_File</i>
   class provides access to a file writer. It is derived from the <i>Binary_File</i>
   class. Let's look at the publicly available methods.<br>
   <br>
   <i>Output_File* Output_File::get_handle(); -</i> Return the handle to the file writer.<br>
   <br>
   <i>void Output_File::open(const char *name); -</i> Open a file to write.<br>
   <br>
   <i>void Output_File::create_temp(); -</i> Create a temporary file. This file will be deleted when it is closed.<br>
   <br>
   <i>void Output_File::write(const void *buffer, const size_t length); -</i> Write data to the file.<br>
   <br>
   void Output_File::flush(); - Force writing the internal buffer data to the file.<br>
  </big>
  <h1><a id="mozTocId638974" class="mozTocH1"></a><big> Part 9. The input</big></h1>
  <h2><a id="mozTocId524142" class="mozTocH2"></a><big> Chapter 1. The sub-namespace</big></h2>
  <big> All classes in this section are declared in the <i>Input</i> sub-namespace.<br>
  </big>
  <h2><a id="mozTocId515445" class="mozTocH2"></a><big> Chapter 2. The keyboard</big></h2>
  <big> <u> The low-level input.</u><br>
   <br>
   Any keyboard has a built-in chip. It generates a special code when the
   user presses or releases the key. This code is called a «scan code».<br>
   <br>
   <u>Working with the keyboard.</u><br>
   <br>
   Just use the <i>Keyboard</i> class to work with a keyboard. Let's look at the publicly available methods.<br>
   <i><br>
    void Keyboard::initialize(); -</i> Initialize the subsystem.<br>
   <br>
   <i>bool Keyboard::check_hold(const unsigned char code); -</i> Return true if a key with a specific scan code is pressed or held.<br>
   <br>
   <i>bool Keyboard::check_press(const unsigned char code); -</i> Return true if a key with a specific scan code was pressed.<br>
   <br>
   <i>bool Keyboard::check_release(const unsigned char code); -</i> Return true if a key with a specific scan code was released.<br>
   <br>
   <i>bool Keyboard::is_ready() const; -</i> Return true if the subsystem has already been initialized.<br>
   <br>
   <u>The list of the supported scan codes.</u><br>
   <br>
   You can see a list of the scan codes below.<br>
   <br>
  </big>
  <table border="1">
   <tbody>
    <tr>
     <td><big>Key</big></td>
     <td><big>Code</big></td>
     <td><big>Key</big></td>
     <td><big>Code</big></td>
     <td><big>Key</big></td>
     <td><big>Code</big></td>
    </tr>
    <tr>
     <td><big>Escape</big></td>
     <td><big>1</big></td>
     <td><big>A</big></td>
     <td><big>30</big></td>
     <td><big>F1</big></td>
     <td><big>59</big></td>
    </tr>
    <tr>
     <td><big>! or 1</big></td>
     <td><big>2</big></td>
     <td><big>S</big></td>
     <td><big>31</big></td>
     <td><big>F2</big></td>
     <td><big>60</big></td>
    </tr>
    <tr>
     <td><big>@ or 2</big></td>
     <td><big>3</big></td>
     <td><big>D</big></td>
     <td><big>32</big></td>
     <td><big>F3</big></td>
     <td><big>61</big></td>
    </tr>
    <tr>
     <td><big># or 3</big></td>
     <td><big>4</big></td>
     <td><big>F</big></td>
     <td><big>33</big></td>
     <td><big>F4</big></td>
     <td><big>62</big></td>
    </tr>
    <tr>
     <td><big>$ or 4</big></td>
     <td><big>5</big></td>
     <td><big>G</big></td>
     <td><big>34</big></td>
     <td><big>F5</big></td>
     <td><big>63</big></td>
    </tr>
    <tr>
     <td><big>% or 5</big></td>
     <td><big>6</big></td>
     <td><big>H</big></td>
     <td><big>35</big></td>
     <td><big>F6</big></td>
     <td><big>64</big></td>
    </tr>
    <tr>
     <td><big>^ or 6</big></td>
     <td><big>7</big></td>
     <td><big>J</big></td>
     <td><big>36</big></td>
     <td><big>F7</big></td>
     <td><big>65</big></td>
    </tr>
    <tr>
     <td><big>&amp; or 7</big></td>
     <td><big>8</big></td>
     <td><big>K</big></td>
     <td><big>37</big></td>
     <td><big>F8</big></td>
     <td><big>66</big></td>
    </tr>
    <tr>
     <td><big>* or 8</big></td>
     <td><big>9</big></td>
     <td><big>L</big></td>
     <td><big>38</big></td>
     <td><big>F9</big></td>
     <td><big>67</big></td>
    </tr>
    <tr>
     <td><big>( or 9</big></td>
     <td><big>10</big></td>
     <td><big>: or ;</big></td>
     <td><big>39</big></td>
     <td><big>F10</big></td>
     <td><big>68</big></td>
    </tr>
    <tr>
     <td><big>0 or )</big></td>
     <td><big>11</big></td>
     <td><big>" or '</big></td>
     <td><big>40</big></td>
     <td><big>F11</big></td>
     <td><big>133</big></td>
    </tr>
    <tr>
     <td><big>_ or |</big></td>
     <td><big>12</big></td>
     <td><big>~ or `</big></td>
     <td><big>41</big></td>
     <td><big>F12</big></td>
     <td><big>134</big></td>
    </tr>
    <tr>
     <td><big>+ or =</big></td>
     <td><big>13</big></td>
     <td><big>Left Shift</big></td>
     <td><big>42</big></td>
     <td><big>Num Lock</big></td>
     <td><big>69</big></td>
    </tr>
    <tr>
     <td><big>Backspace</big></td>
     <td><big>14</big></td>
     <td><big>| or \</big></td>
     <td><big>43</big></td>
     <td><big>Scroll Lock</big></td>
     <td><big>70</big></td>
    </tr>
    <tr>
     <td><big>Tab</big></td>
     <td><big>15</big></td>
     <td><big>Z</big></td>
     <td><big>44</big></td>
     <td><big>Home or 7</big></td>
     <td><big>71</big></td>
    </tr>
    <tr>
     <td><big>Q</big></td>
     <td><big>16</big></td>
     <td><big>X</big></td>
     <td><big>45</big></td>
     <td><big>Up or 8</big></td>
     <td><big>72</big></td>
    </tr>
    <tr>
     <td><big>W</big></td>
     <td><big>17</big></td>
     <td><big>C</big></td>
     <td><big>46</big></td>
     <td><big>Page up or 9</big></td>
     <td><big>73</big></td>
    </tr>
    <tr>
     <td><big>E</big></td>
     <td><big>18</big></td>
     <td><big>V</big></td>
     <td><big>47</big></td>
     <td><big>Gray –</big></td>
     <td><big>74</big></td>
    </tr>
    <tr>
     <td><big>R</big></td>
     <td><big>19</big></td>
     <td><big>B</big></td>
     <td><big>48</big></td>
     <td><big>Left or 4</big></td>
     <td><big>75</big></td>
    </tr>
    <tr>
     <td><big>T</big></td>
     <td><big>20</big></td>
     <td><big>N</big></td>
     <td><big>49</big></td>
     <td><big>Center or 5</big></td>
     <td><big>76</big></td>
    </tr>
    <tr>
     <td><big>Y</big></td>
     <td><big>21</big></td>
     <td><big>M</big></td>
     <td><big>50</big></td>
     <td><big>Right or 6</big></td>
     <td><big>77</big></td>
    </tr>
    <tr>
     <td><big>U</big></td>
     <td><big>22</big></td>
     <td><big>&lt; or ,</big></td>
     <td><big>51</big></td>
     <td><big>Gray +</big></td>
     <td><big>78</big></td>
    </tr>
    <tr>
     <td><big>I</big></td>
     <td><big>23</big></td>
     <td><big>&gt; or .</big></td>
     <td><big>52</big></td>
     <td><big>End or 1</big></td>
     <td><big>79</big></td>
    </tr>
    <tr>
     <td><big>O</big></td>
     <td><big>24</big></td>
     <td><big>?</big></td>
     <td><big>53</big></td>
     <td><big>Down or 2</big></td>
     <td><big>80</big></td>
    </tr>
    <tr>
     <td><big>P</big></td>
     <td><big>25</big></td>
     <td><big>Right shift</big></td>
     <td><big>54</big></td>
     <td><big>Page down or 3</big></td>
     <td><big>81</big></td>
    </tr>
    <tr>
     <td><big>{ or [</big></td>
     <td><big>26</big></td>
     <td><big>Print Surface or *</big></td>
     <td><big>55</big></td>
     <td><big>Insert or 0</big></td>
     <td><big>82</big></td>
    </tr>
    <tr>
     <td><big>} or ]</big></td>
     <td><big>27</big></td>
     <td><big>Alt</big></td>
     <td><big>56</big></td>
     <td><big>Delete or .</big></td>
     <td><big>83</big></td>
    </tr>
    <tr>
     <td><big>Enter</big></td>
     <td><big>28</big></td>
     <td><big>Spacebar</big></td>
     <td><big>57</big></td>
     <td colspan="1" rowspan="2"><br>
     </td>
     <td colspan="1" rowspan="2"><br>
     </td>
    </tr>
    <tr>
     <td><big>Control</big></td>
     <td><big>29</big></td>
     <td><big>Caps Lock</big></td>
     <td><big>58</big></td>
    </tr>
   </tbody>
  </table>
  <big><br>
  </big>
  <h2><a id="mozTocId873525" class="mozTocH2"></a><big> Chapter 3. The mouse</big></h2>
  <big> <u> A few words about mice.</u><br>
   <br>
   A mouse is very useful for interaction with a graphical user interface.
   But the mouse can also be used in video games.<br>
   <br>
   <u>Working with the mouse.</u><br>
   <br>
   Just use the <i>Mouse</i> class to work with a mouse. Let's look at the publicly available methods.<br>
   <br>
   <i>void Mouse::initialize(); -</i> Initialize the subsystem.<br>
   <i><br>
    void Mouse::show(); -</i> Show the mouse cursor.<br>
   <br>
   <i> void Mouse::hide(); -</i> Hide the mouse cursor.<br>
   <br>
   <i>unsigned int Mouse::get_x(); -</i> Return the x-position of the mouse.<br>
   <br>
   <i>unsigned int Mouse::get_y(); -</i> Return the y-position of the mouse.<br>
   <br>
   <i>void Mouse::set_position(const unsigned int x, const unsigned int y); -</i> Set the position of the mouse.<br>
   <br>
   <i>bool Mouse::check_hold(const BIRD2D::MOUSE_BUTTON button); -</i> Return true if a mouse button is pressed or held.<br>
   <i><br>
    bool Mouse::check_press(const BIRD2D::MOUSE_BUTTON button); -</i> Return true if a mouse button was pressed.<br>
   <br>
   <i>bool Mouse::check_release(const BIRD2D::MOUSE_BUTTON button); -</i> Return true if a mouse button was released.<br>
   <br>
   <u>The mouse buttons.</u><br>
   <br>
   The mouse button codes look like the predefined constants. You can see it below.<br>
   <br>
  </big>
  <table border="1">
   <tbody>
    <tr>
     <td><big>Mouse button code</big></td>
     <td><big>Button</big></td>
    </tr>
    <tr>
     <td><big>MOUSE_LEFT</big></td>
     <td><big>Left button</big></td>
    </tr>
    <tr>
     <td><big>MOUSE_RIGHT</big></td>
     <td><big>Right button</big></td>
    </tr>
    <tr>
     <td><big>MOUSE_MIDDLE</big></td>
     <td><big>Middle button</big></td>
    </tr>
   </tbody>
  </table>
  <big><br>
  </big>
  <h2><a id="mozTocId771509" class="mozTocH2"></a><big> Chapter 4. A joystick</big></h2>
  <big> The <i>Joystick</i> class provides simple access to a joystick. It is a simple class with a few methods.<br>
   <br>
   <i>void Joystick::update(); -</i> Update the internal joystick state.<br>
   <br>
   <i>void Joystick::initialize(const char *joystick); -</i> Initialize the subsystem.<br>
   <br>
   <i>bool Joystick::is_ready() const; -</i> Return true if the subsystem has already been initialized.<br>
   <br>
   <i>bool Joystick::check_hold(const size_t button) const; -</i> Return true if the button is pressed or held.<br>
   <br>
   <i>bool Joystick::check_press(const size_t button) const; -</i> Return true if the button was pressed.<br>
   <br>
   <i>bool Joystick::check_released(const size_t button) const; -</i> Return true if the button was released.<br>
   <br>
   <i>short int Joystick::get_axis(const size_t target); -</i> Return the current value of the joystick axis.<br>
   <br>
   <i>size_t Joystick::get_button_amount() const; -</i> Return the number of the joystick buttons.<br>
   <i><br>
    size_t Joystick::get_axes() const; -</i> Return the number of the joystick axes.<br>
  </big>
  <h1><a id="mozTocId104989" class="mozTocH1"></a><big> Part 10. The internal details of the engine subsystems</big></h1>
  <h2><a id="mozTocId841757" class="mozTocH2"></a><big> Chapter 1. A few words for a curious programmer</big></h2>
  <big> <br>
   The engine subsystems have a different internal structure. It has been
   hidden from you, and you don't have access to it. Do you want to know
   about the hidden things? Just read the next chapter.<br>
  </big>
  <h2><a id="mozTocId136763" class="mozTocH2"></a><big> Chapter 2. The internal classes</big></h2>
  <big> <u> The internal classes.</u><br>
   <br>
   Some classes are designed for internal use only. Don't touch them. What are these strange classes doing?<br>
   <u><br>
    The Unix-specific classes.</u><br>
   <br>
   All Unix-specific classes are declared in the Internal sub-namespace.<br>
   <br>
   <i> Engine</i> creates the game window and does message processing.<br>
   <i> Synchronization</i> implements the synchronization timer.<br>
   <br>
   <u>The core classes.</u><br>
   <br>
   All engine core classes and functions are declared in the <i>Core</i> sub-namespace.<br>
   <br>
   <i> FPS</i> implements the FPS counter.<br>
   <i> Render</i> implements the OpenGL render.<br>
   <i> Resizer</i> is intended to calculate the correct texture size.<br>
   <i> Rectangle</i> is intended to draw a textured rectangle.<br>
   <i> Shape</i> is the base class of the Rectangle class.<br>
  </big>
  <h2><a id="mozTocId388620" class="mozTocH2"></a><big> Chapter 3. The base graphics subsystem</big></h2>
  <big> <u> The visible object.</u><br>
   <br>
   Any visible object is a textured rectangle.<br>
   <br>
   <u>The textures.</u><br>
   <br>
   A texture width must be a power of two. A texture height also must be a
   power of two. Any image will be automatically resized before uploading.<br>
   <br>
   <u>The vertex array and the texture coordinates array.</u><br>
   <br>
   Any rectangle needs four vertices and four texture coordinates.<br>
   A single vertex represents the following custom data type:<br>
   <br>
   <i> typedef struct Vertex<br>
    {<br>
     int x;<br>
     int y;<br>
    };</i><br>
   <br>
   A single texture coordinate represents the following custom data type:<br>
   <br>
   <i> typedef struct<br>
    {<br>
     float u;<br>
     float v;<br>
    } Point;</i><br>
   <br>
   All these custom types are declared in the <i>Core</i> sub-namespace.<br>
  </big>
  <h2><a id="mozTocId762700" class="mozTocH2"></a><big> Chapter 4. A joystick</big></h2>
  <big> The joystick subsystem is working over the <a href="https://www.kernel.org/doc/Documentation/input/joystick-api.txt">Linux Joystick API</a>.<br>
  </big>
  <h2><a id="mozTocId341329" class="mozTocH2"></a><big> Chapter 5. The input</big></h2>
  <big> <u>The input backend.</u><br>
   <br>
   The input subsystem is the simple thing. It works over <a href="https://gitlab.freedesktop.org/xorg/lib/libx11">Xlib</a>.<br>
   <br>
   <u>The internal key state.</u><br>
   <br>
   The internal state of a key looks like the predefined constants. You can see it below.<br>
   <br>
  </big>
  <table border="1">
   <tbody>
    <tr>
     <td><big>Key/button state</big></td>
     <td><big>Description</big></td>
    </tr>
    <tr>
     <td><big>KEY_PRESSED</big></td>
     <td><big>A key or button is pressed or held.</big></td>
    </tr>
    <tr>
     <td><big>KEY_RELEASED</big></td>
     <td><big>A key or button was released.</big></td>
    </tr>
   </tbody>
  </table>
  <big><br>
  </big>
  <h2><a id="mozTocId784958" class="mozTocH2"></a><big> Chapter 6. The audio</big></h2>
  <big> The audio subsystem is working over <a href="https://www.videolan.org/vlc/libvlc.html">libVLC</a>.<br>
  </big>
  <h1><a id="mozTocId707314" class="mozTocH1"></a><big>Version history</big></h1>
  <big> 0.1: Initial version.<br>
   0.1.1-0.3.4: The unstable branch.<br>
   0.3.5: The preview release.<br>
   0.3.6-0.3.7: The small changes.<br>
   0.3.8: The full-screen mode has been implemented.<br>
   0.3.9: The mouse input has improved.<br>
   0.4: The keyboard input has improved.<br>
   0.4.1: The mouse input has improved.<br>
   0.4.2-0.4.3: The small changes.<br>
   0.4.4: The makefile has been updated.<br>
   0.4.5: The new subsystem has been added.<br>
   0.4.5-0.4.9: The small changes.<br>
   0.5-0.5.3: The mouse input has improved.<br>
   0.5.4-0.5.6: The small changes.<br>
   0.5.7: The stable release.<br>
   0.5.8: The small changes.<br>
   0.5.9: The joystick support has been added.<br>
   0.6-0.7.3: The joystick support has improved.<br>
   0.7.4: The small changes.<br>
   0.7.4.1: The documentation has been updated.<br>
   0.7.5: The memory leak has been.<br>
   0.7.6: The memory usage has reduced.<br>
   0.7.7: The sound support has been added.<br>
   0.7.8-0.9.5: The sound support has improved.<br>
   0.9.6-1.0: The small changes.<br>
   1.0.1-1.0.2: A small bug has been fixed.<br>
   1.0.3: The memory usage has reduced.<br>
   1.0.3-1.0.8: The audio loader has improved.<br>
   1.0.9-1.1.1: The small changes.<br>
   1.1.2-1.1.9: The low-level sound subsystem has improved.<br>
   1.2: The memory leak has been.<br>
   1.2.1-1.2.3: The small bug has been fixed.<br>
   1.2.4-1.2.5: The small changes.<br>
   1.2.6: The small bug has been.<br>
   1.2.7-1.2.9: The small changes.<br>
   1.3: The audio subsystem was totally rewritten.<br>
   1.3.1-1.3.3: The audio subsystem has improved.<br>
   1.3.4-1.3.6: The small changes.<br>
   1.3.7: The image resizer is backported from the Simple Windows Game Framework 7.3.5.<br>
   1.3.8: The image resizer is backported from the Eugene Game Development Kit 7.3.7.<br>
   1.3.9: The tilemap subsystem is backported from the Eugene Game Development Kit 7.4.4.<br>
   1.4: The image resizer is backported from the Eugene Game Development Kit 7.3.5.<br>
   1.4.1: The image resizer is backported from the Eugene Game Development Kit 7.5.<br>
   1.4.2 The coordinates conversion subsystem is backported from the Eugene Game Development Kit 7.5.3.<br>
   1.4.3: The keyboard input has improved.<br>
   1.4.4: The coordinates conversion subsystem is backported from the Eugene Game Development Kit 7.5.4.<br>
   1.4.5: The keyboard input has improved.<br>
   1.4.6 The coordinates conversion subsystem is backported from the Eugene Game Development Kit 7.5.8.<br>
   1.4.7: The source code synced with the Eugene Game Development Kit 7.6.3.<br>
   1.4.8: The tile-map subsystem is backported from the Eugene Game Development Kit 7.6.4.<br>
   1.4.9: The coordinates conversion subsystem is backported from the Eugene Game Development Kit 7.6.5.<br>
   1.5: The base graphics subsystem has improved.<br>
   1.5.1: The image resizer is backported from the Eugene Game Development Kit 7.6.8.<br>
   1.5.2: The image resizer is backported from the Eugene Game Development Kit 7.6.9.<br>
   1.5.3: The image resizer is backported from the Eugene Game Development Kit 7.7.<br>
   1.5.4: The image resizer is backported from the Eugene Game Development Kit 7.7.2.<br>
   1.5.5: The image resizer is backported from the Eugene Game Development Kit 7.7.3.<br>
   1.5.6: The image resizer is backported from the Eugene Game Development Kit 7.7.4.<br>
   1.5.7: The image resizer is backported from the Eugene Game Development Kit 7.7.5.<br>
   1.5.8: The image resizer is backported from the Eugene Game Development Kit 7.7.6.<br>
   1.5.9: The synchronization timer has improved.<br>
   1.6: The isometric subsystem is backported from the Eugene Game Development Kit 7.8.<br>
   1.6.1: The isometric subsystem is backported from the Eugene Game Development Kit 7.8.1.<br>
   1.6.2: The isometric level subsystem is backported from the Eugene Game Development Kit 7.8.4.<br>
   1.6.3: The animation subsystem is backported from the Eugene Game Development Kit 7.8.6.<br>
   1.6.4: The sprite sheet subsystem is backported from the Eugene Game Development Kit 7.8.8.<br>
   1.6.5: The base sprite subsystem is backported from the Eugene Game Development Kit 7.8.9.<br>
   1.6.6: The text drawing subsystem is backported from the Eugene Game Development Kit 7.9.<br>
   1.6.7: The base sprite subsystem is backported from the Eugene Game Development Kit 7.9.1.<br>
   1.6.8: The background subsystem is backported from the Eugene Game Development Kit 7.9.2.<br>
   1.6.9: The static sprite subsystem is backported from the Eugene Game Development Kit 7.9.3.<br>
   1.7: The static background subsystem is backported from the Eugene Game Development Kit 7.9.4.<br>
   1.7.1: The source code synced with the Eugene Game Development Kit 7.9.5.<br>
   1.7.2: The source code synced with the Eugene Game Development Kit 7.9.6.<br>
   1.7.3: The base sprite subsystem is backported from the Eugene Game Development Kit 7.9.7.<br>
   1.7.4: The image loader is backported from the Eugene Game Development Kit 7.9.8.<br>
   1.7.5: The image resizer is backported from the Eugene Game Development Kit 8.0.3.<br>
   1.7.6: The source code synced with the Eugene Game Development Kit 8.0.4.<br>
   1.7.7: The source code synced with the Eugene Game Development Kit 8.0.5.<br>
   1.7.8: The source code synced with the Eugene Game Development Kit 8.0.8.<br>
   1.7.9: The source code synced with the Eugene Game Development Kit 8.0.9.<br>
   1.8: The source code synced with the Eugene Game Development Kit 8.1.4.<br>
   1.8.1: The source code synced with the Eugene Game Development Kit 8.1.5.<br>
   1.8.2: The source code synced with the Eugene Game Development Kit 8.1.6.<br>
   1.8.3: The source code synced with the Eugene Game Development Kit 8.1.7.<br>
   1.8.4: The source code synced with the Eugene Game Development Kit 8.1.8.<br>
   1.8.5: The source code synced with the Eugene Game Development Kit 8.2.1.<br>
   1.8.6: The small changes.<br>
   1.8.7: The source code synced with the Eugene Game Development Kit 8.2.2.<br>
   1.8.8: The source code synced with the Eugene Game Development Kit 8.2.3.<br>
   1.8.9: The source code synced with the Eugene Game Development Kit 8.2.6.<br>
   1.9: The source code synced with the Eugene Game Development Kit 8.2.8.<br>
   1.9.1: The source code synced with the Eugene Game Development Kit 8.3.<br>
   1.9.2: The source code synced with the Eugene Game Development Kit 8.3.1.<br>
   1.9.3: The source code synced with the Eugene Game Development Kit 8.3.2.<br>
   1.9.4: The source code synced with the Eugene Game Development Kit 8.3.3.<br>
   1.9.5: The source code synced with the Eugene Game Development Kit 8.3.4.<br>
   1.9.6: The source code synced with the Eugene Game Development Kit 8.4.2.<br>
   1.9.7: The source code synced with the Eugene Game Development Kit 8.4.4.<br>
   1.9.8: The source code synced with the Eugene Game Development Kit 8.4.5.<br>
   1.9.8.1: The documentation has been updated.<br>
   1.9.9: The source code synced with the Eugene Game Development Kit 8.4.6.<br>
   2.0: The source code synced with the Eugene Game Development Kit 8.4.8.<br>
   2.0.1: The source code synced with the Eugene Game Development Kit 8.5.<br>
   2.0.2: The source code synced with the Eugene Game Development Kit 8.5.5.<br>
   2.0.3: The source code synced with the Eugene Game Development Kit 8.5.6.<br>
   2.0.4: The source code synced with the Eugene Game Development Kit 8.5.7.<br>
   2.0.5: The source code synced with the Eugene Game Development Kit 8.5.8.<br>
   2.0.6: The source code synced with the Eugene Game Development Kit 8.5.9.<br>
   2.0.7: The source code synced with the Eugene Game Development Kit 8.6.<br>
   2.0.8: The source code synced with the Eugene Game Development Kit 8.6.1.<br>
   2.0.9: The source code synced with the Eugene Game Development Kit 8.6.2.<br>
   2.1: The source code synced with the Eugene Game Development Kit 8.6.5.<br>
   2.1.1: The source code synced with the Eugene Game Development Kit 8.6.6.<br>
   2.1.2: The source code synced with the Eugene Game Development Kit 8.6.8.<br>
   2.1.3: The small changes.<br>
   2.1.4: The source code synced with the Eugene Game Development Kit 8.7.1.<br>
   2.1.5: The source code synced with the Eugene Game Development Kit 8.7.2.<br>
   2.1.6: The source code synced with the Eugene Game Development Kit 8.7.8.<br>
   2.1.7: The source code synced with the Eugene Game Development Kit 8.8.5.<br>
   2.1.8: The source code synced with the Black Game Development Kit 5.8.2.<br>
   2.1.9: The source code synced with the Eugene Game Development Kit 8.8.7.<br>
   2.2: The source code synced with the Eugene Game Development Kit 8.8.8.<br>
   2.2.1: The source code synced with the Black Game Development Kit 5.8.7.<br>
   2.2.2: The source code synced with the Black Game Development Kit 5.8.8.<br>
   2.2.3: The source code synced with the Black Game Development Kit 5.9.<br>
   2.2.4: The source code synced with the Black Game Development Kit 5.9.4.<br>
   2.2.5: The source code synced with the Black Game Development Kit 5.9.6.<br>
   2.2.6: The small changes.<br>
   2.2.7: The source code synced with the Eugene Game Development Kit 8.9.9.<br>
   2.2.8: The keyboard input subsystem is backported from the Neon Game Development Kit 7.9.1.<br>
   2.2.9: The source code synced with the Eugene Game Development Kit 9.0.3.<br>
   2.3: The source code synced with the Eugene Game Development Kit 9.0.4.<br>
   2.3.1: The source code synced with the Eugene Game Development Kit 9.0.5.<br>
   2.3.2: The source code synced with the Eugene Game Development Kit 9.0.6.<br>
   2.3.3: The source code synced with the Eugene Game Development Kit 9.0.7.<br>
   2.3.4: The source code synced with the Eugene Game Development Kit 9.0.8.<br>
   2.3.5: The source code synced with the Eugene Game Development Kit 9.0.9.<br>
   2.3.5.1-2.3.5.1: The documentation has been updated.<br>
   2.3.6: The memory subsystem has improved.<br>
   2.3.7: The source code synced with the Eugene Game Development Kit 9.1.<br>
   2.3.8: The source code synced with the Eugene Game Development Kit 9.2.1.<br>
   2.3.9: The source code synced with the Eugene Game Development Kit 9.2.2.<br>
   2.3.9.1: The documentation has been updated.<br>
   2.4: The source code synced with the Eugene Game Development Kit 9.2.3.<br>
   2.4.0.1-2.4.0.4: The documentation has been updated.<br>
   2.4.1: The small changes.<br>
   2.4.1.1: The documentation has been updated.<br>
   2.4.2: The source code synced with the Eugene Game Development Kit 9.2.6.<br>
   2.4.3: The source code synced with the Eugene Game Development Kit 9.2.7.<br>
   2.4.3.1: The documentation has been updated.<br>
   2.4.4: The source code synced with the Eugene Game Development Kit 9.2.8.<br>
   2.4.5: The makefile has been updated.<br>
   2.4.6: The source code synced with the Eugene Game Development Kit 9.2.9.<br>
   2.4.7: The source code synced with the Eugene Game Development Kit 9.3.<br>
   2.4.8: The source code synced with the Eugene Game Development Kit 9.3.1.<br>
   2.4.9: The source code synced with the Eugene Game Development Kit 9.3.5.<br>
   2.5: The source code synced with the Eugene Game Development Kit 9.3.6.<br>
   2.5.1: The source code synced with the Eugene Game Development Kit 9.3.9.<br>
   2.5.2: The source code synced with the Eugene Game Development Kit 9.4.<br>
   2.5.3: The source code synced with the Eugene Game Development Kit 9.4.1.<br>
   2.5.4: The source code synced with the Eugene Game Development Kit 9.4.2.<br>
   2.5.5: The source code synced with the Eugene Game Development Kit 9.4.3.<br>
   2.5.6: The source code synced with the Eugene Game Development Kit 9.4.4.<br>
   2.5.7: The source code synced with the Eugene Game Development Kit 9.4.5.<br>
   2.5.8: The source code synced with the Eugene Game Development Kit 9.4.6.<br>
   2.5.9: The source code synced with the Eugene Game Development Kit 9.4.7.<br>
   2.6: The source code synced with the Eugene Game Development Kit 9.4.8.<br>
   2.6.1: The source code synced with the Eugene Game Development Kit 9.4.9.<br>
   2.6.2: The source code synced with the Eugene Game Development Kit 6.4.7.<br>
   2.6.2.1: The small changes.<br>
   2.6.3: The source code synced with the Black Game Development Kit 6.4.9.<br>
   2.6.4: The source code synced with the Black Game Development Kit 6.5.1.<br>
   2.6.5: The source code synced with the Eugene Game Development Kit 9.5.3.<br>
   2.6.6: The source code synced with the Eugene Game Development Kit 9.5.4.<br>
   2.6.7: The source code synced with the Eugene Game Development Kit 9.5.5.<br>
   2.6.8: The source code synced with the Eugene Game Development Kit 9.5.6.<br>
   2.6.9: The source code synced with the Eugene Game Development Kit 9.5.7.<br>
   2.7: The small changes.<br>
   2.7.1: The source code synced with the Black Game Development Kit 7.3.3.<br>
   2.7.2: The source code synced with the Black Game Development Kit 7.3.5.<br>
   2.7.3: The source code synced with the Black Game Development Kit 7.3.8.<br>
   2.7.4: The source code synced with the Black Game Development Kit 7.3.9.<br>
   2.7.5: The source code synced with the Eugene Game Development Kit 9.6.2.<br>
   2.7.6: The source code synced with the Black Game Development Kit 7.4.8.<br>
   2.7.6.1: The documentation has been updated.<br>
   2.7.7: The source code synced with the Black Game Development Kit 7.5.<br>
   2.7.8: The source code synced with the Black Game Development Kit 7.5.1.<br>
   2.7.8.1: The documentation has been updated.<br>
   2.7.9: The source code synced with the Black Game Development Kit 7.5.2.<br>
   2.7.9.1-2.7.9.2: The documentation has been updated.<br>
   2.8: The synchronization timer has improved.<br>
   2.8.1: The small changes.<br>
   2.8.1.1-2.8.1.2: The documentation has been updated.<br>
   2.8.2: The source code synced with the Eugene Game Development Kit 9.7.<br>
   2.8.2.1-2.8.2.4: The documentation has been updated.<br>
   2.8.3: The source code synced with the Eugene Game Development Kit 9.7.1.<br>
   2.8.4: The source code synced with the Eugene Game Development Kit 9.7.2.<br>
   2.8.5: The source code synced with the Eugene Game Development Kit 9.7.3.<br>
   2.8.6: The source code synced with the Eugene Game Development Kit 9.7.4.<br>
   2.8.7: The small changes.<br>
   2.8.8: The source code synced with the Eugene Game Development Kit 9.7.5.<br>
   2.8.9: The source code synced with the Eugene Game Development Kit 9.7.6.<br>
   2.8.9.1: The documentation has been updated.<br>
   2.9: The source code synced with the Eugene Game Development Kit 9.7.7.<br>
   2.9.1: The source code synced with the Eugene Game Development Kit 9.7.8.<br>
   2.9.2: The source code synced with the Eugene Game Development Kit 9.8.<br>
   2.9.3: The source code synced with the Eugene Game Development Kit 9.8.1.<br>
  </big>
 </body>
</html>