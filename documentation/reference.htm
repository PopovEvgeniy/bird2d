<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=windows-1251">
    <title>Programmer reference</title>
  </head>
  <body>
    <p> <big> </big> </p>
    <div style="text-align: center;"><big>Bird 2d: Programmer reference</big><br>
    </div>
    <br>
    <big> Table of contents</big>
    <ul id="mozToc">
      <!--mozToc h1 1 h2 2 h3 3 h4 4 h5 5 h6 6-->
      <li><a href="#mozTocId665557">Part 1. Welcome to Bird 2D</a>
        <ul>
          <li><a href="#mozTocId471990">Chapter 1. Introduction</a></li>
          <li><a href="#mozTocId85003">Chapter 2. A special thanks</a></li>
          <li><a href="#mozTocId810132">Chapter 3. License</a></li>
          <li><a href="#mozTocId56069">Chapter 4. Dependencies</a></li>
          <li><a href="#mozTocId914689">Chapter 5. The engine name–space</a></li>
          <li><a href="#mozTocId417277">Chapter 6. Custom date types</a></li>
        </ul>
      </li>
      <li><a href="#mozTocId859712">Part 2. Base things</a>
        <ul>
          <li><a href="#mozTocId312970">Chapter 1. Coordinate system</a></li>
          <li><a href="#mozTocId544184">Chapter 2. A game cycle</a></li>
        </ul>
      </li>
      <li><a href="#mozTocId760374">Part 3. Graphics</a>
        <ul>
          <li><a href="#mozTocId182571">Chapter 1. The sub–namespace</a></li>
          <li><a href="#mozTocId552078">Chapter 2. Base graphics subsystem</a></li>
          <li><a href="#mozTocId289525">Chapter 3. Picture subsystem</a></li>
          <li><a href="#mozTocId501089">Chapter 4. Animation subsystem</a></li>
          <li><a href="#mozTocId904725">Chapter 5. Image kind</a></li>
          <li><a href="#mozTocId738557">Chapter 6. Background</a></li>
          <li><a href="#mozTocId573639">Chapter 7. Static background</a></li>
          <li><a href="#mozTocId309905">Chapter 8. Base sprite subsystem</a></li>
          <li><a href="#mozTocId662651">Chapter 9. Ordinary sprites</a></li>
          <li><a href="#mozTocId66751">Chapter 10. Static sprites</a></li>
          <li><a href="#mozTocId146800">Chapter 11. Sprite sheet</a></li>
          <li><a href="#mozTocId752257">Chapter 12. Text</a></li>
          <li><a href="#mozTocId67980">Chapter 13. Loading images</a></li>
        </ul>
      </li>
      <li><a href="#mozTocId696454">Part 4. Transformation</a>
        <ul>
          <li><a href="#mozTocId933730">Chapter 1. The sub–namespace</a></li>
          <li><a href="#mozTocId952856">Chapter 2. Cartesian coordinates and
              screen coordinates</a></li>
          <li><a href="#mozTocId446824">Chapter 3. Cartesian coordinates and
              isometric coordinates</a></li>
          <li><a href="#mozTocId143616">Chapter 4. Isometric level</a></li>
        </ul>
      </li>
      <li><a href="#mozTocId64443">Part 5. Common things</a>
        <ul>
          <li><a href="#mozTocId597525">Chapter 1. The sub–namespace</a></li>
          <li><a href="#mozTocId853711">Chapter 2. Abnormal program termination</a></li>
          <li><a href="#mozTocId656377">Chapter 3. Timer</a></li>
          <li><a href="#mozTocId381935">Chapter 4. Collision</a></li>
          <li><a href="#mozTocId423669">Chapter 5. Tile–map</a></li>
        </ul>
      </li>
      <li><a href="#mozTocId611802">Part 6. Other important things</a>
        <ul>
          <li><a href="#mozTocId900597">Chapter 1. The sub–namespace</a></li>
          <li><a href="#mozTocId942355">Chapter 2. Memory</a></li>
          <li><a href="#mozTocId522782">Chapter 3. Audio</a></li>
        </ul>
      </li>
      <li><a href="#mozTocId209024">Part 7. Misc</a>
        <ul>
          <li><a href="#mozTocId608755">Chapter 1. File system</a></li>
          <li><a href="#mozTocId59386">Chapter 2. Tools</a></li>
          <li><a href="#mozTocId573582">Chapter 3. Resource manager</a></li>
        </ul>
      </li>
      <li><a href="#mozTocId590919">Part 8. Binary files</a>
        <ul>
          <li><a href="#mozTocId200879">Chapter 1. The sub–namespace</a></li>
          <li><a href="#mozTocId961921">Chapter 2. Base binary file subsystem</a></li>
          <li><a href="#mozTocId424835">Chapter 3. File reader</a></li>
          <li><a href="#mozTocId511135">Chapter 4. File writer</a></li>
        </ul>
      </li>
      <li><a href="#mozTocId291572">Part 9. Input</a>
        <ul>
          <li><a href="#mozTocId783369">Chapter 1. The sub–namespace</a></li>
          <li><a href="#mozTocId685403">Chapter 2. Keyboard</a></li>
          <li><a href="#mozTocId686993">Chapter 3. Mouse</a></li>
          <li><a href="#mozTocId316549">Chapter 3. Joystick</a></li>
        </ul>
      </li>
      <li><a href="#mozTocId309127">Part 10. Internal details of the engine
          subsystems</a>
        <ul>
          <li><a href="#mozTocId383177">Chapter 1. A few words for a curious
              programmer</a></li>
          <li><a href="#mozTocId318160">Chapter 2. Internal classes</a></li>
          <li><a href="#mozTocId293644">Chapter 3. Base graphics subsystem</a></li>
          <li><a href="#mozTocId804583">Chapter 4. Input</a></li>
          <li><a href="#mozTocId389200">Chapter 5. Joystick</a></li>
          <li><a href="#mozTocId45292">Chapter 6. Audio subsystem</a></li>
        </ul>
      </li>
      <li><a href="#mozTocId78453">Version history</a></li>
    </ul>
    <big> </big>
    <h1><a name="mozTocId665557" class="mozTocH1"></a><big>Part 1. Welcome to
        Bird 2D<br>
      </big></h1>
    <big> </big>
    <h2><a name="mozTocId471990" class="mozTocH2"></a><big>Chapter 1.
        Introduction</big></h2>
    <big> <span style="text-decoration: underline;"> Introduction</span><br>
      <br>
      Hello from Russia. My name is Popov Evgeniy Alekseyevich. I am the
      individual programmer. I enjoy creating software. I also like old–school
      video games. Do you want to develop video games for <a href="https://en.wikipedia.org/wiki/Linux">Linux</a>?
      You need a good game engine for doing it. I made my own engine. I hope
      that my C++ game engine will be useful for many programmers.<br>
      <span style="text-decoration: underline;"> Features</span><br>
      <br>
      Let me show the engine features. Let's go. </big>
    <ul>
      <li><big>Open source code.</big></li>
      <li><big>Easy to use object–orientated design.</big></li>
      <li><big>Very fast.</big></li>
      <li><big>Minimum external dependencies: only <a href="https://gitlab.freedesktop.org/xorg/lib/libx11">Xlib</a>,
          <a href="https://mesa3d.org">Mesa 3d</a>, and <a href="https://www.videolan.org/vlc/libvlc.html">libVLC</a>.<br>
        </big></li>
    </ul>
    <big><br>
      <span style="text-decoration: underline;"> Feedback</span><br>
      <br>
      Send me <a href="mailto:tuzik87@inbox.ru">e–mail</a> if you want contact
      with me. </big>
    <h2><a name="mozTocId85003" class="mozTocH2"></a><big>Chapter 2. A special
        thanks</big></h2>
    <big><br>
      I want to say «Big thanks for technical consultation» to these peoples: </big>
    <ul>
      <li><a href="https://github.com/dmitrysmagin"><big>Dmitry Smagin</big></a></li>
      <li><a href="https://bsg.org.ua"><big>Pavel Samko</big></a></li>
      <li><a href="https://github.com/EXL"><big>EXL</big></a></li>
      <li><a><big>Vladimir Mozhenkov</big></a></li>
      <li><a href="https://vk.com/strong666"><big>Vitaliy Molochkov</big></a></li>
      <li><a href="mailto:eyegem@mail.ru"><big>Evgenia Germanova</big></a></li>
      <li><big>DDMZ</big></li>
      <li><big>Anastasiya</big></li>
    </ul>
    <big><br>
      Also thanks to PVS–Studio team for <a href="https://www.viva64.com/en/b/0614/">free
        license</a>. </big>
    <h2><a name="mozTocId810132" class="mozTocH2"></a><big>Chapter 3. License</big></h2>
    <big> Copyright (C) 2023 </big><big>– 2024</big><big> Popov Evgeniy
      Alekseyevich<br>
      <br>
      This software is provided 'as–is', without any express or implied<br>
      warranty. In no event will the authors be held liable for any damages<br>
      arising from the use of this software.<br>
      Permission is granted to anyone to use this software for any purpose,<br>
      including commercial applications, and to alter it and redistribute it<br>
      freely, subject to the following restrictions:<br>
      <br>
      1. The origin of this software must not be misrepresented; you must not<br>
      claim that you wrote the original software. If you use this software<br>
      in a product, an acknowledgment in the product documentation would be<br>
      appreciated but is not required.<br>
      2. Altered source versions must be plainly marked as such, and must not be<br>
      misrepresented as being the original software.<br>
      3. This notice may not be removed or altered from any source distribution.<br>
    </big>
    <h2><a name="mozTocId56069" class="mozTocH2"></a><big>Chapter 4. </big><big>Dependencies</big></h2>
    <big><span style=""></span></big><big>You need&nbsp; libx11</big><big>-</big><big>dev,
      libgl1</big><big>-</big><big>mesa</big><big>-</big><big>dev packages and
      libvlc</big><big>-</big><big>dev for compile this game engine.</big>
    <h2><a name="mozTocId914689" class="mozTocH2"></a><big>Chapter 5. The engine
        name–space</big></h2>
    <big><span style="font-style: italic;">BIRD2D</span> is the main name–space.</big><big>
      All the engine classes declared in few nested namespaces.<br>
    </big>
    <h2><a name="mozTocId417277" class="mozTocH2"></a><big>Chapter 6. Custom
        date types</big></h2>
    <big>Almost all custom data types declared in <span style="font-style: italic;">BIRD2D</span>
      namespace.<br>
    </big>
    <h1><a name="mozTocId859712" class="mozTocH1"></a><big>Part 2. Base things</big></h1>
    <big> </big>
    <h2><a name="mozTocId312970" class="mozTocH2"></a><big>Chapter 1. Coordinate
        system</big></h2>
    <big><br>
      The engine uses standard coordinate system by default. Coordinates start
      at top–left corner. Look to this picture to understand it.<br>
      <br>
      <img style="width: 107px; height: 111px;" alt="" src="coordinate_system.png">
    </big>
    <h2><a name="mozTocId544184" class="mozTocH2"></a><big>Chapter 2. A game
        cycle</big></h2>
    <big><br>
      What is the main point in your game? A game cycle. You can see the
      structure of a typical game cycle below.<br>
      <br>
      <img style="width: 379px; height: 354px;" alt="" src="game_cycle.png"> </big>
    <h1><a name="mozTocId760374" class="mozTocH1"></a><big>Part 3. Graphics</big></h1>
    <h2><a name="mozTocId182571" class="mozTocH2"></a><big>Chapter 1. The
        sub–namespace</big></h2>
    <big>All subsystems in this section declared in <i>Graphics</i>
      sub–namespace.</big><br>
    <big> </big>
    <h2><a name="mozTocId552078" class="mozTocH2"></a><big>Chapter 2. Base
        graphics subsystem</big></h2>
    <big> <span style="text-decoration: underline;"> Introduce to base graphics
        subsystem</span><br>
      <br>
      Base graphics subsystem do rendering game scene. This subsystem using <a
        href="http://opengl.org">OPENGL</a> for render. Most modern video–card
      support hardware accelerated OPENGL. Software emulated OPENGL will
      activate if </big><big>hardware acceleration not available.<br>
      <br>
    </big> <big> <span style="text-decoration: underline;"> Render performance</span><br>
      <br>
      Always use latest video–card drivers. It can increase render performance.
      You can also try to change screen resolution if you have low render
      performance.<br>
      <br>
      <span style="text-decoration: underline;"> Fps limitation</span><br>
      <br>
      Fps is an important thing. Many fps need for good animation, but it also
      needs high processor usage. Fps limit is 60 by default. It is optimal
      value.<br>
      <br>
      <span style="text-decoration: underline;"> Work with base graphics
        subsystem</span><br>
      <br>
      <span style="font-style: italic;"> Surface</span> class provide access to
      the base graphic subsystem. Let's look at public methods.<br>
      <br>
      <span style="font-style: italic;"> void Surface::clear_screen();</span> –
      Clear the screen. Fill it by black color.<br>
      <br>
      <span style="font-style: italic;"> void Surface::initialize();</span> –
      Initialize the base graphic subsystem with default screen resolution.<br>
    </big><big style=""></big><big style="font-style: italic;"><br>
    </big><big> <span style="font-style: italic;"> bool Surface::sync();</span>
      – Show current back–buffer content on screen. Return false if a game is
      terminated. This method uses fps limit and do wait between frames.<br>
      <br>
      <span style="font-style: italic;"> bool Surface::update();</span> – Show
      current back–buffer content on screen. Return false if a game is
      terminated. This method ignoring fps limit and need high processor usage.<br>
      <br>
      <span style="font-style: italic;">bool Surface::sync(const bool limit);</span>
      – Show current back–buffer content on screen. Return false if a game is
      terminated.<br>
      <br>
      <span style="font-style: italic;"> bool Surface::is_ready();</span> –
      Return true if the subsystem is already initialized.<br>
      <span style=""></span><br>
      <span style="font-style: italic;"> unsigned int Surface::get_fps() const;</span>
      – Return current fps value.<br>
      <br>
      <span style="font-style: italic;"> unsigned int Surface::get_color()
        const;</span> – Return current color depth in bits per pixel.<br>
      <br>
      <span style="font-style: italic;"> unsigned int Surface::get_width()
        const;</span> – Return screen width in pixels.<br>
      <br>
      <span style="font-style: italic;"> unsigned int Surface::get_height()
        const;</span> – Return screen height in pixels.<br>
      <br>
      <span style="font-style: italic;">bool Surface::check_x(const unsigned int
        x) const;</span> – Return true if x-coordinate is valid.<br>
      <br>
      <span style="font-style: italic;">bool Surface::check_y(const unsigned int
        y) const;</span> – Return true if y-coordinate is valid.<br>
      <br>
      <span style="font-style: italic;"> Surface* Surface::get_handle();</span>
      – Return the handle to base graphics subsystem object. </big>
    <h2><a name="mozTocId289525" class="mozTocH2"></a><big>Chapter 3. Picture
        subsystem</big></h2>
    <big><span style="text-decoration: underline;"> An important subsystem</span><br>
      <br>
      Picture subsystem implement image storage.<br>
      <br>
    </big><big><span style="text-decoration: underline;"> Work with picture
        subsystem</span><br>
      <br>
      <span style="font-style: italic;"> Picture</span> class provide simple
      access to picture subsystem. Don't use it directly. Let's look at public
      methods.<br>
      <br>
      <span style="font-style: italic;"> unsigned int *Picture::get_image();</span>
      – Return handle to image storage.<br>
      <br>
    </big><big><span style="font-style: italic;">void Picture::destroy_image();</span>
      – Destroy an image in the storage.<br>
      <br>
    </big><big> <span style="font-style: italic;"> bool
        Picture::is_storage_empty() const;</span> – Return true if storage is
      empty.<br>
      <br>
      <span style="font-style: italic;"> unsigned int Picture::get_image_width()
        const;</span> – Return image width in pixels.<br>
      <br>
      <span style="font-style: italic;">size_t Picture::get_pixel_amount()
        const;</span> – Return amount of image pixels.<br>
      <br>
      <span style="font-style: italic;"> unsigned int
        Picture::get_image_height() const;</span> – Return image height in
      pixels.<br>
      <br>
    </big><big><span style="font-style: italic;">size_t
        Picture::get_image_lenght() const;</span> – Return image length in
      bytes.</big><br>
    <big> </big>
    <h2><a name="mozTocId501089" class="mozTocH2"></a><big>Chapter 4. Animation
        subsystem</big></h2>
    <big><span style="text-decoration: underline;"> An important subsystem</span><br>
      <br>
      Animation subsystem let you control animation frames.<br>
      <br>
      <span style="text-decoration: underline;"> Frame indexing</span><br>
      <br>
      First frame index is 1.<br>
      <br>
      <span style="text-decoration: underline;"> Work with animation subsystem</span><br>
      <br>
      <span style="font-style: italic;"> Animation</span> class provide simple
      access to animation subsystem. Don't use it directly. Let's look at public
      methods.<br>
      <br>
      <span style="font-style: italic;"> unsigned int Animation::get_frames()
        const;</span> – Return amount of frames.<br>
      <br>
      <span style="font-style: italic;"> unsigned int Animation::get_frame()
        const;</span> – Return current frame.<br>
      <br>
      <span style="font-style: italic;">bool Animation::is_last_frame() const;</span>
      – Return true if current frame is last frame.<br>
      <br>
      <span style="font-style: italic;">bool Animation::check_frame(const
        unsigned int target) const;</span> – Return true if target frame is
      valid.<br>
    </big>
    <h2><a name="mozTocId904725" class="mozTocH2"></a><big>Chapter 5. Image kind</big></h2>
    <big></big>
    <p><big> Image kind look as predefined constants. You can see it below.</big></p>
    <br>
    <big> </big>
    <table border="1">
      <tbody>
        <tr>
          <td><big>Image kind<br>
            </big></td>
          <td><big>Description </big></td>
        </tr>
        <tr>
          <td><big>HORIZONTAL_ANIMATED </big></td>
          <td><big>Horizontal scrolling background or horizontal strip </big></td>
        </tr>
        <tr>
          <td><big>VERTICAL_ANIMATED </big></td>
          <td><big>Vertical scrolling background or vertical strip<br>
            </big></td>
        </tr>
      </tbody>
    </table>
    <br>
    <h2><a name="mozTocId738557" class="mozTocH2"></a><big>Chapter 6. Background</big></h2>
    <big><span style="text-decoration: underline;"> Level decoration</span><br>
      <br>
      Background is a big image. It is like decoration in theater stage. Any
      game has a background. The background will stretch to screen resolution
      before rendering the game scene. Background transparency is disabled.<br>
      <br>
      There are two background kinds: horizontal orientated scrolling background
      and vertical orientated scrolling background. It is a big image with few
      frames. Horizontal orientated scrolling background look like horizontal
      orientated photo ribbon. Vertical orientated scrolling background look
      like vertical orientated photo ribbon.<br>
      <br>
    </big><big> <span style="text-decoration: underline;"> Work with background</span><br>
      <br>
      Just use <span style="font-style: italic;">Background</span> class to
      work with background. Let's look at public methods.<br>
      <br>
      <span style="font-style: italic;">Background* Background::get_handle();</span>
      – Return the handle to background object.<br>
      <br>
    </big><big> <span style="font-style: italic;"> void
        Background::prepare(const Surface *surface);</span> – Prepare for
      drawing.<br>
      <br>
      <span style="font-style: italic;"> void Background::prepare(Screen
        &amp;surface);</span> – Prepare for drawing.<br>
      <br>
      <span style="font-style: italic;"> void Background::prepare(const unsigned
        int width,const unsigned int heigt);</span> – Prepare for drawing.<br>
      <br>
      <span style="font-style: italic;">void Background::disable_mirror();</span>
      – Disable background mirroring mode.<br>
      <br>
      <span style="font-style: italic;">void Background::horizontal_mirror();</span>
      – Set horizontal background mirroring mode.<br>
      <br>
      <span style="font-style: italic;">void Background::vertical_mirror();</span>
      – Set vertical background mirroring mode.<br>
      <br>
      <span style="font-style: italic;">void Background::complex_mirror();</span>
      – Set both horizontal and vertical background mirroring mode.<br>
      <br>
      <span style="font-style: italic;"> void Background::set_target(const
        unsigned int target);</span> – Set target frame.<br>
      <br>
      <span style="font-style: italic;"> void Background::step();</span> –
      Increase number of target frame. Set it to 1 if number of target frame
      more than frame amount.<br>
      <br>
      <span style="font-style: italic;"> void Background::set_setting(const
        BIRD2D::IMAGE_KIND kind,const unsigned int frames);</span> – Set
      setting.<br>
      <span style=""></span><br>
      <span style="font-style: italic;">void Background::load(Image
        *background,const BIRD2D::IMAGE_KIND kind,const unsigned int frames);</span>
      – Load a background from the buffer.<br>
      <br>
      <span style="font-style: italic;">void Background::load(Image
        &amp;background,const BIRD2D::IMAGE_KIND kind,const unsigned int
        frames);</span> – Load a background from the buffer.<br>
      <br>
      <span style="font-style: italic;">void Background::load(const char
        *name,const BIRD2D::IMAGE_KIND kind,const unsigned int frames);</span> –
      Load a background from target file.<br>
      <br>
      <span style="font-style: italic;"> void Background::draw();</span> – Draw
      a background.<br>
      <br>
      <span style="font-style: italic;">void Background::draw(const unsigned int
        target);</span> – Draw target frame.<br>
      <br>
      <span style="font-style: italic;"> void Background::destroy_image();</span>
      – Destroy a background image.<br>
      <br>
      <span style="font-style: italic;"> void Background::destroy();</span> –
      Destroy a background image and destroy a background texture.<br>
      <br>
      <span style="font-style: italic;">bool Background::is_load() const;</span>
      – Return true if a background is already loaded.<br>
      <br>
      <span style="font-style: italic;">bool Background::is_last_frame() const;</span>
      – Return true if current frame is last frame.<br>
      <br>
      <span style="font-style: italic;">bool Background::check_frame(const
        unsigned int target) const;</span> – Return true if target frame is
      valid.<br>
      <br>
      <span style="font-style: italic;"> unsigned int Background::get_frame()
        const;</span> – Return current frame.<br>
      <br>
      <span style="font-style: italic;"> unsigned int Background::get_frames()
        const;</span> – Return frame amount.<br>
      <br>
      <span style="font-style: italic;"> unsigned int Background::get_width()
        const;</span> – Return the width of the background.<br>
      <br>
      <span style="font-style: italic;"> unsigned int Background::get_height()
        const;</span> – Return the height of the background.<br>
      <br>
      <span style="font-style: italic;"> BIRD2D::IMAGE_KIND
        Background::get_kind() const;</span> – Get background type.<br>
      <br>
      <span style="text-decoration: underline;"> Background texture</span><br>
      <br>
      Background don't draw if background texture is don't exist. Background
      texture will automatically create after call <span style="font-style: italic;">load</span>
      method.<br>
      <br>
      <span style="text-decoration: underline;"> Important notice</span><br>
      <br>
      Always call <span style="">prepare</span> method after load background.<br>
    </big>
    <h2><a class="mozTocH2" name="mozTocId573639"></a><big>Chapter 7. Static
        background</big></h2>
    <big><span style="text-decoration: underline;">A few words about static
        background</span><br>
      <br>
      The static background is simple kind of backgrounds. It contain one frame
      only.<br>
    </big><big><br>
      <span style="text-decoration: underline;"> Work with background</span><br>
      <br>
      Just use <span style="font-style: italic;">Scene</span> class to work
      with static background. Let's look at public methods.<br>
      <br>
      <span style="font-style: italic;">Scene* Scene::get_handle();</span> –
      Return the handle to background object.<br>
      <br>
    </big><big> <span style="font-style: italic;"> void Scene::prepare(const
        Surface *surface);</span> – Prepare for drawing.<br>
      <br>
      <span style="font-style: italic;"> void Scene::prepare(Surface
        &amp;surace);</span> – Prepare for drawing.<br>
      <br>
      <span style="font-style: italic;"> void Scene::prepare(const unsigned int
        width,const unsigned int heigt);</span> – Prepare for drawing.<br>
      <br>
      <span style="font-style: italic;">void Scene::disable_mirror();</span> –
      Disable background mirroring mode.<br>
      <br>
      <span style="font-style: italic;">void Scene::horizontal_mirror();</span>
      – Set horizontal background mirroring mode.<br>
      <br>
      <span style="font-style: italic;">void Scene::vertical_mirror();</span> –
      Set vertical background mirroring mode.<br>
      <br>
      <span style="font-style: italic;">void Scene::complex_mirror();</span> –
      Set both horizontal and vertical background mirroring mode.<br>
      <span style="font-style: italic;"></span><span style="font-style: italic;"></span></big><big><br>
      <span style="font-style: italic;"> void Scene::load(Image *background);</span>
      – Load a background from the buffer.<br>
      <br>
      <span style="font-style: italic;"> void Scene::load(Image
        &amp;background);</span> – Load a background </big><big>from the buffer</big><big>.<br>
      <br>
    </big><big><span style="font-style: italic;">void Scene::load(</span></big><big
      style="font-style: italic;">const char *name</big><big><span style="font-style: italic;">);</span>
      – Load a background from target file.</big><br>
    <big><br>
      <span style="font-style: italic;"> void Scene::draw();</span> – Draw a
      background.<br>
      <span style="font-style: italic;"></span><br>
      <span style="font-style: italic;"> void Scene::destroy_image();</span> –
      Destroy a background image.<br>
      <br>
      <span style="font-style: italic;"> void Scene::destroy();</span> – Destroy
      a background image and destroy a background texture.<br>
      <br style="font-style: italic;">
      <span style="font-style: italic;">bool Scene::is_load() const;</span> –
      Return true if a static background is already loaded.<br>
      <span style="font-style: italic;"></span><br>
      <span style="font-style: italic;"> unsigned int Scene::get_width() const;</span>
      – Return the width of the background.<br>
      <br>
      <span style="font-style: italic;"> unsigned int Scene::get_height() const;</span>
      – Return the height of the background.<br>
      <span style="font-style: italic;"></span><br>
      <span style="text-decoration: underline;"> Background texture</span><br>
      <br>
      Background don't draw if background texture is don't exist. Background
      texture will automatically create after call <span style="font-style: italic;">load</span>
      method.<br>
      <br>
      <span style="text-decoration: underline;"> Important notice</span><br>
      <br>
      Always call <span style="font-style: italic;">prepare</span> method after
      load background.</big><br>
    <h2><a name="mozTocId309905" class="mozTocH2"></a><big>Chapter 8. Base
        sprite subsystem</big></h2>
    <big> </big><big><span style="text-decoration: underline;">Small important
        thing</span><br>
      <br>
      A sprite is a transparent image. It is useful for many things: enemies,
      bonuses, etc.<br>
    </big><big><span style=""></span><br>
      <span style="text-decoration: underline;"> Work with base sprite subsystem</span><br>
      <br>
      <span style="font-style: italic;"> Billboard</span> class provide simple
      access to base sprite subsystem. Don't use it directly. Let's look at
      public methods.<br>
    </big><big><br>
    </big><big><span style="font-style: italic;"> void
        Billboard::set_transparent(const bool enabled);</span> – Enable or
      disable the transparent mode.<br>
      <br>
      <span style="font-style: italic;"> bool Billboard::get_transparent()
        const;</span> – Return true if transparent mode is enable.<br>
      <br>
      <span style="font-style: italic;">void Billboard::set_start(const unsigned
        int x, const unsigned int y);</span> – Set start position of the sprite.<br>
      <br>
    </big><big><span style="font-style: italic;">void
        Billboard::set_position(const unsigned int x, const unsigned int y);</span>
      – Set sprite position.<br>
      <br>
      <span style="font-style: italic;"> void Billboard::set_size(const unsigned
        int width, const unsigned int height);</span> – Change the sprite size.<br>
      <br>
    </big> <big><span style="font-style: italic;"> void Billboard::set_x(const
        unsigned int x);</span> – Set x–coordinate of the sprite position.<br>
      <br>
    </big> <big><span style="font-style: italic;"> void Billboard::set_y(const
        unsigned int y);</span> – Set y–coordinate of the sprite position.<br>
      <br>
    </big><big> <span style="font-style: italic;"> void
        Billboard::set_width(const unsigned int width);</span> – Change the
      sprite width.<br>
      <br>
      <span style="font-style: italic;"> void Billboard::set_height(const
        unsigned int height);</span> – Change the sprite height.<br>
      <br>
    </big> <big><span style="font-style: italic;">unsigned int
        Billboard::increase_x();</span> – Increase x–coordinate and return
      increased x–position.<br>
      <br>
      <span style="font-style: italic;">unsigned int Billboard::decrease_x();</span>
      – Decrease x–coordinate and return decreased x–position.<br>
      <br>
      <span style="font-style: italic;">unsigned int Billboard::increase_y();</span>
      – Increase y–coordinate and return increased y–position.<br>
      <br>
      <span style="font-style: italic;">unsigned int Billboard::decrease_y();</span>
      – Decrease y–coordinate and return increased y–position.<br>
      <br>
      <span style="font-style: italic;">unsigned int Billboard::increase_x(const
        unsigned int increment);</span> – Increase x–coordinate with user value
      and return increased x–position.<br>
      <br>
      <span style="font-style: italic;">unsigned int Billboard::decrease_x(const
        unsigned int decrement);</span> – Decrease x–coordinate with user value
      and return decreased x–position.<br>
      <br>
      <span style="font-style: italic;">unsigned int Billboard::increase_y(const
        unsigned int increment);</span> – Increase y–coordinate with user value
      and return increased y–position.<br>
      <br>
      <span style="font-style: italic;">unsigned int Billboard::decrease_y(const
        unsigned int decrement);</span> – Decrease y–coordinate with user value
      and return decreased y–position.<br>
      <br>
      <span style="font-style: italic;">unsigned int Billboard::get_start_x()
        const;</span> – Return x–coordinate of start position.<br>
      <br>
      <span style="font-style: italic;">unsigned int Billboard::get_start_y()
        const;</span> – Return y–coordinate of start position.<br>
      <br>
      <span style="font-style: italic;"> unsigned int Billboard::get_x() const;</span>
      – Return x–coordinate of the sprite position.<br>
      <br>
      <span style="font-style: italic;"> unsigned int Billboard::get_y() const;</span>
      – Return y–coordinate of the sprite position.<br>
      <br>
      <span style="font-style: italic;"> unsigned int Billboard::get_width()
        const;</span> – Return the width of the sprite.<br>
      <br>
      <span style="font-style: italic;"> unsigned int Billboard::get_height()
        const;</span> – Return the height of the sprite.<br>
      <br>
      <span style="font-style: italic;">bool Billboard::is_load() const;</span>
      – Return true if the sprite is already loaded.<br>
      <br>
    </big><big><span style="font-style: italic;">BIRD2D::BOX
        Billboard::get_box() const;</span> – Return collision related
      information.<br>
      <br>
      <span style="font-style: italic;">void Billboard::disable_mirror();</span>
      – Disable sprite mirroring mode.<br>
      <br>
      <span style="font-style: italic;">void Billboard::horizontal_mirror();</span>
      – Set horizontal sprite mirroring mode.<br>
      <br>
      <span style="font-style: italic;">void Billboard::vertical_mirror();</span>
      – Set vertical sprite mirroring mode.<br>
      <br>
      <span style="font-style: italic;">void Billboard::complex_mirror();</span>
      – Set both horizontal and vertical sprite mirroring mode.<br>
      <br>
      <span style="font-style: italic;">void Billboard::go_start();</span> – Set
      sprite position to start position.<br>
      <br>
      <span style="font-style: italic;">void Billboard::go_start_x();</span> –
      Set x–coordinate of sprite position to x–coordinate of start position.<br>
      <br>
      <span style="font-style: italic;">void Billboard::go_start_y();</span> –
      Set y–coordinate of sprite position to y–coordinate of start position.<br>
      <br>
    </big><big> </big><big><span style="font-style: italic;">void
        Billboard::draw();</span> – Draw a sprite.<br>
      <br>
    </big> <big><span style="font-style: italic;"> void Billboard::draw(const
        unsigned int x, const unsigned int y);</span> – Set sprite position and
      draw it.<br>
      <br>
    </big> <big><i>void Billboard::draw(const bool transparency);</i> – Set
      transparent mode and draw a sprite.<br>
      <br>
    </big> <big><i>void Billboard::draw(const bool transparency,const unsigned
        int x, const unsigned int y);</i> – Set transparent mode and draw a
      sprite at target position.</big><br>
    <big> </big>
    <h2><a name="mozTocId662651" class="mozTocH2"></a><big> Chapter 9. Ordinary
        sprites</big></h2>
    <big><span style="text-decoration: underline;"> Sprite types</span><br>
      <br>
      There are two kinds of ordinary sprites: horizontal strip and vertical
      strip. It is a small image with few frames.<br>
      Do you remember an analog camera? Strip look like photo ribbon.<br>
      Horizontal strip look like the horizontal orientated photo ribbon.
      Vertical strip look like the vertical orientated photo ribbon.<br>
    </big><big><br>
    </big><big><span style="text-decoration: underline;">Frame indexing</span><br>
      <br>
      First frame index is 1.<br>
      <br>
    </big> <big> <span style="text-decoration: underline;"> Work with sprites</span><br>
      <br>
      Just use <span style="font-style: italic;">Sprite</span> class to work
      with a sprite. It is derived from three classes: </big><big><span style="font-style: italic;">Billboard</span>,
      <span style="font-style: italic;">Animation</span> and <span style="font-style: italic;">Picture</span></big><big>.
      Let's look at public methods.<br>
      <br>
      <span style="font-style: italic;"> void Sprite::set_setting(const
        BIRD2D::IMAGE_KIND kind,const unsigned int frames);</span> – Set sprite
      settings.<br>
      <br>
      <span style="font-style: italic;"> void Sprite::load(Image *buffer,const
        BIRD2D::IMAGE_KIND kind,const unsigned int frames);</span> – Load a
      sprite from the buffer.<br>
      <br>
      <span style="font-style: italic;">void Sprite::load(Image
        &amp;buffer,const BIRD2D::IMAGE_KIND kind,const unsigned int frames);</span>
      – Load a sprite from the buffer.<br>
      <br>
      <span style="font-style: italic;">void Sprite::load(const char *name,const
        BIRD2D::IMAGE_KIND kind,const unsigned int frames);</span> – Load a
      sprite from target file.<br>
      <br>
      <span style="font-style: italic;"> void Sprite::set_target(const unsigned
        int target);</span> – Set target frame.<br>
      <br>
      <span style="font-style: italic;"> void Sprite::step();</span> – Increase
      number of target frame. Set it to 1 if number of target frame more than
      frame amount.<br>
      <br>
      <span style="font-style: italic;"> BIRD2D::IMAGE_KIND Sprite::get_kind()
        const;</span> – Get sprite type.<br>
      <br>
    </big><big> <span style="font-style: italic;"> Sprite*
        Sprite::get_handle();</span> – Return the handle to sprite object.<br>
      <br>
      <span style="font-style: italic;"> void Sprite::clone(Sprite *target);</span>
      – Create copy of the sprite if the image storage of target sprite is not
      empty.<br>
      <br>
      <span style="font-style: italic;"> void Sprite::clone(Sprite &amp;target);</span>
      – Create copy of the sprite if the image storage of target sprite is not
      empty.<br>
      <br>
      <span style=""><span style="font-style: italic;"> void Sprite::destroy();</span>
      </span>– Destroy a sprite image and destroy a sprite texture.</big><big><br>
    </big> <big><br>
      <span style="text-decoration: underline;"> Sprite texture</span><br>
      <br>
      Sprite will don't draw if sprite texture is don't exist. Sprite texture
      will automatically create when load or clone sprite.<br>
    </big>
    <h2><a class="mozTocH2" name="mozTocId66751"></a><big>Chapter 10. Static
        sprites</big></h2>
    <big><span style="text-decoration: underline;">A few words about static
        sprite</span><br>
      <br>
      The static sprite is simple kind of sprites. It contain one frame only.<br>
      <br>
    </big><big><span style="text-decoration: underline;"></span></big><big> <span
        style="text-decoration: underline;"> Work with static sprites</span><br>
      <br>
      Just use <span style="font-style: italic;">Cartoon</span> class to work
      with a static sprite. It is derived from two classes: </big><big><span style="font-style: italic;">Billboard</span>
      and <span style="font-style: italic;">Picture</span></big><big>. Let's
      look at public methods.<br>
      <span style="font-style: italic;"></span><br>
      <span style="font-style: italic;"> void Cartoon::load(Image *buffer);</span>
      – Load a sprite </big><big>from the buffer</big><big>.<br>
      <span style="font-style: italic;"></span></big><big><br>
      <span style="font-style: italic;"> void Cartoon::load(Image &amp;buffer);</span>
      – Load a sprite </big><big>from the buffer</big><big>.<br>
      <span style="font-style: italic;"></span></big><big><br>
      <span style="font-style: italic;">void Cartoon::load(</span></big><big style="font-style: italic;">const
      char *name</big><big><span style="font-style: italic;">);</span> – Load a
      sprite from target file.<br>
      <span style="font-style: italic;"></span><br>
    </big><big> <span style="font-style: italic;"> Cartoon*
        Cartoon::get_handle();</span> – Return the handle to sprite object.<br>
      <br>
      <span style="font-style: italic;"> void Cartoon::clone(Cartoon *target);</span>
      – Create copy of the sprite if the image storage of target sprite is not
      empty.<br>
      <br>
      <span style="font-style: italic;"> void Cartoon::clone(Cartoon
        &amp;target);</span> – Create copy of the sprite if the image storage of
      target sprite is not empty.<br>
      <br>
      <span style="font-style: italic;"> void Cartoon::destroy(); </span>–
      Destroy a sprite image and destroy a sprite texture.</big><big><br>
    </big> <big><br>
      <span style="text-decoration: underline;"> Sprite texture</span><br>
      <br>
      Sprite will don't draw if sprite texture is don't exist. Sprite texture
      will automatically create when load or clone sprite.</big><br>
    <big> </big>
    <h2><a name="mozTocId146800" class="mozTocH2"></a><big>Chapter 11. Sprite
        sheet</big></h2>
    <big><span style="text-decoration: underline;"> Some words about sprite
        sheet</span><br>
      <br>
      Sprite sheet is a special kind of animated sprites. Each frame has fixed
      size. A sprite sheet is a matrix of frames. Look to this picture to
      understand it.<br>
      <br>
      <img src="sheet.png"><br>
      <br>
      <span style="text-decoration: underline;"> Rows and columns</span><br>
      <br>
      First row index is 1. First column index is 1.<br>
    </big><big><br>
    </big><big><span style="text-decoration: underline;"> Work with sprite sheet
        subsystem</span><br>
      <br>
      <span style="font-style: italic;"> Sheet</span> class provide access to
      the sprite sheet subsystem. </big><big>It is derived from&nbsp; three </big><big>classes:
      <span style="font-style: italic;">Billboard</span>, <span style="font-style: italic;">Picture</span>
      and <span style="font-style: italic;">Animation</span>. Let's look at
      public methods.<br>
      <br>
      <span style="font-style: italic;">bool Sheet::check_row(const unsigned int
        target) const;</span> – Return true if target row is valid.<br>
      <br>
      <span style="font-style: italic;">bool Sheet::check_column(const unsigned
        int target) const;</span> – Return true if target column is valid.<br>
      <br>
    </big><big style="font-style: italic;"> unsigned int Sheet::get_row(</big><big
      style="font-style: italic;">const unsigned int target</big><big><span style="font-style: italic;">)
        const;</span> – Return row of target frame.<br>
      <br>
      <span style="font-style: italic;"> unsigned int Sheet::get_column(</span></big><big
      style="font-style: italic;">const unsigned int target</big><big><span style="font-style: italic;">)
        const;</span> – Return</big><big> column</big><big> </big><big>of
      target frame</big><big>.<br>
      <br>
    </big> <big><span style="font-style: italic;">unsigned int
        Sheet::calculate(const unsigned int row,const unsigned int column)
        const;</span> – Calculate the frame by row and column.<br>
      <br>
    </big> <big><span style="font-style: italic;"> unsigned int
        Sheet::get_rows() const;</span> – Return row amount.<br>
      <br>
      <span style="font-style: italic;"> unsigned int Sheet::get_columns()
        const;</span> – Return</big><big> column</big><big> amount.<br>
      <br>
    </big> <big><span style="font-style: italic;"> void Sheet::destroy();</span>
      – Destroy a sprite sheet image and destroy a sprite sheet texture.<br>
      <br>
    </big> <big><span style="font-style: italic;"> void Sheet::select(const
        unsigned int row,const unsigned int column);</span> – Select the sprite
      by row and column.<br>
      <br>
    </big> <big><span style="font-style: italic;"> void Sheet::select(const
        unsigned int target);</span> – Select the sprite by frame number.<br>
      <br>
    </big><big><span style="font-style: italic;">void Sheet::step();</span> –
      Increase number of target frame. Set it to 1 if number of target frame
      more than frame amount.<br>
      <br>
    </big> <big><span style="font-style: italic;">void Sheet::load(Image
        *sheet,const unsigned int row_amount,const unsigned int column_amount);</span>
      – Load a sprite sheet from the buffer.<br>
      <br>
      <span style="font-style: italic;">void Sheet::load(Image &amp;sheet,const
        unsigned int row_amount,const unsigned int column_amount);</span> – Load
      a sprite sheet from the buffer.<br>
      <br>
      <span style="font-style: italic;">void Sheet::load(const char *name,const
        unsigned int row_amount,const unsigned int column_amount);</span> – Load
      a sprite sheet from target file.<br>
      <br>
      <span style="font-style: italic;">Sheet* Sheet::get_handle();</span> –
      Return the handle to sprite sheet.<br>
      <br>
      <span style="font-style: italic;">void Sheet::clone(Sheet *target);</span>
      – Create copy of the sprite sheet if the image storage of target sprite
      sheet is not empty.<br>
      <br>
      <span style="font-style: italic;">void Sheet::clone(Sheet &amp;target);</span>
      – Create copy of the sprite sheet if the image storage of target sprite
      sheet is not empty.<br>
      <br>
      <span style="text-decoration: underline;"> Sprite sheet texture</span><br>
      <br>
      Sprite will don't draw if sprite sheet texture is don't exist. A sprite
      sheet texture will automatically create after call <span style="">load_sheet</span>
      method.<br>
    </big>
    <h2><a name="mozTocId752257" class="mozTocH2"></a><big>Chapter 12. Text</big></h2>
    <big><span style="text-decoration: underline;"> How to draw a text?</span><br>
      <br>
      Just use text subsystem to draw a text. This subsystem need a font for
      text drawing. You must load a font before start draw the text. The font is
      just a sprite sheet with 16 rows and 16 columns.<br>
      <br>
      <span style="text-decoration: underline;"> Valid characters</span><br>
      <br>
      Only 8–bit </big><big>characters</big><big> supported.<br>
      <br>
    </big><big style="text-decoration: underline;">Text orientation</big><br>
    <br>
    <big>Text orientation look as predefined constants. You can see it below.<br>
      <br>
    </big> <big> </big>
    <table border="1">
      <tbody>
        <tr>
          <td><big>Text orientation<br>
            </big></td>
          <td><big>Description </big></td>
        </tr>
        <tr>
          <td><big>HORIZONTAL_TEXT </big></td>
          <td><big>Horizontal orientated text<br>
            </big></td>
        </tr>
        <tr>
          <td><big>VERTICAL_TEXT </big></td>
          <td><big>Vertical orientated text</big></td>
        </tr>
      </tbody>
    </table>
    <big><br>
      <span style="text-decoration: underline;"> Work with text</span><br>
      <br>
      <span style="font-style: italic;"> Text</span> class provide a simple
      interface to text subsystem. Let's look at public methods.<br>
      <br>
      <span style="font-style: italic;">Text* Text::get_handle();</span> –
      Return the handle to text drawing subsystem.<br>
      <br>
      <span style="font-style: italic;"> BIRD2D::TEXT_KIND
        Text::get_orientation() const;</span> – Get current text orientation.<br>
      <br>
      <span style="font-style: italic;"> void Text::set_orientation(const
        BIRD2D::TEXT_KIND target);</span> – Set current text orientation.<br>
      <br>
      <span style="font-style: italic;">bool Text::is_font_load() const;</span>
      – Return true if the font is already loaded.<br>
      <br>
      <span style="font-style: italic;"> unsigned int Text::get_font_width()
        const;</span> – Get current font width in pixels.<br>
      <br>
      <span style="font-style: italic;"> unsigned int Text::get_font_height()
        const;</span> – Get current font height in pixels.<br>
      <br>
      <span style="font-style: italic;"> void Text::set_position(const unsigned
        int x,const unsigned int y);</span> – Set output position.<br>
      <br>
      <span style="font-style: italic;"> void Text::set_size(const unsigned int
        width,const unsigned int height);</span> – Change the font size.<br>
      <br>
      <span style="font-style: italic;">void Text::set_width(const unsigned int
        width);</span> – Set the font width.<br>
      <br>
      <span style="font-style: italic;">void Text::set_height(const unsigned int
        height);</span> – Set the font height.<br>
      <br>
      <span style="font-style: italic;">void Text::set_setting(const unsigned
        int width,const unsigned int height,const BIRD2D::TEXT_KIND kind);</span>
      – Set text output settings.<br>
      <br>
      <span style="font-style: italic;">void Text::load_font(Image *font);</span>
      – Load a font from the buffer.<br>
      <br>
      <span style="font-style: italic;">void Text::load_font(Image &amp;font);</span>
      – Load a font from the buffer.<br>
      <br>
      <span style="font-style: italic;">void Text::load_font(const char *name);</span>
      – Load a font from target file.<br>
      <br>
      <span style="font-style: italic;"> void Text::print(const char target);</span>
      – Draw single character at current position.<br>
      <br>
      <span style="font-style: italic;"> void Text::print(const char *target);</span>
      – Draw text at current position.<br>
      <br>
      <span style="font-style: italic;"> void Text::print(const unsigned int
        x,const unsigned int y,const char target);</span> – Draw single
      character at specific position.<br>
      <br>
      <span style="font-style: italic;"> void Text::print(const unsigned int
        x,const unsigned int y,const char *target);</span> – Draw text at
      specific position.<br>
      <br>
      <span style="font-style: italic;">void Text::disable_mirror();</span> –
      Disable text mirroring mode.<br>
      <br>
      <span style="font-style: italic;">void Text::horizontal_mirror();</span> –
      Set horizontal text mirroring mode.<br>
      <br>
      <span style="font-style: italic;">void Text::vertical_mirror();</span> –
      Set vertical text mirroring mode.<br>
      <br>
      <span style="font-style: italic;">void Text::complex_mirror();</span> –
      Set both horizontal and vertical text mirroring mode.<br>
      <br>
      <span style="font-style: italic;"> void Text::destroy_image();</span> –
      Destroy a font image.<br>
      <br>
      <span style="font-style: italic;"> void Text::destroy_font();</span> –
      Destroy a font image and destroy a font texture.<br>
    </big><big> </big>
    <h2><a name="mozTocId67980" class="mozTocH2"></a><big>Chapter 13. Loading
        images</big></h2>
    <big><span style="text-decoration: underline;"> Load an image from files</span><br>
      <br>
      Use image loader to load an image from a file. <span style="font-style: italic;">Image</span>
      class provide simple access to image loader. It is a simple class with few
      methods.<br>
      <br>
      <span style="font-style: italic;"> unsigned char *Image::load(const char
        *name);</span> – Load a Truevision TGA image and return handle to image
      buffer.<br>
      <br>
      <span style="font-style: italic;">unsigned char *Image::get_data();</span>
      – Return handle to image buffer.<br>
      <br>
      <span style="font-style: italic;"> unsigned int Image::get_width() const;</span>
      – Return width of current image.<br>
      <br>
      <span style="font-style: italic;"> unsigned int Image::get_height() const;</span>
      – Return height of current image.<br>
      <br>
      <span style="font-style: italic;"> size_t Image::get_length() const;</span>
      – Return length of image buffer in bytes.<br>
      <span style=""></span><br>
      <span style="font-style: italic;"> Image* Image::get_handle();</span> –
      Return the handle to image loader.<br>
      <br>
      <span style="font-style: italic;"> void Image::destroy_image();</span> –
      Destroy the current image and free image buffer.<br>
      <br>
      <span style="text-decoration: underline;"> Important remark</span><br>
      <br>
      A new image will replace current image if current image already exist.
      Incorrect images will ignore and don't load.<br>
      Source image will convert to <a href="https://en.wikipedia.org/wiki/RGBA">RGBA</a>
      format. Pixels equal to top-left pixel will mark as transparent.<br>
      <br>
      <span style="text-decoration: underline;"> Supported format</span><br>
    </big>
    <p><big> All loading images must have correct specification. You can load an
        image from 24 bit </big><big><a href="https://en.wikipedia.org/wiki/Truevision_TGA">Truevision
          TGA</a> pictures. </big></p>
    <big><span style="text-decoration: underline;"> Recommend software</span><br>
      <br>
      You can use a wide range of graphics software to convert your images to
      the correct format. I recommend use <a href="https://www.gimp.org">GIMP</a>
      for doing it. It is a powerful image editor.<br>
    </big>
    <h1><a class="mozTocH1" name="mozTocId696454"></a><a id="mozTocId806412" class="mozTocH1"></a><big>Part
        4. Transformation</big></h1>
    <big></big>
    <h2><a class="mozTocH2" name="mozTocId933730"></a><a id="mozTocId688245" class="mozTocH2"></a><big>Chapter
        1. The sub–namespace</big></h2>
    <big> All subsystems in this section declared in <span style="font-style: italic;">Transformation</span>
      sub–namespace.<br>
    </big>
    <h2><a class="mozTocH2" name="mozTocId952856"></a><a id="mozTocId925097" class="mozTocH2"></a><big>Chapter
        2. Cartesian coordinates and screen coordinates</big></h2>
    <big><span style="text-decoration: underline;"> Cartesian coordinates</span><br>
      <br>
      Cartesian coordinates start at center of the screen. Look to this picture
      to understand it.<br>
      <br>
      <img style="width: 107px; height: 111px;" alt="" src="cartesian_system.png"><br>
      <br>
      <span style="text-decoration: underline;"> Cartesian coordinates to screen
        coordinates conversion and screen coordinates to cartesian coordinates
        conversion</span><br>
      <br>
      You can convert cartesian coordinates to screen coordinates. You can also
      convert screen coordinates to cartesian coordinates.<br>
      Just use <span style="font-style: italic;">Coordinates</span> class for
      doing it. Let's look at public methods.<br>
      <br>
      <span style="font-style: italic;">Coordinates* Coordinates::get_handle();</span>
      – Return the handle to coordinates conversion subsystem.<br>
      <br>
      <span style="font-style: italic;"> void Coordinates::initialize(const int
        viewport_width,const int viewport_height);</span> – Initialize the
      subsystem.<br>
      <br>
      <span style="font-style: italic;">int Coordinates::get_viewport_width()
        const;</span> – Return view-port width in pixels.<br>
      <br>
      <span style="font-style: italic;">int Coordinates::get_viewport_height()
        const;</span> – Return view-port height in pixels.<br>
      <br>
      <span style="font-style: italic;">int
        Coordinates::get_lowest_cartesian_x() const;</span> – Return lowest
      allowable cartesian x-coordinate.<br>
      <br>
      <span style="font-style: italic;">int
        Coordinates::get_highest_cartesian_x() const;</span> – Return highest
      allowable cartesian x-coordinate.<br>
      <br>
      <span style="font-style: italic;">int
        Coordinates::get_lowest_cartesian_y() const;</span> – Return lowest
      allowable cartesian y-coordinate.<br>
      <br>
      <span style="font-style: italic;">int
        Coordinates::get_highest_cartesian_y() const;</span> – Return highest
      allowable cartesian y-coordinate.<br>
      <br>
      <span style="font-style: italic;">bool
        Coordinates::check_cartesian_x(const int x) const;</span> – Return true
      if the cartesian x-coordinate is valid.<br>
      <br>
      <span style="font-style: italic;">bool
        Coordinates::check_cartesian_y(const int y) const;</span> – Return true
      if the cartesian y-coordinate is valid.<br>
      <br>
      <span style="font-style: italic;"> int Coordinates::get_screen_x(const int
        x) const;</span> – Convert cartesian x-coordinate to screen
      x-coordinate.<br>
      <br>
      <span style="font-style: italic;"> int Coordinates::get_screen_y(const int
        y) const;</span> – Convert cartesian y-coordinate to screen
      y-coordinate.<br>
      <br>
      <span style="font-style: italic;"> int Coordinates::get_cartesian_x(const
        int x) const;</span> – Convert screen x-coordinate to cartesian
      x-coordinate.<br>
      <br>
      <span style="font-style: italic;"> int Coordinates::get_cartesian_y(const
        int y) const;</span> – Convert screen y-coordinate to cartesian
      y-coordinate.<br>
    </big>
    <h2><a class="mozTocH2" name="mozTocId446824"></a><big>Chapter 3. Cartesian
        coordinates and isometric coordinates</big></h2>
    <big><span style="text-decoration: underline;">A few words about isometric</span><br>
      <br>
      <a href="https://en.wikipedia.org/wiki/Isometric_projection">Isometric</a>
      is very popular way for pseudo-3D games. Many old-school games are
      isometric games.<br>
      <br>
    </big><big><span style="text-decoration: underline;">Cartesian coordinates
        to isometric coordinates conversion and isometric coordinates to
        cartsian coordinates conversion</span><br>
      <br>
      You can convert cartesian coordinates to isometric coordinates. You can
      also convert isometric coordinates to cartesian coordinates.<br>
      Just use <span style="font-style: italic;">Isometric</span> class for
      doing it. Let's look at public methods.<br>
      <br>
      <span style="font-style: italic;">Isometric* Isometric::get_handle();</span>
      – Return the handle to isometric subsystem.<br>
      <br>
    </big><big><span style="font-style: italic;">void
        Isometric::set_target(const int x,const int y);</span> – Set target
      point.</big><big><span style="font-style: italic;"></span></big><big><br>
      <br>
      <span style="font-style: italic;">int Isometric::get_isometric_x() const;</span>
      – Convert x-coordinate of target point from cartesian system to isometric
      system.<br>
      <br>
      <span style="font-style: italic;">int Isometric::get_isometric_y() const;</span>
      – Convert y-coordinate of target point from cartesian system to isometric
      system.<br>
      <br>
      <span style="font-style: italic;">int Isometric::get_cartesian_x() const;</span>
      – Convert x-coordinate of target point from isometric system to cartesian
      system.<br>
      <br>
      <span style="font-style: italic;">int Isometric::get_cartesian_y() const;</span>
      – Convert y-coordinate of target point from isometric system to cartesian
      system.<br>
      <br>
      <span style="font-style: italic;">int Isometric::get_isometric_x(const int
        x,const int y);</span> – Set target point and convert x-coordinate from
      cartesian system to isometric system.<br>
      <br>
      <span style="font-style: italic;">int Isometric::get_isometric_y(const int
        x,const int y);</span> – Set target point and convert y-coordinatefrom
      cartesian system to isometric system.<br>
      <br>
      <span style="font-style: italic;">int Isometric::get_cartesian_x(const int
        x,const int y);</span> – Set target point and convert x-coordinatefrom
      isometric system to cartesian system.<br>
      <br>
      <span style="font-style: italic;">int Isometric::get_cartesian_y(const int
        x,const int y);</span> – Set target point and convert y-coordinate from
      isometric system to cartesian system.<br>
    </big>
    <h2><a class="mozTocH2" name="mozTocId143616"></a><big>Chapter 4. Isometric
        level<br>
      </big></h2>
    <big><span style="text-decoration: underline;"></span> Isometric level
      subsystem intend for help you to create an isometric levels. Just use <span
        style="font-style: italic;">World</span> class for doing it. Let's look
      at public methods.<br>
      <br>
      <span style="font-style: italic;">World* World::get_handle();</span> –
      Return the handle to isometric level subsystem.<br>
      <br>
      <span style="font-style: italic;">void World::initialize(const int
        tile_width,const int tile_height,const int screen_width,const int
        screen_height);</span> – Initialize the subsystem.<br>
      <br>
      <span style="font-style: italic;">int World::get_target_x(const int row,</span></big><big
      style="font-style: italic;">const int column</big><big><span style="font-style: italic;">)
        const;</span> – Get target cartesian x-coordinate from the row and
      column.<br>
      <br>
      <span style="font-style: italic;">int World::get_target_y(const int row</span></big><big
      style="font-style: italic;">,</big><big style="font-style: italic;">const
      int column</big><big><span style="font-style: italic;">) const;</span> –
      Get target cartesian y-coordinate </big><big>from the row and column.<br>
      <br>
    </big><big><span style="font-style: italic;">int World::get_row(const int x,</span></big><big
      style="font-style: italic;">const int y</big><big><span style="font-style: italic;">)
        const;</span> – Get the row from target point.<br>
      <br>
      <span style="font-style: italic;">int World::get_column(const int y</span></big><big
      style="font-style: italic;">,</big><big style="font-style: italic;">const
      int y</big><big><span style="font-style: italic;">) const;</span> – Get
      the column</big><big> from target point.<br>
      <br>
      <span style="font-style: italic;">int World::get_row_amount() const;</span>
      – Get amount of maximum visible rows.<br>
      <br>
      <span style="font-style: italic;">int World::get_column_amount() const;</span>
      – Get amount of maximum visible columns.<br>
      <br>
      <span style="font-style: italic;">int World::get_tile_amount() const;</span>
      – Get amount of maximum visible isometric tiles.<br>
    </big> <big> </big>
    <h1><a name="mozTocId64443" class="mozTocH1"></a><big>Part 5. Common things</big></h1>
    <h2><a name="mozTocId597525" class="mozTocH2"></a><big>Chapter 1. The
        sub–namespace</big></h2>
    <big>Almost all subsystems in this section declared in <span style="font-style: italic;">Common</span>
      sub–namespace.<br>
    </big> <big></big> <big> </big> <big> </big>
    <h2><a name="mozTocId853711" class="mozTocH2"></a><big>Chapter 2. Abnormal
        program termination</big></h2>
    <big> You can use <span style="font-style: italic;">Halt</span> function to
      terminate a program. This function declared in <i>BIRD2D</i> name–space.<br>
      <br>
      <span style="font-style: italic;"> void BIRD2D::Halt(const char *message);</span>
      – Terminate the program. Write error message to log file if logging
      enabled. </big><big> </big>
    <h2><a name="mozTocId656377" class="mozTocH2"></a><big>Chapter 3. Timer</big></h2>
    <big> Timer is a very useful thing. Just use <span style="font-style: italic;">Timer</span>
      class to work with the timer. Let's look at public methods.<br>
      <br>
      <span style="font-style: italic;">Timer* Timer::get_handle();</span> –
      Return the handle to the timer.<br>
      <br>
      <span style=""><span style="font-style: italic;"> void
          Timer::set_timer(const double seconds);</span> </span>– Set timer
      interval and initialize start point.<br>
      <br>
      <span style="font-style: italic;">double Timer::get_interval() const;</span>
      – Return current timer interval.<br>
      <br>
      <span style="font-style: italic;"> bool Timer::check_timer();</span> –
      Return true and reinitialize start point if interval between stop and
      start points large or equal than specific seconds.</big><br>
    <h2><a name="mozTocId381935" class="mozTocH2"></a><big>Chapter 4. Collision</big></h2>
    <big> <span style="text-decoration: underline;"> An important thing for any
        game</span><br>
      <br>
      What is an important thing for a video games? A collision.<br>
      <br>
      <span style="text-decoration: underline;"> Collision detail</span><br>
      <br>
      Collision detector using bounding box collision method to detect
      collision. Collision related information store in special custom data
      type.<br>
      <br>
      <span style="font-style: italic;"> typedef struct</span> <span style="font-style: italic;"><br>
        {<br>
        &nbsp; unsigned int x;<br>
        &nbsp; unsigned int y;<br>
        &nbsp; unsigned int width;<br>
        &nbsp; unsigned int height;</span><span style="font-style: italic;"><br>
        } BOX;</span><br>
      <br>
      <span style="text-decoration: underline;"> Work with collision detector</span><br>
      <br>
      <span style="font-style: italic;"> Collision</span> class provide easy
      access to collision detector. It is a simple class with few methods. Let's
      look at public methods.<br>
      <br>
      <span style="font-style: italic;">Collision* Collision::get_handle();</span>
      – Return the handle to the collision detector.<br>
    </big><br>
    <big><span style="font-style: italic;">void Collision::set_target(const
        BIRD2D::BOX first_target,const BIRD2D::BOX second_target);</span> – Set
      targets for collision detector.<br>
      <br>
      <span style="font-style: italic;"> bool Collision::check_collision()
        const;</span> – Return true if collision between two objects is
      accepted.<br>
      <br>
      <span style="font-style: italic;"> bool Collision::check_collision(const
        BIRD2D::BOX first_target,const BIRD2D::BOX second_target);</span> – Set
      collision targets and check collision between it.<br>
    </big>
    <h2><a class="mozTocH2" name="mozTocId423669"></a><big>Chapter 5. Tile–map</big></h2>
    <big><span style="text-decoration: underline;">A few words about tile-map</span><br>
      <br>
      The tile–map is tile matrix. A tile is a small non–transparent sprite. A
      tile–map is very useful thing for level background.<br>
      <br>
      <span style="text-decoration: underline;">Rows and columns</span><br>
      <br>
      First row index is 0. First column index is 0.<br>
      <br>
      <span style="text-decoration: underline;">Work with tile-map</span><br>
      <br>
      <span style="font-style: italic;">Tilemap</span> class provide easy access
      to the tile–map. It is a simple class with few methods. Let's look at
      public methods.<br>
      <br>
      <span style="font-style: italic;">Tilemap* Tilemap::get_handle();</span> –
      Return the handle to tile-map subsystem.<br>
      <br>
      <span style="font-style: italic;">void Tilemap::initialize(const unsigned
        int tile_width,const unsigned int tile_height);</span> – Initialize the
      subsystem.<br>
      <br>
      <span style="font-style: italic;">unsigned int Tilemap::get_tile_width()
        const;</span> – Return the tile width in pixels.<br>
      <br>
      <span style="font-style: italic;">unsigned int Tilemap::get_tile_height()
        const;</span> – Return the tile height in pixels.<br>
      <br>
      <span style="font-style: italic;">unsigned int Tilemap::get_x(const
        unsigned int row) const;</span> – Get x-coordinate from target row.<br>
      <br>
      <span style="font-style: italic;">unsigned int Tilemap::get_y(const
        unsigned int column) const;</span> – Get y-coordinate from target
      column.<br>
      <br>
      <span style="font-style: italic;">unsigned int Tilemap::get_row(const
        unsigned int x) const;</span> – Get the row from x-coordinate.<br>
      <br>
      <span style="font-style: italic;">unsigned int Tilemap::get_column(const
        unsigned int y) const;</span> – Get the column from y-coordinate.<br>
      <br>
      <span style="font-style: italic;">unsigned int
        Tilemap::get_row_amount(const unsigned int viewport_width) const;</span>
      – Get amount of maximum visible rows.<br>
      <br>
      <span style="font-style: italic;">unsigned int
        Tilemap::get_column_amount(const unsigned int viewport_width) const;</span>
      – Get amount of maximum visible columns.<br>
      <br>
      <span style="font-style: italic;">unsigned int
        Tilemap::get_tile_amount(const unsigned int viewport_width,const
        unsigned int viewport_height) const;</span> – Get amount of maximum
      visible tiles.<br>
      <br>
      <span style="font-style: italic;">bool Tilemap::check_row(const unsigned
        int row,const unsigned int viewport_width) const;</span> – Return true
      if the row is valid.<br>
      <br>
      <span style="font-style: italic;">bool Tilemap::check_column(const
        unsigned int column,const unsigned int viewport_height) const;</span> –
      Return true if the column is valid.<br>
      <br>
      <span style="font-style: italic;">BIRD2D::BOX Tilemap::get_box(const
        unsigned int row,const unsigned int column) const;</span> – Return
      collision related information.<br>
    </big>
    <h1><a class="mozTocH1" name="mozTocId611802"></a><big>Part 6. Other
        important things</big></h1>
    <big> </big>
    <h2><a class="mozTocH2" name="mozTocId900597"></a><big>Chapter 1. The
        sub–namespace</big></h2>
    <big> All subsystems in this section declared in <span style="font-style: italic;">Misc</span>
      sub–namespace.<br>
    </big>
    <h2><a class="mozTocH2" name="mozTocId942355"></a><big>Chapter 2. Memory</big></h2>
    <big> RAM is an important resource. Just use <span style="font-style: italic;">Memory</span>
      class to get total memory size and free memory size. Let's look at public
      methods.<br>
      <br>
      <span style="font-style: italic;">unsigned long long int
        Memory::get_total_physical();</span> – Return total physical memory size
      in bytes.<br>
      <br>
      <span style="font-style: italic;">unsigned long long int
        Memory::get_free_physical();</span> – Return free physical memory size
      in bytes.<br>
      <br>
      <span style=""><span style="font-style: italic;">unsigned long long int
          Memory::get_total_virtual();</span> </span>– Return total <a href="https://en.wikipedia.org/wiki/Virtual_memory">virtual
        memory</a> size in bytes.<br>
      <br>
      <span style="font-style: italic;">unsigned long long int
        Memory::get_free_virtual();</span> – Return free <a href="https://en.wikipedia.org/wiki/Virtual_memory">virtual
        memory</a> size in bytes.<br>
      <br>
      <span style="font-style: italic;">unsigned long int Memory::get_usage();</span>
      – Return amount of using physical memory in bytes.</big><big><br>
    </big>
    <h2><a class="mozTocH2" name="mozTocId522782"></a><big>Chapter 3. Audio</big></h2>
    <big><span style="text-decoration: underline;">A few words about multimedia
        subsystem</span><br>
      <br>
      Audio subsystem intend for playing music and sounds.<br>
      <br>
      <span style="text-decoration: underline;">Working with audio</span><br>
      <br>
      Just use <span style="font-style: italic;">Audio</span> class to work
      with audio. Let's look at public methods.<br>
      <br>
      <span style="font-style: italic;">void Audio::initialize();</span> –
      Initialize the subsystem.<br>
      <br>
      <span style="font-style: italic;">void Audio::initialize(const char
        *name);</span> – Initialize the subsystem and load a sound file.<br>
      <br>
      <span style="font-style: italic;">void Audio::load(const char *name);</span>
      – Load a sound file.<br>
      <br>
      <span style="font-style: italic;">void Audio::play();</span> – Play a
      content of the target file.<br>
      <br>
      <span style="font-style: italic;">void Audio::play_loop();</span> –
      Checking play status and restart play if needed.<br>
      <br>
      <span style="font-style: italic;">void Audio::play(const bool loop);</span>
      – Play a sound. You can set loop flag as true for loop playing mode.<br>
      <br>
      <span style="font-style: italic;">void Audio::stop();</span> – Stop
      playing a content of the target file.<br>
      <br>
      <span style="font-style: italic;">bool Audio::check_playing();</span> –
      Return true if the sound resource is playing.<br>
    </big><big> </big><big> </big> <big> </big>
    <h1><a name="mozTocId209024" class="mozTocH1"></a><big>Part 7. Misc</big></h1>
    <h2><a name="mozTocId608755" class="mozTocH2"></a><big>Chapter 1. File
        system</big></h2>
    <big><br>
      File system subsystem implement as two simple functions. All these
      functions declared in <span style="font-style: italic;">Filesystem</span>
      sub–namespace.<br>
      <br>
      <span style="font-style: italic;"> file_exist</span> function check the
      target file for exist.<br>
      <br>
      <span style="font-style: italic;"> delete_file</span> function delete the
      target file.<br>
      <br>
      All functions take target file name as argument and return false if the
      operation failed.</big><br>
    <big> </big>
    <h2><a name="mozTocId59386" class="mozTocH2"></a><big>Chapter 2. Tools</big></h2>
    <big>This module implemented as few simple functions</big><big>. All these
      functions declared in <span style="font-style: italic;">Tools</span>
      sub–namespace.<br>
      <br>
      <span style="font-style: italic;">void quit();</span> – Exit from your
      program and return user to operating system.<br>
      <br>
      <span style="font-style: italic;">bool enable_logging(const char *name);</span>
      – Enable redirecting error messages to a log file and return false if the
      operation failed.<br>
      <br>
      <span style="font-style: italic;">void randomize();</span> – Initialize
      random number generator.<br>
      <br>
      <span style="font-style: italic;">unsigned int get_random(const int
        number);</span> – Return a random value between zero and the number.<br>
      <br>
      <span style="font-style: italic;">unsigned int get_texture_size();</span>
      – Return maximum width or height of texture.<br>
      <br>
      <span style="font-style: italic;">BIRD2D::BOX generate_box(const unsigned
        int x,const unsigned int y,const unsigned int width,const unsigned int
        height);</span> – Generate collision related information.<br>
    </big>
    <h2><a name="mozTocId573582" class="mozTocH2"></a><big>Chapter 3. Resource
        manager</big></h2>
    <big>A resource is an instance of a user–defined class or structure.
      Resource manager is storage for resources. It implemented as few template
      functions. All these functions declared in <span style="font-style: italic;">Resource</span>
      sub–namespace.<br>
      <br>
      <span style="font-style: italic;">create</span> function create a single
      resource or array of resources. It has two form. First form create a
      single resource. First form takes a handle to resource handle as
      arguments. Second form create array of resources. Second form takes a
      handle to resource handle and resource amount as arguments.<br>
      <br>
      <span style="font-style: italic;"> destroy</span> function delete resource
      if it already exists. This function takes resource handle as argument.<br>
      <br>
      <span style="font-style: italic;"> destroy_array</span> function delete
      resource array if it already exists. This function takes resource array
      handle as argument.<br>
    </big>
    <h1><a name="mozTocId590919" class="mozTocH1"></a><big> Part 8. Binary files</big></h1>
    <h2><a name="mozTocId200879" class="mozTocH2"></a><big>Chapter 1. The
        sub–namespace</big></h2>
    <big>All subsystems in this section declared in <span style="font-style: italic;">File</span>
      sub–namespace.</big><br>
    <big> </big>
    <h2><a name="mozTocId961921" class="mozTocH2"></a><big> Chapter 2. Base
        binary file subsystem</big></h2>
    <big> <u> Work with binary files</u><br>
      <br>
      <i>Binary_File</i> class provide simple access to base binary subsystem.
      Don't use it directly. Let's look at public methods.<br>
      <br>
      <i> void Binary_File::close();</i> – Close the file.<br>
      <br>
      <i> void Binary_File::set_position(const long int offset);</i> – Set the
      file position.<br>
      <br>
      <i> long int Binary_File::get_position();</i> – Return current file
      position.<br>
      <br>
      <i> long int Binary_File::get_length();</i> – Return file length in bytes.<br>
      <br>
      <i> bool Binary_File::check_error();</i> – Return true if last file
      operation failed.<br>
      <br>
      <span style="font-style: italic;"> bool Binary_File::is_open() const;</span>
      – Return true if the file was successfully open.<br>
      <br>
      <u>Important notice</u><br>
      <br>
      Target file size limit is 2 gigabytes. </big>
    <h2><a name="mozTocId424835" class="mozTocH2"></a><big> Chapter 3. File
        reader</big></h2>
    <big> File reader is intending to reading data from a binary files. <i>Input_File</i>
      class provide access to file reader. It is derived from <i>Binary_File</i>
      class. Let's look at public methods.<br>
      <br>
      <span style="font-style: italic;">Input_File* Input_File::get_handle();</span>
      – Return the handle to file reader.<br>
      <br>
      <i> void Input_File::open(const char *name);</i> – Open a file for read.<br>
      <br>
      <i> void Input_File::read(void *buffer,const size_t length);</i> – Read
      data from the file. </big>
    <h2><a name="mozTocId511135" class="mozTocH2"></a><big> Chapter 4. File
        writer</big></h2>
    <big> File writer is intending to write data to binary files. <i>Output_File</i>
      class provide access to file writer. It is derived from <i>Binary_File</i>
      class. Let's look at public methods.<br>
      <br>
      <span style="font-style: italic;">Output_File* Output_File::get_handle();</span>
      – Return the handle to file writer.<br>
      <br>
      <i> void Output_File::open(const char *name);</i> – Open a file for write.<br>
      <br>
      <i> void Output_File::create_temp();</i> – Create a temporary file. This
      file will be deleted when it closed.<br>
      <br>
    </big> <big> <i> void Output_File::write(const void *buffer,const size_t
        length);</i> – Write data to the file.<br>
      <br>
    </big> <big><i>void Output_File::flush();</i> – Force writing internal
      buffer data to the file.</big><br>
    <big> </big>
    <h1><a name="mozTocId291572" class="mozTocH1"></a><big>Part 9. Input</big></h1>
    <h2><a name="mozTocId783369" class="mozTocH2"></a><big>Chapter 1. The
        sub–namespace</big></h2>
    <big>All subsystems in this section declared in <span style="font-style: italic;">Input</span>
      sub–namespace.</big><br>
    <big> </big>
    <h2><a name="mozTocId685403" class="mozTocH2"></a><big>Chapter 2. Keyboard</big></h2>
    <big> <span style="text-decoration: underline;"> Low–level input</span><br>
      <br>
      Any keyboard has a built–in chip. It generates a special code when user
      press or release key. This code called «scan code».<br>
      <br>
      <span style="text-decoration: underline;"> Working with keyboard</span><br>
      <br>
      Just use <span style="font-style: italic;">Keyboard</span> class to work
      with a keyboard. Let's look at public methods.<br>
      <br>
      <span style="font-style: italic;"> void Keyboard::initialize();</span> –
      Initialize the subsystem.<br>
      <br>
      <span style="font-style: italic;"> bool Keyboard::check_hold(const
        unsigned char code);</span> – Return true if key with specific scan–code
      is press or holding.<br>
      <br>
      <span style="font-style: italic;"> bool Keyboard::check_press(const
        unsigned char code);</span> – Return true if key with specific scan–code
      was press.<br>
      <br>
      <span style="font-style: italic;"> bool Keyboard::check_release(const
        unsigned char code);</span> – Return true if key with specific scan–code
      was release.<br>
      <br>
      <span style="font-style: italic;"> bool Keyboard::is_ready() const;</span>
      – Return true if the subsystem is already initialized.<br>
      <br>
      <span style="text-decoration: underline;"> List of supported scan–codes</span><br>
    </big>
    <p><big> You can see a list of scan–codes below.</big></p>
    <big> </big>
    <table border="1">
      <tbody>
        <tr>
          <td><big>Key </big></td>
          <td><big>Code </big></td>
          <td><big>Key </big></td>
          <td><big>Code </big></td>
          <td><big>Key </big></td>
          <td><big>Code </big></td>
        </tr>
        <tr>
          <td><big>Escape </big></td>
          <td><big>1 </big></td>
          <td><big>A </big></td>
          <td><big>30 </big></td>
          <td><big>F1 </big></td>
          <td><big>59 </big></td>
        </tr>
        <tr>
          <td><big>! or 1 </big></td>
          <td><big>2 </big></td>
          <td><big>S </big></td>
          <td><big>31 </big></td>
          <td><big>F2</big></td>
          <td><big>60 </big></td>
        </tr>
        <tr>
          <td><big>@ or 2 </big></td>
          <td><big>3 </big></td>
          <td><big>D </big></td>
          <td><big>32 </big></td>
          <td><big>F3</big></td>
          <td><big>61 </big></td>
        </tr>
        <tr>
          <td><big># or 3 </big></td>
          <td><big>4 </big></td>
          <td><big>F </big></td>
          <td><big>33 </big></td>
          <td><big>F4</big></td>
          <td><big>62 </big></td>
        </tr>
        <tr>
          <td><big>$ or 4 </big></td>
          <td><big>5 </big></td>
          <td><big>G </big></td>
          <td><big>34 </big></td>
          <td><big>F5</big></td>
          <td><big>63 </big></td>
        </tr>
        <tr>
          <td><big>% or 5 </big></td>
          <td><big>6 </big></td>
          <td><big>H </big></td>
          <td><big>35 </big></td>
          <td><big>F6</big></td>
          <td><big>64 </big></td>
        </tr>
        <tr>
          <td><big>^ or 6 </big></td>
          <td><big>7 </big></td>
          <td><big>J </big></td>
          <td><big>36 </big></td>
          <td><big>F7</big></td>
          <td><big>65 </big></td>
        </tr>
        <tr>
          <td><big>&amp; or 7 </big></td>
          <td><big>8 </big></td>
          <td><big>K </big></td>
          <td><big>37 </big></td>
          <td><big>F8</big></td>
          <td><big>66 </big></td>
        </tr>
        <tr>
          <td><big>* or 8 </big></td>
          <td><big>9 </big></td>
          <td><big>L </big></td>
          <td><big>38 </big></td>
          <td><big>F9</big></td>
          <td><big>67 </big></td>
        </tr>
        <tr>
          <td><big>( or 9 </big></td>
          <td><big>10 </big></td>
          <td><big>: or ;</big></td>
          <td><big>39 </big></td>
          <td><big>F10</big></td>
          <td><big>68 </big></td>
        </tr>
        <tr>
          <td><big>0 or ) </big></td>
          <td><big>11 </big></td>
          <td><big>" or ' </big></td>
          <td><big>40 </big></td>
          <td><big>F11</big></td>
          <td><big>133 </big></td>
        </tr>
        <tr>
          <td><big>_ or – </big></td>
          <td><big>12 </big></td>
          <td><big>~ or ` </big></td>
          <td><big>41 </big></td>
          <td><big>F12</big></td>
          <td><big>134 </big></td>
        </tr>
        <tr>
          <td><big>+ or = </big></td>
          <td><big>13 </big></td>
          <td><big>Left Shift </big></td>
          <td><big>42 </big></td>
          <td><big>Num Lock </big></td>
          <td><big>69 </big></td>
        </tr>
        <tr>
          <td><big>Backspace </big></td>
          <td><big>14 </big></td>
          <td><big>| or \ </big></td>
          <td><big>43 </big></td>
          <td><big>Scroll Lock </big></td>
          <td><big>70 </big></td>
        </tr>
        <tr>
          <td><big>Tab </big></td>
          <td><big>15 </big></td>
          <td><big>Z </big></td>
          <td><big>44 </big></td>
          <td><big>Home or 7 </big></td>
          <td><big>71 </big></td>
        </tr>
        <tr>
          <td><big>Q </big></td>
          <td><big>16 </big></td>
          <td><big>X </big></td>
          <td><big>45 </big></td>
          <td><big>Up or 8 </big></td>
          <td><big>72 </big></td>
        </tr>
        <tr>
          <td><big>W </big></td>
          <td><big>17 </big></td>
          <td><big>C </big></td>
          <td><big>46 </big></td>
          <td><big>Page up or 9 </big></td>
          <td><big>73 </big></td>
        </tr>
        <tr>
          <td><big>E </big></td>
          <td><big>18 </big></td>
          <td><big>V </big></td>
          <td><big>47 </big></td>
          <td><big>Gray – </big></td>
          <td><big>74 </big></td>
        </tr>
        <tr>
          <td><big>R </big></td>
          <td><big>19 </big></td>
          <td><big>B </big></td>
          <td><big>48 </big></td>
          <td><big>Left or 4 </big></td>
          <td><big>75 </big></td>
        </tr>
        <tr>
          <td><big>T </big></td>
          <td><big>20 </big></td>
          <td><big>N </big></td>
          <td><big>49 </big></td>
          <td><big>Center or 5 </big></td>
          <td><big>76 </big></td>
        </tr>
        <tr>
          <td><big>Y </big></td>
          <td><big>21 </big></td>
          <td><big>M </big></td>
          <td><big>50 </big></td>
          <td><big>Right or 6 </big></td>
          <td><big>77 </big></td>
        </tr>
        <tr>
          <td><big>U </big></td>
          <td><big>22 </big></td>
          <td><big>&lt; or , </big></td>
          <td><big>51 </big></td>
          <td><big>Neon + </big></td>
          <td><big>78 </big></td>
        </tr>
        <tr>
          <td><big>I </big></td>
          <td><big>23 </big></td>
          <td><big>&gt; or . </big></td>
          <td><big>52 </big></td>
          <td><big>End or 1 </big></td>
          <td><big>79 </big></td>
        </tr>
        <tr>
          <td><big>O </big></td>
          <td><big>24 </big></td>
          <td><big>? or / </big></td>
          <td><big>53 </big></td>
          <td><big>Down or 2 </big></td>
          <td><big>80 </big></td>
        </tr>
        <tr>
          <td><big>P </big></td>
          <td><big>25 </big></td>
          <td><big>Right shift </big></td>
          <td><big>54 </big></td>
          <td><big>Page down or 3 </big></td>
          <td><big>81 </big></td>
        </tr>
        <tr>
          <td><big>{ or [ </big></td>
          <td><big>26 </big></td>
          <td><big>Print Screen or * </big></td>
          <td><big>55 </big></td>
          <td><big>Insert or 0 </big></td>
          <td><big>82 </big></td>
        </tr>
        <tr>
          <td><big>} or ] </big></td>
          <td><big>27 </big></td>
          <td><big>Alt </big></td>
          <td><big>56 </big></td>
          <td><big>Delete or . </big></td>
          <td><big>83 </big></td>
        </tr>
        <tr>
          <td><big>Enter </big></td>
          <td><big>28 </big></td>
          <td><big>Spacebar </big></td>
          <td><big>57 </big></td>
          <td><big> </big><br>
          </td>
          <td><big> </big><br>
          </td>
        </tr>
        <tr>
          <td><big>Control </big></td>
          <td><big>29 </big></td>
          <td><big>Caps Lock </big></td>
          <td><big>58 </big></td>
          <td><big> </big><br>
          </td>
          <td><big> </big><br>
          </td>
        </tr>
      </tbody>
    </table>
    <big> </big>
    <h2><a name="mozTocId686993" class="mozTocH2"></a><big>Chapter 3. Mouse</big></h2>
    <big> <span style="text-decoration: underline;"> A few words about mouse</span><br>
      <br>
      Mouse is very useful for interaction with graphical user interface. But
      mouse also can use in a video games.<br>
      <br>
      <span style="text-decoration: underline;"> Working with mouse</span><br>
      <br>
      Just use <span style="font-style: italic;">Mouse</span> class to work
      with a mouse. Let's look at public methods.<br>
      <br>
      <span style="font-style: italic;">void Mouse::initialize();</span> –
      Initialize the subsystem.<br>
      <br>
      <span style="font-style: italic;"> void Mouse::show();</span> – Show mouse
      cursor.<br>
      <br>
      <span style="font-style: italic;"> void Mouse::hide();</span> – Hide mouse
      cursor.<br>
      <br>
      <span style="font-style: italic;"> unsigned int Mouse::get_x();</span> –
      Return x position of mouse.<br>
      <br>
      <span style="font-style: italic;"> unsigned int Mouse::get_y();</span> –
      Return y position of mouse.<br>
      <br>
      <span style="font-style: italic;"> void Mouse::set_position(const unsigned
        int x,const unsigned int y);</span> – Set position of mouse.<br>
      <br>
      <span style="font-style: italic;"> bool Mouse::check_hold(const
        BIRD2D::MOUSE_BUTTON button);</span> – Return true if specific mouse
      button is press or holding.<br>
      <br>
      <span style="font-style: italic;"> bool Mouse::check_press(const
        BIRD2D::MOUSE_BUTTON button);</span> – Return true if specific mouse
      button was press.<br>
      <br>
      <span style="font-style: italic;"> bool Mouse::check_release(const
        BIRD2D::MOUSE_BUTTON button);</span> – Return true if specific mouse
      button was release.<br>
      <br>
      <span style="text-decoration: underline;"> Mouse buttons</span><br>
    </big>
    <p><big> Mouse button codes look as predefined constants. You can see it
        below.</big></p>
    <big> </big>
    <table border="1">
      <tbody>
        <tr>
          <td><big>Mouse button code </big></td>
          <td><big>Button </big></td>
        </tr>
        <tr>
          <td><big>MOUSE_LEFT </big></td>
          <td><big>Left button </big></td>
        </tr>
        <tr>
          <td><big>MOUSE_RIGHT </big></td>
          <td><big>Right button </big></td>
        </tr>
        <tr>
          <td><big>MOUSE_MIDDLE </big></td>
          <td><big>Middle button </big></td>
        </tr>
      </tbody>
    </table>
    <big> </big> <big> <br>
    </big>
    <h2><a class="mozTocH2" name="mozTocId316549"></a><big>Chapter 3. Joystick</big></h2>
    <big><span style="font-style: italic;">Joystick</span> class provide simple
      access to <a href="https://en.wikipedia.org/wiki/Joystick">joystick</a>.
      It is a simple class with few methods.<br>
      <br>
      <span style="font-style: italic;">void Joystick::update();</span> – Update
      internal joystick state. Always call it before call another methods.<br>
      <br>
      <span style="font-style: italic;">void Joystick::initialize(const char
        *joystick);</span> – Initialize the subsystem.<br>
      <br>
      <span style="font-style: italic;">bool Joystick::is_ready() const;</span>
      – Return true if the subsystem is already initialized.<br>
      <br>
      <span style="font-style: italic;">bool Joystick::check_hold(const size_t
        button) const;</span> – Return true if the button is press or holding.<br>
      <br>
      <span style="font-style: italic;">bool Joystick::check_press(const size_t
        button) const;</span> – Return true if the button was press.<br>
      <br>
      <span style="font-style: italic;">bool Joystick::check_released(const
        size_t button) const;</span> – Return true if the button was release.<br>
      <br>
      <span style="font-style: italic;">short int Joystick::get_axe(const size_t
        target);</span> – Return current value of target joystick axe.<br>
      <br>
      <span style="font-style: italic;">size_t Joystick::get_button_amount()
        const;</span> – Return amount of the joystick buttons.<br>
      <br>
      <span style="font-style: italic;">size_t Joystick::get_axe_amount() const;</span>
      – Return amount of the joystick axe.<br>
    </big>
    <h1><a name="mozTocId309127" class="mozTocH1"></a><big>Part 10. Internal
        details of the engine subsystems</big></h1>
    <big></big> <big> </big>
    <h2><a name="mozTocId383177" class="mozTocH2"></a><big>Chapter 1. A few
        words for a curious programmer</big></h2>
    <big> The engine subsystems have a different internal structure. It has
      hidden from you, and you don't have access to it. Do you want to know
      about hiding things? Just read a next chapter.</big><br>
    <big> </big>
    <h2><a name="mozTocId318160" class="mozTocH2"></a><big>Chapter 2. Internal
        classes</big></h2>
    <big><span style="text-decoration: underline;">Internal classes</span><br>
      <br>
      Some classes designed for internal use only. Don't touch them. What doing
      these strange classes?<br>
      <br>
      <span style="text-decoration: underline;">Unix specific classes</span><br>
      <br>
      All <a href="https://en.wikipedia.org/wiki/Unix">Unix</a> specific
      classes declared in <span style="font-style: italic;">Internal</span>
      sub–namespace.<br>
      <br>
      <span style="font-style: italic;"> Engine</span> creates the game window
      and do message processing.<br>
      <span style="font-style: italic;"> Synchronization</span> implements the
      synchronization timer.<br>
    </big><big><span style=""></span></big><br>
    <big> <span style="text-decoration: underline;"> Core classes</span><br>
      <br>
      All engine core classes and functions declared in <span style="font-style: italic;">Core</span>
      sub–namespace.<br>
      <br>
    </big> <big><span style="font-style: italic;"> FPS</span> implement fps
      counter.</big><big><i></i><br>
      <span style="font-style: italic;"> Buffer</span> implement custom memory
      buffer.<br>
    </big><big><span style="font-style: italic;"> Render</span> implement OPENGL
      render.<br>
      <span style="font-style: italic;"> Resizer</span> intending to calculate
      correct texture size.<br>
      <span style="font-style: italic;"> Rectangle</span> intending to draw
      textured rectangle.<br>
      <span style="font-style: italic;"> Shape</span> is base class of <span style="font-style: italic;">Rectangle</span>
      class.<br>
    </big>
    <h2><a name="mozTocId293644" class="mozTocH2"></a><big>Chapter 3. Base
        graphics subsystem</big></h2>
    <big> </big><big style="text-decoration: underline;">Visible object</big><br>
    <big> </big><br>
    <big> Any visible object is a textured rectangle.</big><br>
    <big> </big><br>
    <big style="text-decoration: underline;"> Images</big><br>
    <big> </big><br>
    <big> A texture width must be a power of two. A texture height also must be
      a power of two. Any image will automatically resize before load.</big><br>
    <br>
    <big style="text-decoration: underline;"> Vertex arrays and texture
      coordinates arrays</big><br>
    <big> </big><br>
    <big> Any rectangle need four vertexes and four texture coordinates.</big><br>
    <big> Single vertex represent by follow custom data type.</big><br>
    <big> </big><br>
    <big style="font-style: italic;"> typedef struct</big> <big style="font-style: italic;">
      <br>
      {</big> <span style="font-style: italic;"><br>
      &nbsp; </span><big style="font-style: italic;">int x;</big> <span style="font-style: italic;"><br>
    </span><big style="font-style: italic;">&nbsp; int y;</big><big style="font-style: italic;"><br>
      } Vertex;</big><br>
    <big> </big><br>
    <big> </big><big>Single texture coordinate represent by follow custom data
      type.</big><br>
    <big> </big><br>
    <big style="font-style: italic;"> typedef struct</big> <big style="font-style: italic;">
      <br>
      {</big><br>
    &nbsp; <span style="font-style: italic;"></span><big style="font-style: italic;">float
      u;</big><br>
    <span style="font-style: italic;"></span><big style="font-style: italic;">
      float v;</big><big style="font-style: italic;"><br>
      } Point;</big><br>
    <big> </big> <br>
    <big>All these custom types declared in <span style="font-style: italic;">Core</span>
      sub–namespace.</big><span style=""></span><big><br>
    </big>
    <h2><a name="mozTocId804583" class="mozTocH2"></a><big>Chapter 4. Input</big></h2>
    <big> <span style="text-decoration: underline;"> Input back–end</span><br>
      <br>
      Keyboard and mouse input subsystems are simple. It works over Xlib.<br>
      <br>
      <span style="text-decoration: underline;"> Internal key state</span><br>
    </big>
    <p><big> Internal state of keyboard keys and mouse buttons look as
        predefined constants. You can see it below.</big></p>
    <big> </big>
    <table border="1">
      <tbody>
        <tr>
          <td><big>Key/button state </big></td>
          <td><big>Description </big></td>
        </tr>
        <tr>
          <td><big>KEY_PRESSED </big></td>
          <td><big>A key\button is press or holding </big></td>
        </tr>
        <tr>
          <td><big>KEY_RELEASED </big></td>
          <td><big>A key\button was release </big></td>
        </tr>
      </tbody>
    </table>
    <big> <br>
    </big>
    <h2><a class="mozTocH2" name="mozTocId389200"></a><big>Chapter 5. Joystick</big></h2>
    <big>Joystick subsystem working over <a href="https://www.kernel.org/doc/Documentation/input/joystick-api.txt">Linux
        Joystick API</a>.<br>
    </big>
    <h2><a class="mozTocH2" name="mozTocId45292"></a><big>Chapter 6. </big><big>Audio
        subsystem</big></h2>
    <big>Audio subsystem</big><big> working over libVLC.</big><br>
    <h1><a name="mozTocId78453" class="mozTocH1"></a><big>Version history</big></h1>
    <big> 0.1 – Initial version.<br>
      0.1.1 – 0.3.4 – Unstable branch.<br>
      0.3.5 – Preview release.<br>
      0.3.6 – 0.3.7 – Small changes.<br>
      0.3.8 – Full–screen mode is implemented.<br>
      0.3.9 – Mouse input improved.<br>
      0.4 – Keyboard input improved.<br>
      0.4.1 – Mouse input improved.<br>
      0.4.2 – 0.4.3 – Small changes.<br>
      0.4.4 – Makefile updated.<br>
      0.4.5 – New subsystem added.<br>
      0.4.5 – 0.4.9 – Small changes.<br>
      0.5 – 0.5.3 – Mouse input improved.<br>
      0.5.4 – 0.5.6 – Small changes.<br>
      0.5.7 – Stable release.<br>
      0.5.8 – Small changes.<br>
      0.5.9 – Joystick support added.<br>
      0.6 – 0.7.3 – Joystick support improved.<br>
      0.7.4 – Small changes.<br>
      0.7.4.1 – Documentation updated.<br>
      0.7.5 – Memory leak fixed.<br>
      0.7.6 – Memory usage reduced.<br>
      0.7.7 – Sound support added.<br>
      0.7.8 – 0.9.5 – Sound support improved.<br>
      0.9.6 – 1.0 – Small changes.<br>
      1.0.1 – 1.0.2 – Small bug fixed.<br>
      1.0.3 – Memory usage reduced.<br>
      1.0.3 – 1.0.8 – Audio loader improved.<br>
      1.0.9 – 1.1.1 – Small changes.<br>
      1.1.2 – 1.1.9 – Low-level sound subsystem improved.<br>
      1.2 – Memory leak fixed.<br>
      1.2.1 – 1.2.3 – Small bug fixed.<br>
      1.2.4 – 1.2.5 – Small changes.<br>
      1.2.6 – Small bug fixed.<br>
      1.2.7 – 1.2.9 – Small changes.<br>
      1.3 – Audio subsystem was totally rewritten.<br>
      1.3.1 – 1.3.3 – Audio subsystem improved.<br>
      1.3.4 – 1.3.6 – Small changes.<br>
      1.3.7 – Image resizer back-ported from Simple windows game framework 7.3.5.<br>
      1.3.8 – Image resizer back-ported from Eugene game development kit 7.3.7.<br>
      1.3.9 – Tile–map subsystem back-ported from Eugene game development kit 7.4.4.<br>
      1.4 – Image resizer back-ported from Eugene game development kit 7.3.5.<br>
      1.4.1 – Image resizer back-ported from Eugene game development kit 7.5.<br>
      1.4.2 – Coordinates conversion subsystem back-ported from Eugene game development kit 7.5.3.<br>
      1.4.3 – Keyboard input improved.<br>
      1.4.4 – Coordinates conversion subsystem back-ported from Eugene game development kit 7.5.4.<br>
      1.4.5 – Keyboard input improved.<br>
      1.4.6 – Coordinates conversion subsystem back-ported from Eugene game development kit 7.5.8.<br>
      1.4.7 – Source code synced with Eugene game development kit 7.6.3.<br>
      1.4.8 – Tile–map subsystem back-ported from Eugene game development kit 7.6.4.<br>
      1.4.9 – Coordinates conversion subsystem back-ported from Eugene game development kit 7.6.5.<br>
      1.5 – Base graphics subsystem improved.<br>
      1.5.1 – Image resizer back-ported from Eugene game development kit 7.6.8.<br>
      1.5.2 – Image resizer back-ported from Eugene game development kit 7.6.9.<br>
      1.5.3 – Image resizer back-ported from Eugene game development kit 7.7.<br>
      1.5.4 – Image resizer back-ported from Eugene game development kit 7.7.2<br>
      1.5.5 – Image resizer back-ported from Eugene game development kit 7.7.3.<br>
      1.5.6 – Image resizer back-ported from Eugene game development kit 7.7.4.<br>
      1.5.7 – Image resizer back-ported from Eugene game development kit 7.7.5.<br>
      1.5.8 – Image resizer back-ported from Eugene game development kit 7.7.6.<br>
      1.5.9 – Synchronization timer improved.<br>
      1.6 – Isometric subsystem back-ported from Eugene game development kit 7.8.<br>
      1.6.1 – Isometric subsystem back-ported from Eugene game development kit 7.8.1.<br>
      1.6.2 – Isometric level subsystem back-ported from Eugene game development kit 7.8.4.<br>
      1.6.3 – Animation subsystem back-ported from Eugene game development kit 7.8.6.<br>
      1.6.4 – Sprite sheet subsystem back-ported from Eugene game development kit 7.8.8.<br>
      1.6.5 – Base sprite subsystem back-ported from Eugene game development kit 7.8.9.<br>
      1.6.6 – Text drawing subsystem back-ported from Eugene game development kit 7.9.<br>
      1.6.7 – Base sprite subsystem back-ported from Eugene game development kit 7.9.1.<br>
      1.6.8 – Background subsystem back-ported from Eugene game development kit 7.9.2.<br>
      1.6.9 – Static sprite subsystem back-ported from Eugene game development kit 7.9.3.<br>
      1.7 – Static background subsystem back-ported from Eugene game development kit 7.9.4.<br>
      1.7.1 – Source code synced with Eugene game development kit 7.9.5.<br>
      1.7.2 – Source code synced with Eugene game development kit 7.9.6.<br>
      1.7.3 – Base sprite subsystem back-ported from Eugene game development kit 7.9.7.<br>
      1.7.4 – Image loader back-ported from Eugene game development kit 7.9.8.<br>
      1.7.5 – Image resizer back-ported from Eugene game development kit 8.0.3.<br>
      1.7.6 – Source code synced with Eugene game development kit 8.0.4.<br>
      1.7.7 – Source code synced with Eugene game development kit 8.0.5.<br>
      1.7.8 – Source code synced with Eugene game development kit 8.0.8.<br>
      1.7.9 – Source code synced with Eugene game development kit 8.0.9.<br>
      1.8 – Source code synced with Eugene game development kit 8.1.4.<br>
      1.8.1 – Source code synced with Eugene game development kit 8.1.5.<br>
      1.8.2 – Source code synced with Eugene game development kit 8.1.6.<br>
      1.8.3 – Source code synced with Eugene game development kit 8.1.7.<br>
      1.8.4 – Source code synced with Eugene game development kit 8.1.8.<br>
      1.8.5 – Source code synced with Eugene game development kit 8.2.1.<br>
      1.8.6 – Small changes.<br>
      1.8.7 – Source code synced with Eugene game development kit 8.2.2.<br>
      1.8.8 – Source code synced with Eugene game development kit 8.2.3.<br>
      1.8.9 – Source code synced with Eugene game development kit 8.2.6.<br>
      1.9 – Source code synced with Eugene game development kit 8.2.8.<br>
      1.9.1 – Source code synced with Eugene game development kit 8.3.<br>
      1.9.2 – Source code synced with Eugene game development kit 8.3.1.<br>
      1.9.3 – Source code synced with Eugene game development kit 8.3.2.<br>
      1.9.4 – Source code synced with Eugene game development kit 8.3.3.<br>
      1.9.5 – Source code synced with Eugene game development kit 8.3.4.<br>
      1.9.6 – Source code synced with Eugene game development kit 8.4.2.<br>
      1.9.7 – Source code synced with Eugene game development kit 8.4.4.<br>
      1.9.8 – Source code synced with Eugene game development kit 8.4.5.<br>
      1.9.8.1 – Documentation updated.<br>
      1.9.9 – Source code synced with Eugene game development kit 8.4.6.<br>
      2.0 – Source code synced with Eugene game development kit 8.4.8.<br>
      2.0.1 – Source code synced with Eugene game development kit 8.5.<br>
      2.0.2 – Source code synced with Eugene game development kit 8.5.5.<br>
      2.0.3 – Source code synced with Eugene game development kit 8.5.6.<br>
      2.0.4 – Source code synced with Eugene game development kit 8.5.7.<br>
      2.0.5 – Source code synced with Eugene game development kit 8.5.8.<br>
      2.0.6 – Source code synced with Eugene game development kit 8.5.9.<br>
      2.0.7 – Source code synced with Eugene game development kit 8.6.<br>
      2.0.8 – Source code synced with Eugene game development kit 8.6.1.<br>
      2.0.9 – Source code synced with Eugene game development kit 8.6.2.<br>
      2.1 – Source code synced with Eugene game development kit 8.6.5.<br>
      2.1.1 – Source code synced with Eugene game development kit 8.6.6.<br>
      2.1.2 – Source code synced with Eugene game development kit 8.6.8.<br>
      2.1.3 – Small changes.<br>
      2.1.4 – Source code synced with Eugene game development kit 8.7.1.<br>
      2.1.5 – Source code synced with Eugene game development kit 8.7.2.<br>
      2.1.6 – Source code synced with Eugene game development kit 8.7.8.<br>
      2.1.7 – Source code synced with Eugene game development kit 8.8.5.<br>
      2.1.8 – Source code synced with Black game development kit 5.8.2.<br>
      2.1.9 – Source code synced with Eugene game development kit 8.8.7.<br>
      2.2 – Source code synced with Eugene game development kit 8.8.8.<br>
      2.2.1 – Source code synced with Black game development kit 5.8.7.<br>
      2.2.2 – Source code synced with Black game development kit 5.8.8.<br>
      2.2.3 – Source code synced with Black game development kit 5.9.<br>
      2.2.4 – Source code synced with Black game development kit 5.9.4.<br>
      2.2.5 – Source code synced with Black game development kit 5.9.6.<br>
      2.2.6 – Small changes.<br>
      2.2.7 – Source code synced with Eugene game development kit 8.9.9.<br>
      2.2.8 – Keyboard input subsystem back-ported from Neon game development kit 7.9.1.<br>
      2.2.9 – Source code synced with Eugene game development kit 9.0.3.<br>
      2.3 – Source code synced with Eugene game development kit 9.0.4.<br>
      2.3.1 – Source code synced with Eugene game development kit 9.0.5.<br>
      2.3.2 – Source code synced with Eugene game development kit 9.0.6.<br>
      2.3.3 – Source code synced with Eugene game development kit 9.0.7.<br>
    </big>
  </body>
</html>