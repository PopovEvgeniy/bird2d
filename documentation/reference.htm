<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=us-ascii">
    <title>Programmer Reference</title>
  </head>
  <body>
    <div align="center"><big>Bird 2D: Programmer Reference</big><br>
    </div>
    <big><br>
    </big>
    <ol id="mozToc">
      <!--mozToc h1 1 h2 2 h3 3 h4 4 h5 5 h6 6-->
      <li><a href="#mozTocId251512">Part 1. Welcome to Bird 2D</a>
        <ol>
          <li><a href="#mozTocId644886">Chapter 1. Introduction</a></li>
          <li><a href="#mozTocId712481">Chapter 2. A special thanks</a></li>
          <li><a href="#mozTocId620001">Chapter 3. License</a></li>
          <li><a href="#mozTocId610167">Chapter 4. Dependencies</a></li>
          <li><a href="#mozTocId87585">Chapter 5. The engine namespace</a></li>
          <li><a href="#mozTocId757406">Chapter 6. Custom data types</a></li>
        </ol>
      </li>
      <li><a href="#mozTocId855711">Part 2. Base things</a>
        <ol>
          <li><a href="#mozTocId441637">Chapter 1. Coordinate system</a></li>
          <li><a href="#mozTocId840547">Chapter 2. Game loop</a></li>
        </ol>
      </li>
      <li><a href="#mozTocId506974">Part 3. Graphics</a>
        <ol>
          <li><a href="#mozTocId104881">Chapter 1. The sub-namespace</a></li>
          <li><a href="#mozTocId64853">Chapter 2. Base graphics subsystem</a></li>
          <li><a href="#mozTocId273595">Chapter 3. Picture subsystem</a></li>
          <li><a href="#mozTocId312870">Chapter 4. Animation subsystem</a></li>
          <li><a href="#mozTocId754248">Chapter 5. Vertex index</a></li>
          <li><a href="#mozTocId218099">Chapter 6. Image kind</a></li>
          <li><a href="#mozTocId389868">Chapter 7. Background</a></li>
          <li><a href="#mozTocId297302">Chapter 8. Static background</a></li>
          <li><a href="#mozTocId291174">Chapter 9. Parallax</a></li>
          <li><a href="#mozTocId98006">Chapter 10. Base sprite subsystem</a></li>
          <li><a href="#mozTocId920538">Chapter 11. Ordinary sprites</a></li>
          <li><a href="#mozTocId895327">Chapter 12. Static sprites</a></li>
          <li><a href="#mozTocId132557">Chapter 13. Sprite sheet</a></li>
          <li><a href="#mozTocId910339">Chapter 14. Text</a></li>
          <li><a href="#mozTocId122295">Chapter 15. Loading images</a></li>
          <li><a href="#mozTocId845590">Chapter 16. Camera</a></li>
        </ol>
      </li>
      <li><a href="#mozTocId516694">Part 4. Transformation</a>
        <ol>
          <li><a href="#mozTocId771051">Chapter 1. The sub-namespace</a></li>
          <li><a href="#mozTocId197525">Chapter 2. Cartesian coordinates and
              screen coordinates</a></li>
          <li><a href="#mozTocId176902">Chapter 3. Cartesian coordinates and
              isometric coordinates</a></li>
          <li><a href="#mozTocId684253">Chapter 4. Isometric level</a></li>
        </ol>
      </li>
      <li><a href="#mozTocId411027">Part 5. Common things</a>
        <ol>
          <li><a href="#mozTocId370034">Chapter 1. The sub-namespace</a></li>
          <li><a href="#mozTocId50801">Chapter 2. Abnormal program termination</a></li>
          <li><a href="#mozTocId287426">Chapter 3. Timer</a></li>
          <li><a href="#mozTocId340292">Chapter 4. Collision</a></li>
          <li><a href="#mozTocId237921">Chapter 5. Tile map</a></li>
        </ol>
      </li>
      <li><a href="#mozTocId147043">Part 6. Other important things</a>
        <ol>
          <li><a href="#mozTocId53728">Chapter 1. The sub-namespace</a></li>
          <li><a href="#mozTocId749487">Chapter 2. Memory</a></li>
          <li><a href="#mozTocId407036">Chapter 3. Audio</a></li>
        </ol>
      </li>
      <li><a href="#mozTocId15273">Part 7. Misc</a>
        <ol>
          <li><a href="#mozTocId631611">Chapter 1. File system</a></li>
          <li><a href="#mozTocId920039">Chapter 2. Tools</a></li>
          <li><a href="#mozTocId258567">Chapter 3. Resource Manager</a></li>
        </ol>
      </li>
      <li><a href="#mozTocId242557">Part 8. Binary files</a>
        <ol>
          <li><a href="#mozTocId843024">Chapter 1. The sub-namespace</a></li>
          <li><a href="#mozTocId302257">Chapter 2. Base binary file subsystem</a></li>
          <li><a href="#mozTocId983262">Chapter 3. File reader</a></li>
          <li><a href="#mozTocId541605">Chapter 4. File writer</a></li>
        </ol>
      </li>
      <li><a href="#mozTocId579355">Part 9. Input</a>
        <ol>
          <li><a href="#mozTocId524142">Chapter 1. The sub-namespace</a></li>
          <li><a href="#mozTocId579252">Chapter 2. Keyboard</a></li>
          <li><a href="#mozTocId512643">Chapter 3. Mouse</a></li>
          <li><a href="#mozTocId958601">Chapter 4. Joystick</a></li>
        </ol>
      </li>
      <li><a href="#mozTocId811838">Part 10. Internal details of the engine
          subsystems</a>
        <ol>
          <li><a href="#mozTocId841757">Chapter 1. A few words for a curious
              programmer</a></li>
          <li><a href="#mozTocId923720">Chapter 2. Internal classes</a></li>
          <li><a href="#mozTocId889998">Chapter 3. Base graphics subsystem</a></li>
          <li><a href="#mozTocId324625">Chapter 4. Joystick</a></li>
          <li><a href="#mozTocId446231">Chapter 5. Input</a></li>
          <li><a href="#mozTocId606783">Chapter 6. Audio</a></li>
        </ol>
      </li>
      <li><a href="#mozTocId707314">Version history</a></li>
    </ol>
    <h1><a id="mozTocId251512" class="mozTocH1"></a><big>
        Part 1. Welcome to Bird 2D</big></h1>
    <h2><a id="mozTocId644886" class="mozTocH2"></a><big>
        Chapter 1. Introduction</big></h2>
    <big>
      <u>
        Introduction</u><br>
      <br>
      Hello from Russia. My name is Popov Evgeniy Alekseyevich. I am the
      individual programmer. I enjoy creating software. I also like the
      old-school video games. Do you want to develop video games for <a href="https://en.wikipedia.org/wiki/Linux">Linux</a>?
      You need a good game engine to do it. I made my own engine. I hope that
      my C++ game engine will be useful for many programmers.<br>
      <br>
      <u>
        Features</u><br>
      <br>
      Let me show you the engine features. Let's go.<br>
      <br>
    </big>
    <ul>
      <li><big>
          Open source code.</big></li>
      <li><big>
          Easy-to-use object-oriented design.</big></li>
      <li><big>
          Very fast.</big></li>
      <li><big>
          Minimum external dependencies: only <a href="https://gitlab.freedesktop.org/xorg/lib/libx11">Xlib</a>,
          <a href="https://mesa3d.org">Mesa 3D</a>, and <a href="https://www.videolan.org/vlc/libvlc.html">libVLC</a>
          libraries.</big></li>
      <li><big>
          You don't need to link a main program with the
          engine binary file. The engine is just the source code files.</big></li>
    </ul>
    <big><u><br>
        Installation</u><br>
      <br>
      How do I install this engine? Follow these steps:<br>
      <br>
      Copy these files to your project directory:<br>
      <br>
    </big>
    <ul>
      <li><big>
          bird2d.h</big></li>
      <li><big>
          bird2d.cpp</big></li>
    </ul>
    <big><br>
      Add it to your project.<br>
      Add this directive to your code: <i>#include "bird2d.h"</i><br>
      <br>
      Yes. This is really all you need to do.<br>
    </big>
    <h2><a id="mozTocId712481" class="mozTocH2"></a><big>
        Chapter 2. A special thanks</big></h2>
    <big>
      I want to say «Big thanks for technical consultation» to these people:<br>
      <br>
    </big>
    <ul>
      <li><big>
          <a href="https://github.com/dmitrysmagin">Dmitry Smagin</a></big></li>
      <li><big>
          <a href="https://bsg.org.ua">Pavel Samko</a></big></li>
      <li><big>
          <a href="https://github.com/EXL">EXL</a></big></li>
      <li><big>
          <a href="http://www.almost-university.com">Vladimir Mozhenkov</a></big></li>
      <li><big>
          <a href="https://vk.com/strong666">Vitaliy Molochkov</a></big></li>
      <li><big>
          <a href="mailto:eyegem@mail.ru">Evgenia Germanova</a></big></li>
      <li><big>
          DDMZ</big></li>
      <li><big>
          Anastasiya</big></li>
    </ul>
    <big><br>
      Thanks to the PVS-Studio team for the <a href="https://www.viva64.com/en/b/0614/">free
        license</a>.<br>
    </big>
    <h2><a id="mozTocId620001" class="mozTocH2"></a><big>
        Chapter 3. License</big></h2>
    <big>
      Copyright (C) 2023 – 2025 Popov Evgeniy Alekseyevich<br>
      <br>
      This software is provided 'as–is', without any express or implied<br>
      warranty. In no event will the authors be held liable for any damages<br>
      arising from the use of this software.<br>
      Permission is granted to anyone to use this software for any purpose,<br>
      including commercial applications, and to alter it and redistribute it<br>
      freely, subject to the following restrictions:<br>
      1. The origin of this software must not be misrepresented; you must not<br>
      claim that you wrote the original software. If you use this software<br>
      in a product, an acknowledgment in the product documentation would be<br>
      appreciated but is not required.<br>
      2. Altered source versions must be plainly marked as such, and must not
      be<br>
      misrepresented as being the original software.<br>
      3. This notice may not be removed or altered from any source
      distribution.<br>
    </big>
    <h2><a id="mozTocId610167" class="mozTocH2"></a><big>
        Chapter 4. Dependencies</big></h2>
    <big>
      You need libx11-dev, libgl1-mesa-dev and libvlc-dev packages to compile
      this game engine.<br>
    </big>
    <h2><a id="mozTocId87585" class="mozTocH2"></a><big>
        Chapter 5. The engine namespace</big></h2>
    <big>
      BIRD2D is the main namespace. All the engine classes are declared in a
      few nested namespaces.<br>
    </big>
    <h2><a id="mozTocId757406" class="mozTocH2"></a><big>
        Chapter 6. Custom data types</big></h2>
    <big>
      Almost all custom data types are declared in the <i>BIRD2D</i> namespace.<br>
    </big>
    <h1><a id="mozTocId855711" class="mozTocH1"></a><big>
        Part 2. Base things</big></h1>
    <h2><a id="mozTocId441637" class="mozTocH2"></a><big>
        Chapter 1. Coordinate system</big></h2>
    <big><br>
      The engine uses the standard coordinate system by default. The
      coordinates start at the top-left corner. Look at this picture to
      understand it.<br>
      <br>
      <img alt="" src="coordinate_system.png" height="111" width="107"><br>
      <br>
    </big>
    <h2><a id="mozTocId840547" class="mozTocH2"></a><big>
        Chapter 2. Game loop</big></h2>
    <big>
      What is the main point in your game? A game loop. You can see the
      structure of a typical game loop below.<br>
      <br>
      <img alt="" src="game_loop.png" height="354" width="379"><br>
      <br>
    </big>
    <h1><a id="mozTocId506974" class="mozTocH1"></a><big>
        Part 3. Graphics</big></h1>
    <h2><a id="mozTocId104881" class="mozTocH2"></a><big>
        Chapter 1. The sub-namespace</big></h2>
    <big>
      <br>
      All classes in this section are declared in the Graphics sub-namespace.<br>
    </big>
    <h2><a id="mozTocId64853" class="mozTocH2"></a><big>
        Chapter 2. Base graphics subsystem</big></h2>
    <big>
      <u>
        Introduce</u><br>
      <br>
      The base graphics subsystem does render a game scene. This subsystem
      uses <a href="http://opengl.org">OPENGL</a> for rendering. All modern
      video cards support
      hardware-accelerated OPENGL. The software OPENGL will be activated if
      the acceleration is not available.<br>
      <u><br>
        Render performance</u><br>
      <br>
      Always use the latest video card drivers. It may increase rendering
      performance. You can also try to change the screen resolution if you
      have low rendering performance.<br>
      <br>
      <u>
        FPS limitation</u><br>
      <br>
      FPS is an important thing. Many FPS are needed for good animation, but
      it also needs high processor usage. The FPS limit is 60 by default. It
      has an ideal value.<br>
      <u><br>
        Work with the base graphics subsystem</u><br>
      <br>
      The <i>Screen</i> class provides access to the base graphics subsystem.
      Let's
      look at the publicly available methods.<br>
      <br>
      <i>
        void Screen::clear_screen(); -</i> Clear the screen. Fill it with black color.<br>
      <i><br>
        void Screen::initialize(); -</i> Initialize the base graphic subsystem.<br>
      <i><br>
        bool Screen::sync(); -</i> Show the current content of the back buffer
      on the screen. Return false if a game is terminated. This method uses the
      FPS limits and waits between frames.<br>
      <br>
      <i>
        bool Screen::update(); -</i> Show the current content of the back buffer
      on the screen. Return false if a game is terminated. This method ignores
      the FPS limit and needs high processor usage.<br>
      <i><br>
        bool Screen::sync(const bool limit); -</i> Show the current content of
      the back buffer on the screen. Return false if a game is terminated.<br>
      <i><br>
        bool Screen::is_ready(); -</i> Return true if the subsystem has already
      been initialized.<br>
      <br>
      <i>
        unsigned int Screen::get_fps() const; -</i> Return the current FPS
      value.<br>
      <i><br>
        unsigned int Screen::get_color() const; -</i> Return the current color
      depth in bits per pixel.<br>
      <br>
      <i>
        unsigned int Screen::get_width() const; -</i> Return the screen width in
      pixels.<br>
      <br>
      <i>
        unsigned int Screen::get_height() const; -</i> Return the screen height
      in pixels.<br>
      <i><br>
        bool Screen::check_x(const unsigned int x) const; -</i> Return true if
      the x-coordinate is valid.<br>
      <br>
      <i>
        bool Screen::check_y(const unsigned int y) const; -</i> Return true if
      the y-coordinate is valid.<br>
      <br>
      <i>
        bool Screen::check_horizontal_border(const BIRD2D::BOX target) const; -</i>
      Return true if a game object has collided with the horizontal screen
      border.<br>
      <i><br>
        bool Screen::check_vertical_border(const BIRD2D::BOX target) const; -</i>
      Return true if a game object has collided with the vertical screen
      border.<br>
      <br>
      <i>
        Screen *Screen::get_handle(); -</i> Return the handle to the base
      graphics subsystem object.<br>
    </big>
    <h2><a id="mozTocId273595" class="mozTocH2"></a><big>
        Chapter 3. Picture subsystem</big></h2>
    <big>
      <u>
        An important subsystem</u><br>
      <br>
      The picture subsystem implements image storage.<br>
      <br>
      <u>
        Work with the picture subsystem</u><br>
      <br>
      The <i>Picture</i> class provides simple access to the picture subsystem.
      Don't use it directly. Let's look at the publicly available methods.<br>
      <br>
      <i>
        unsigned int *Picture::get_image(); -</i> Return the handle to the image
      storage.<br>
      <i><br>
        void Picture::destroy_image(); -</i> Destroy an image in the storage.<br>
      <br>
      <i>
        bool Picture::is_storage_empty() const; -</i> Return true if the storage
      is empty.<br>
      <i><br>
        unsigned int Picture::get_image_width() const; -</i> Return the image
      width in pixels.<br>
      <br>
      <i>
        unsigned int Picture::get_image_height() const; -</i> Return the image
      height in pixels.<br>
      <br>
      <i>
        size_t Picture::get_pixel_amount() const; -</i> Return the amount of the
      image pixels.<br>
      <br>
      <i>
        size_t Picture::get_image_lenght() const; -</i> Return the image length
      in bytes.<br>
    </big>
    <h2><a id="mozTocId312870" class="mozTocH2"></a><big>
        Chapter 4. Animation subsystem</big></h2>
    <big>
      <u>
        An important subsystem</u><br>
      <br>
      The animation subsystem lets you control the animation frames.<br>
      <u><br>
        Frame indexing</u><br>
      <br>
      The first frame index is 1.<br>
      <br>
      <u>
        Work with the animation subsystem</u><br>
      <br>
      The <i>Animation</i> class provides simple access to the animation
      subsystem. Don't use it directly. Let's look at the publicly available methods.<br>
      <br>
      <i>
        unsigned int Animation::get_frames() const; -</i> Return the number of
      the frames.<br>
      <i><br>
        unsigned int Animation::get_frame() const; -</i> Return the current frame.<br>
      <i><br>
        bool Animation::is_last_frame() const; -</i> Return true if the current
      frame is the last frame.<br>
      <br>
      <i>
        bool Animation::check_frame(const unsigned int target) const; - </i>Return
        true if the target frame is valid.<br>
    </big>
    <h2><a id="mozTocId754248" class="mozTocH2"></a><big>
        Chapter 5. Vertex index</big></h2>
    <big>
      <br>
      The vertex index looks like the predefined constants. You can see it
      below.<br>
      <br>
    </big>
    <table style="width: 358px; height: 139px;" border="1">
      <tbody>
        <tr>
          <td><big>Vertex index<br>
            </big></td>
          <td><big>Description</big></td>
        </tr>
        <tr>
          <td><big>FIRST_VERTEX<br>
            </big></td>
          <td><big>The first vertex<br>
            </big></td>
        </tr>
        <tr>
          <td><big>SECOND_VERTEX</big></td>
          <td><big>The second vertex<br>
            </big></td>
        </tr>
        <tr>
          <td style="vertical-align: top;"><big>THIRD_VERTEX</big></td>
          <td style="vertical-align: top;"><big>The third vertex<br>
            </big></td>
        </tr>
        <tr>
          <td style="vertical-align: top;"><big>LAST_VERTEX</big></td>
          <td style="vertical-align: top;"><big>The last vertex</big></td>
        </tr>
      </tbody>
    </table>
    <big><br>
    </big>
    <h2><a id="mozTocId218099" class="mozTocH2"></a><big>
        Chapter 6. Image kind</big></h2>
    <big>
      <br>
      The image types look like the predefined constants. You can see it
      below.<br>
      <br>
    </big>
    <table style="width: 711px; height: 106px;" border="1">
      <tbody>
        <tr>
          <td><big>Image kind<br>
            </big></td>
          <td><big>Description</big></td>
        </tr>
        <tr>
          <td><big>HORIZONTAL_ANIMATED</big></td>
          <td><big>The horizontal animated background or the horizontal strip</big></td>
        </tr>
        <tr>
          <td><big>VERTICAL_ANIMATED</big></td>
          <td><big>The vertical animated background or the vertical strip</big></td>
        </tr>
      </tbody>
    </table>
    <big><br>
    </big>
    <h2><a id="mozTocId389868" class="mozTocH2"></a><big>
        Chapter 7. Background</big></h2>
    <big>
      <u>
        Level decoration</u><br>
      <br>
      A background is a big image with a few frames. Any game has a
      background. The background will be stretched to the screen resolution
      before rendering the game scene. The background transparency is always
      disabled.<br>
      <br>
      The horizontal animated backgrounds look like the horizontal photo
      ribbons. The vertical animated backgrounds look like the vertical photo
      ribbons.<br>
      <br>
      <u>
        Work with the background</u><br>
      <br>
      Just use the <i>Background</i> class to work with the background. Let's
      look at the publicly available methods.<br>
      <br>
      <i>
        Background *Background::get_handle(); -</i> Return the handle to the
      background object.<br>
      <br>
      <i>
        void Background::prepare(const Screen *screen); -</i> Prepare for
      drawing.<br>
      <br>
      <i>
        void Background::prepare(Screen &amp;screen); -</i> Prepare for drawing.<br>
      <br>
      <i>
        void Background::prepare(const unsigned int width, const unsigned int
        height); -</i> Prepare for drawing.<br>
      <i><br>
        void Background::disable_mirror(); -</i> Disable background mirroring mode.<br>
      <i><br>
        void Background::horizontal_mirror(); -</i> Set horizontal background
      mirroring mode.<br>
      <br>
      <i>
        void Background::vertical_mirror(); -</i> Set vertical background
      mirroring mode.<br>
      <br>
      <i>
        void Background::complex_mirror(); -</i> Set both horizontal and
      vertical background mirroring modes.<br>
      <br>
      <i>
        void Background::set_target(const unsigned int target); -</i> Set the
      target frame.<br>
      <i><br>
        void Background::step(); -</i> Increase the target frame. Set it to 1 if
      the target is more than the number of frames.<br>
      <i><br>
        void Background::set_settings(const BIRD2D::IMAGE_KIND kind, const
        unsigned int frames); -</i> Set the background settings.<br>
      <br>
      <i>
        void Background::load(Image *background,const BIRD2D::IMAGE_KIND kind,
        const unsigned int frames); -</i> Load a background from the buffer.<br>
      <br>
      <i>
        void Background::load(Image &amp;background,const BIRD2D::IMAGE_KIND
        kind, const unsigned int frames); -</i> Load a background from the
      buffer.<br>
      <i><br>
        void Background::load(const char *name,const BIRD2D::IMAGE_KIND kind,
        const unsigned int frames); -</i> Load a background from the target
      file.<br>
      <br>
      <i>
        void Background::draw(); -</i> Draw a background.<br>
      <i><br>
        void Background::draw(const unsigned int target); -</i> Draw the target
      frame.<br>
      <br>
      <i>
        void Background::destroy_image(); -</i> Destroy a background image.<br>
      <br>
      <i>
        void Background::destroy(); -</i> Destroy a background image and the
      texture.<br>
      <br>
      <i>
        bool Background::is_load() const; -</i> Return true if a background has
      already been loaded.<br>
      <i><br>
        bool Background::is_last_frame() const; -</i> Return true if the current
      frame is the last frame.<br>
      <br>
      <i>
        bool Background::check_frame(const unsigned int target) const; -</i>
      Return true if the target frame is valid.<br>
      <i><br>
        unsigned int Background::get_frame() const; -</i> Return the current frame.<br>
      <i><br>
        unsigned int Background::get_frames() const; -</i> Return the number of
      the frames.<br>
      <i><br>
        unsigned int Background::get_width() const; -</i> Return the width of
      the background.<br>
      <br>
      <i>
        unsigned int Background::get_height() const; -</i> Return the height of
      the background.<br>
      <br>
      <i>
        BIRD2D::IMAGE_KIND Background::get_kind() const; -</i> Get the
      background kind.<br>
      <u><br>
        A background texture</u><br>
      <br>
      The background doesn't draw if the background texture doesn't exist. It
      will automatically be created when you load an image.<br>
      <br>
      <u>
        Important notice</u><br>
      <br>
      Always call the <i>prepare</i> after the background has been loaded.<br>
    </big>
    <h2><a id="mozTocId297302" class="mozTocH2"></a><big>
        Chapter 8. Static background</big></h2>
    <big>
      <u>
        A few words about static background</u><br>
      <br>
      The static background is a simple kind of background. It contains one
      frame only.<br>
      <u><br>
        Work with the background</u><br>
      <br>
      Just use the <i>Scene</i> class to work with the static background. Let's
      look at the publicly available methods.<br>
      <i><br>
        Scene *Scene::get_handle(); -</i> Return the handle to the background object.<br>
      <i><br>
        void Scene::prepare(const Screen *screen); -</i> Prepare for drawing.<br>
      <i><br>
        void Scene::prepare(Screen &amp;screen); -</i> Prepare for drawing.<br>
      <br>
      <i>
        void Scene::prepare(const unsigned int width, const unsigned int
        height); -</i> Prepare for drawing.<br>
      <br>
      <i>
        void Scene::disable_mirror(); -</i> Disable background mirroring mode.<br>
      <i><br>
        void Scene::horizontal_mirror(); -</i> Set horizontal background
      mirroring mode.<br>
      <br>
      <i>
        void Scene::vertical_mirror(); -</i> Set vertical background mirroring mode.<br>
      <br>
      <i>
        void Scene::complex_mirror(); -</i> Set both horizontal and vertical
      background mirroring modes.<br>
      <br>
      <i>
        void Scene::load(Image *background); -</i> Load a background from the buffer.<br>
      <i><br>
        void Scene::load(Image &amp; background); -</i> Load a background from
      the buffer.<br>
      <br>
      <i>
        void Scene::load(const char *name); -</i> Load a background from the
      target
      file.<br>
      <br>
      <i>
        void Scene::draw(); -</i> Draw a background.<br>
      <i><br>
        void Scene::destroy_image(); -</i> Destroy a background image.<br>
      <br>
      <i>
        void Scene::destroy(); -</i> Destroy a background image and destroy the texture.<br>
      <br>
      <i>
        bool Scene::is_load() const; -</i> Return true if a static background
      has already been loaded.<br>
      <i><br>
        unsigned int Scene::get_width() const; -</i> Return the width of the
      background.<br>
      <i><br>
        unsigned int Scene::get_height() const; -</i> Return the height of the background.<br>
      <i><br>
      </i><u>A background texture</u><br>
      <br>
      The background doesn't draw if the background texture doesn't exist. It
      will automatically be created when you load an image.<br>
      <u><br>
        Important notice</u><br>
      <br>
      Always call the <i>prepare</i> after the background has been loaded.<br>
    </big>
    <h2><a id="mozTocId291174" class="mozTocH2"></a><big>
        Chapter 9. Parallax</big></h2>
    <big>
      <u>
        A few words about parallax</u><br>
      <br>
      The parallax background is a background with scrolling support.<br>
      <u><br>
        Speed</u><br>
      <br>
      The scrolling speed should be a positive number.<br>
      <br>
      <u>
        Work with the background</u><br>
      <br>
      Just use the <i>Parallax</i> class to work with the parallax background.
      Let's look at the publicly available methods.<br>
      <br>
      <i>
        Parallax *Parallax::get_handle(); -</i> Return the handle to the
      background object.<br>
      <br>
      <i>
        void Parallax::prepare(const Screen *screen); -</i> Prepare for drawing.<br>
      <br>
      <i>
        void Parallax::prepare(Screen &amp;screen); -</i> Prepare for drawing.<br>
      <br>
      <i>
        void Parallax::prepare(const unsigned int width, const unsigned int
        height); -</i> Prepare for drawing.<br>
      <br>
      <i>
        void Parallax::disable_mirror(); -</i> Disable background mirroring
      mode.<br>
      <br>
      <i>
        void Parallax::horizontal_mirror(); -</i> Set horizontal background
      mirroring mode.<br>
      <br>
      <i>
        void Parallax::vertical_mirror(); -</i> Set vertical background
      mirroring
      mode.<br>
      <i><br>
        void Parallax::complex_mirror(); -</i> Set both horizontal and vertical
      background mirroring modes.<br>
      <br>
      <i>
        void Parallax::load(Image *background); -</i> Load a background from the buffer.<br>
      <br>
      <i>
        void Parallax::load(Image &amp; background); -</i> Load a background
      from the buffer.<br>
      <br>
      <i>
        void Parallax::load(const char *name); -</i> Load a background from the
      target file.<br>
      <br>
      <i>void Parallax::set_horizontal_speed(const float speed);
        -</i> Set the horizontal scrolling speed.<br>
      <br>
       <i>void Parallax::set_vertical_speed(const float speed);
        -</i> Set the vertical scrolling speed.<br>
      <br>
      <i>
        void Parallax::set_speed(const float horizontal,const float vertical);
        -</i> Set the scrolling speed.<br>
      <br>
      <i>
        float Parallax::get_horizontal_speed() const; -</i> Return the
      horizontal speed.<br>
      <br>
      <i>
        float Parallax::get_vertical_speed() const; -</i> Return the vertical speed.<br>
      <i><br>
        void Parallax::draw(); -</i> Draw a background.<br>
      <i><br>
        void Parallax::destroy_image(); -</i> Destroy a background image.<br>
      <i><br>
        void Parallax::destroy(); -</i> Destroy a background image and destroy
      the texture.<br>
      <i><br>
        bool Parallax::is_load() const; -</i> Return true if a parallax
      background has already been loaded.<br>
      <br>
      <i>
        unsigned int Parallax::get_width() const; -</i> Return the width of the
      background.<br>
      <i><br>
        unsigned int Parallax::get_height() const; -</i> Return the height of
      the
      background.<br>
      <br>
      <u>
        A background texture</u><br>
      <br>
      The background doesn't draw if the background texture doesn't exist. It
      will automatically be created when you load an image.<br>
      <br>
      <u>
        Important notice</u><br>
      <br>
      Always call the prepare after the background has been loaded.<br>
    </big>
    <h2><a id="mozTocId98006" class="mozTocH2"></a><big>
        Chapter 10. Base sprite subsystem</big></h2>
    <big>
      <u>
        A small, important thing</u><br>
      <br>
      A sprite is a transparent image. It is useful for many things: enemies,
      bonuses, etc.<br>
      <br>
      <u>
        Work with the base sprite subsystem</u><br>
      <br>
      The <i>Billboard</i> class provides simple access to the base sprite
      subsystem. Don't use it directly. Let's look at the publicly available
      methods.<br>
      <br>
      <i>
        void Billboard::set_texture_coordinates(const BIRD2D::VERTEX_INDEX
        index, const float u, const float v); -</i> Set the texture coordinates.<br>
      <br>
      <i>
        void Billboard::set_transparent(const bool enabled); -</i> Enable or
      disable the transparent mode.<br>
      <br>
      <i>
        bool Billboard::get_transparent() const; -</i> Return true if the
      transparent mode is enabled.<br>
      <i><br>
        void Billboard::set_position(const unsigned int x, const unsigned int
        y); -</i> Set the sprite position.<br>
      <br>
      <i>
        void Billboard::set_start(const unsigned int x, const unsigned int y);
        -</i> Set the start position of the sprite.<br>
      <i><br>
        void Billboard::set_size(const unsigned int width, const unsigned int
        height); -</i> Change the sprite size.<br>
      <i><br>
        void Billboard::set_x(const unsigned int x); -</i> Set the x-coordinate
      of the sprite position.<br>
      <i><br>
        void Billboard::set_y(const unsigned int y); -</i> Set the y-coordinate
      of the sprite position.<br>
      <i><br>
        void Billboard::set_width(const unsigned int width); -</i> Change the
      sprite width.<br>
      <i><br>
        void Billboard::set_height(const unsigned int height); -</i> Change the
      sprite height.<br>
      <i><br>
        unsigned int Billboard::increase_x(); -</i> Increase the x-coordinate
      and return it.<br>
      <br>
      <i>
        unsigned int Billboard::decrease_x(); -</i> Decrease the x-coordinate
      and return it.<br>
      <i><br>
        unsigned int Billboard::increase_y(); -</i> Increase the y-coordinate
      and return it.<br>
      <br>
      <i>
        unsigned int Billboard::decrease_y(); -</i> Decrease the y-coordinate
      and return it.<br>
      <br>
      <i>
        unsigned int Billboard::increase_x(const unsigned int increment); -</i>
      Increase the x-coordinate with the user value and return it.<br>
      <br>
      <i>
        unsigned int Billboard::decrease_x(const unsigned int decrement); -</i>
      Decrease the x-coordinate with the user value and return it.<br>
      <br>
      <i>
        unsigned int Billboard::increase_y(const unsigned int increment); -</i>
      Increase the y-coordinate with the user value and return it.<br>
      <br>
      <i>
        unsigned int Billboard::decrease_y(const unsigned int decrement); -</i>
      Decrease the y-coordinate with the user value and return it.<br>
      <br>
      <i>
        unsigned int Billboard::get_start_x() const; -</i> Return the
      x-coordinate of the start position.<br>
      <br>
      <i>
        unsigned int Billboard::get_start_y() const; -</i> Return the
      y-coordinate of the start position.<br>
      <br>
      <i>
        unsigned int Billboard::get_x() const; -</i> Return the x-coordinate of
      the sprite position.<br>
      <br>
      <i>
        unsigned int Billboard::get_y() const; -</i> Return the y-coordinate of
      the sprite position.<br>
      <br>
      <i>
        unsigned int Billboard::get_width() const; -</i> Return the width of the sprite.<br>
      <br>
      <i>
        unsigned int Billboard::get_height() const; -</i> Return the height of
      the sprite.<br>
      <br>
      <i>
        bool Billboard::is_load() const; -</i> Return true if the sprite has
      already been loaded.<br>
      <br>
      <i>
        BIRD2D::BOX Billboard::get_box() const; -</i> Return the
      collision-related information.<br>
      <br>
      <i>
        void Billboard::disable_mirror(); -</i> Disable sprite mirroring mode.<br>
      <i><br>
        void Billboard::horizontal_mirror(); -</i> Set horizontal sprite
      mirroring mode.<br>
      <br>
      <i>
        void Billboard::vertical_mirror(); -</i> Set vertical sprite mirroring mode.<br>
      <br>
      <i>
        void Billboard::complex_mirror(); -</i> Set both horizontal and vertical
      sprite mirroring modes.<br>
      <br>
      <i>
        void Billboard::go_start(); -</i> Set the sprite position to the start
      position.<br>
      <br>
      <i>
        void Billboard::go_start_x(); -</i> Set the x-coordinate of the sprite
      position to the x-coordinate of the start position.<br>
      <br>
      <i>
        void Billboard::go_start_y(); -</i> Set the y-coordinate of the sprite
      position to the y-coordinate of the start position.<br>
      <br>
      <i>
        void Billboard::draw(); -</i> Draw a sprite.<br>
      <br>
      <i>
        void Billboard::draw(const unsigned int x, const unsigned int y); -</i>
      Set the sprite position and draw it.<br>
      <i><br>
        void Billboard::draw(const bool transparency); -</i> Set the transparent
      mode and draw a sprite.<br>
      <br>
      <i>
        void Billboard::draw(const bool transparency, const unsigned int x,
        const unsigned int y); -</i> Set the transparent mode and draw a sprite
      at the target position.<br>
    </big>
    <h2><a id="mozTocId920538" class="mozTocH2"></a><big>
        Chapter 11. Ordinary sprites</big></h2>
    <big>
      <u>
        Sprite types</u><br>
      <br>
      There are two kinds of ordinary sprites: the horizontal strips and the
      vertical strips. It is a small image with a few frames.<br>
      The horizontal strip looks like the horizontal photo ribbon. The
      vertical strip looks like the vertical photo ribbon.<br>
      <u><br>
        Work with the sprites</u><br>
      <br>
      Just use the <i>Sprite</i> class to work with a sprite. It is derived
      from three classes: <i>Billboard</i>, <i>Animation</i>, and <i>Picture</i>.
      Let's look at the publicly available methods.<br>
      <br>
      <i>
        void Sprite::set_settings(const BIRD2D::IMAGE_KIND kind, const unsigned
        int frames); -</i> Set the sprite settings.<br>
      <br>
      <i>
        void Sprite::load(Image *buffer,const BIRD2D::IMAGE_KIND kind, const
        unsigned int frames); -</i> Load a sprite from the buffer.<br>
      <i><br>
        void Sprite::load(Image &amp;buffer,const BIRD2D::IMAGE_KIND kind,
        const unsigned int frames); -</i> Load a sprite from the buffer.<br>
      <br>
      <i>
        void Sprite::load(const char *name,const BIRD2D::IMAGE_KIND kind, const
        unsigned int frames); -</i> Load a sprite from the target file.<br>
      <br>
      <i>
        void Sprite::set_target(const unsigned int target); -</i> Set the target frame.<br>
      <br>
      <i>
        void Sprite::step(); -</i> Increase the target frame. Set it to 1 if the
      target is more than the number of frames.<br>
      <br>
      <i>
        BIRD2D::IMAGE_KIND Sprite::get_kind() const; -</i> Get the sprite kind.<br>
      <i><br>
        Sprite *Sprite::get_handle(); -</i> Return the handle to the sprite object.<br>
      <br>
      <i>
        void Sprite::clone(Sprite *target); -</i> Create a copy of the sprite if
      the storage of the target sprite is not empty.<br>
      <br>
      <i>
        void Sprite::clone(Sprite &amp;target); -</i> Create a copy of the
      sprite
      if the storage of the target sprite is not empty.<br>
      <i><br>
        void Sprite::destroy(); -</i> Destroy a sprite image and destroy the
      texture.<br>
      <br>
      <u>
        A sprite texture</u><br>
      <br>
      A sprite doesn't draw if the sprite texture doesn't exist. It will
      automatically be created when you load or clone a sprite.<br>
    </big>
    <h2><a id="mozTocId895327" class="mozTocH2"></a><big>
        Chapter 12. Static sprites</big></h2>
    <big>
      <u>
        A few words about static sprites</u><br>
      <br>
      The static sprite is a simple kind of sprite. It contains one frame only.<br>
      <br>
      <u>
        Work with the static sprites</u><br>
      <br>
      Just use the <i>Cartoon</i> class to work with a static sprite. It is
      derived from two classes: <i>Billboard</i> and <i>Picture</i>. Let's look at the
      publicly available methods.<br>
      <br>
      <i>
        void Cartoon::load(Image *buffer); -</i> Load a sprite from the buffer.<br>
      <br>
      <i>
        void Cartoon::load(Image &amp;buffer); -</i> Load a sprite from the buffer.<br>
      <br>
      <i>
        void Cartoon::load(const char *name); -</i> Load a sprite from the
      target file.<br>
      <br>
      <i>
        Cartoon *Cartoon::get_handle(); -</i> Return the handle to the sprite object.<br>
      <br>
      <i>
        void Cartoon::clone(Cartoon *target); -</i> Create a copy of the sprite
      if the storage of the target sprite is not empty.<br>
      <br>
      <i>
        void Cartoon::clone(Cartoon &amp;target); -</i> Create a copy of the
      sprite if the storage of the target sprite is not empty.<br>
      <br>
      <i>
        void Cartoon::destroy(); -</i> Destroy a sprite image and the texture.<br>
      <br>
      <u>
        A sprite texture<br>
      </u>
      <br>
      A sprite doesn't draw if the sprite texture doesn't exist. It will
      automatically be created when you load or clone a sprite.<br>
    </big>
    <h2><a id="mozTocId132557" class="mozTocH2"></a><big>
        Chapter 13. Sprite sheet</big></h2>
    <big>
      <u>
        Some words about a sprite sheet</u><br>
      <br>
      A sprite sheet is a special kind of animated sprite. Each frame has a
      fixed size. The sheet is a matrix of frames. Look at this picture to
      understand it.<br>
      <br>
      <img alt="" src="sheet.png" height="249" width="380"><br>
      <br>
      <u>
        Rows and columns</u><br>
      <br>
      The first row index is 1. The first column index is 1.<br>
      <br>
      <u>
        Work with the sheet</u><br>
      <br>
      The <i>Sheet</i> class provides access to the sprite sheet subsystem. It
      is derived from three classes: <i>Billboard</i>, <i>Picture</i>, and <i>Animation</i>.
      Let's look at the publicly available methods.<br>
      <i><br>
        bool Sheet::check_row(const unsigned int target) const; -</i> Return
      true if the target row is valid.<br>
      <i><br>
        bool Sheet::check_column(const unsigned int target) const; -</i> Return
      true if the target column is valid.<br>
      <i><br>
        unsigned int Sheet::get_row(const unsigned int target) const; -</i>
      Return the row of the target frame.<br>
      <i><br>
        unsigned int Sheet::get_column(const unsigned int target) const; -</i>
      Return column of the target frame.<br>
      <br>
      <i>
        unsigned int Sheet::calculate(const unsigned int row, const unsigned
        int column) const; -</i> Calculate the frame by row and column.<br>
      <br>
      <i>
        unsigned int Sheet::get_rows() const; -</i> Return the number of rows.<br>
      <i><br>
        unsigned int Sheet::get_columns() const; -</i> Return the number of columns.<br>
      <br>
      <i>
        void Sheet::destroy(); -</i> Destroy a sprite sheet image and the texture.<br>
      <br>
      <i>
        void Sheet::select(const unsigned int row,const unsigned int column); -</i>
      Select the target frame by row and column.<br>
      <i><br>
        void Sheet::set_target(const unsigned int target); -</i> Set the target
      frame.<br>
      <br>
      <i>
        void Sheet::step(); -</i> Increase the target frame. Set it to 1 if the
      target is more than the number of frames.<br>
      <i><br>
        void Sheet::load(Image *sheet, const unsigned int row_amount, const
        unsigned int column_amount); -</i> Load a sprite sheet from the buffer.<br>
      <i><br>
        void Sheet::load(Image &amp;sheet, const unsigned int row_amount, const
        unsigned int column_amount); -</i> Load a sprite sheet from the buffer.<br>
      <br>
      <i>
        void Sheet::load(const char *name, const unsigned int row_amount, const
        unsigned int column_amount); -</i> Load a sprite sheet from a target
      file.<br>
      <i><br>
        Sheet *Sheet::get_handle(); -</i> Return the handle to the sprite sheet.<i><br>
        <br>
        void Sheet::clone(Sheet *target); -</i> Create a copy of the sprite
      sheet
      if the storage of the target sprite sheet is not empty.<br>
      <i><br>
        void Sheet::clone(Sheet &amp;target); -</i> Create a copy of the sprite
      sheet if the storage of the target sprite sheet is not empty.<br>
      <br>
      <u>
        A sprite sheet texture</u><br>
      <br>
      A sprite sheet doesn't draw if the sprite sheet texture doesn't exist.
      It will automatically be created when you load a sheet.<br>
    </big>
    <h2><a id="mozTocId910339" class="mozTocH2"></a><big>
        Chapter 14. Text</big></h2>
    <big>
      <u>
        How do I draw a text?</u><br>
      <br>
      Just use the text subsystem to draw a text. This subsystem needs a font
      for text drawing. You must load a font before starting to draw the
      text. The font is just a sprite sheet with 16 rows and 16 columns.<br>
      <br>
      <u>
        Valid characters</u><br>
      <br>
      Only 8-bit characters are supported.<br>
      <br>
      <u>
        Text orientation</u><br>
      <br>
      The text orientation looks like the predefined constants. You can see
      it below.<br>
      <br>
    </big>
    <table style="width: 437px; height: 85px;" border="1">
      <tbody>
        <tr>
          <td><big>Text orientation<br>
            </big></td>
          <td><big>Description</big></td>
        </tr>
        <tr>
          <td><big>HORIZONTAL_TEXT</big></td>
          <td><big>The horizontally oriented text<br>
            </big></td>
        </tr>
        <tr>
          <td><big>VERTICAL_TEXT</big></td>
          <td><big>The vertically oriented text</big></td>
        </tr>
      </tbody>
    </table>
    <big><br>
      <u>
        Work with the text</u><br>
      <br>
      The <i>Text</i> class provides a simple interface to the text subsystem.
      Let's look at the publicly available methods.<br>
      <i><br>
        Text *Text::get_handle(); -</i> Return the handle to the text drawing
      subsystem.<br>
      <br>
      <i>
        BIRD2D::TEXT_KIND Text::get_orientation() const; -</i> Get the current
      text orientation.<br>
      <br>
      <i>
        void Text::set_orientation(const BIRD2D::TEXT_KIND target); -</i> Set
      the current text orientation.<br>
      <br>
      <i>
        bool Text::is_font_load() const; -</i> Return true if the font has
      already been loaded.<br>
      <br>
      <i>
        unsigned int Text::get_font_width() const; -</i> Get the current font
      width in pixels.<br>
      <br>
      <i>
        unsigned int Text::get_font_height() const; -</i> Get the current font
      height in pixels.<br>
      <br>
      <i>
        unsigned int Text::get_x() const; -</i> Get the x-coordinate of the text
      output position.<br>
      <br>
      <i>
        unsigned int Text::get_y() const; -</i> Get the y-coordinate of the text
      output position.<br>
      <i><br>
        void Text::set_position(const unsigned int x, const unsigned int y); -</i>
      Set the output position.<br>
      <br>
      <i>
        void Text::set_size(const unsigned int width, const unsigned int
        height); -</i> Change the font size.<br>
      <br>
      <i>
        void Text::set_width(const unsigned int width); -</i> Set the font width.<br>
      <br>
      <i>
        void Text::set_height(const unsigned int height); -</i> Set the font height.<br>
      <i><br>
        void Text::set_settings(const unsigned int width, const unsigned int
        height, const BIRD2D::TEXT_KIND kind); -</i> Set the text output
      settings.<br>
      <br>
      <i>
        void Text::load_font(Image *font); -</i> Load a font from the buffer.<br>
      <i><br>
        void Text::load_font(Image &amp;font); -</i> Load a font from the buffer.<br>
      <br>
      <i>
        void Text::load_font(const char *name); -</i> Load a font from the
      target file.<br>
      <br>
      <i>
        void Text::print(const char target); -</i> Draw a single character at
      the current position.<br>
      <br>
      <i>
        void Text::print(const unsigned int x, const unsigned int y, const char
        target); -</i> Draw a single character at the specific position.<br>
      <br>
      <i>
        size_t Text::print(const char *target); -</i> Draw a text at the current
      position and return the text length.<br>
      <br>
      <i>
        size_t Text::print(const unsigned int x, const unsigned int y, const
        char *target); -</i> Draw a text at the specific position and return the
      text length.<br>
      <i><br>
        void Text::disable_mirror(); -</i> Disable text mirroring mode.<br>
      <i><br>
        void Text::horizontal_mirror(); -</i> Set horizontal text mirroring
      mode.<br>
      <i><br>
        void Text::vertical_mirror(); -</i> Set vertical text mirroring mode.<br>
      <i><br>
        void Text::complex_mirror(); -</i> Set both horizontal and vertical text
      mirroring modes.<br>
      <i><br>
        void Text::destroy_image(); -</i> Destroy a font image.<br>
      <i><br>
        void Text::destroy_font(); -</i> Destroy a font image and the texture.<br>
    </big>
    <h2><a id="mozTocId122295" class="mozTocH2"></a><big>
        Chapter 15. Loading images</big></h2>
    <big>
      <u>
        Load an image from a file</u><br>
      <br>
      Use the image loader to load an image from a file. The <i>Image</i> class
      provides simple access to the image loader. It is a simple class with a
      few methods.<br>
      <br>
      <i>
        unsigned char *Image::load(const char *name); -</i> Load a Truevision
      TGA image and return the handle to the image buffer.<br>
      <i><br>
        unsigned char *Image::get_data(); -</i> Return the handle to the image buffer.<br>
      <br>
      <i>
        unsigned int Image::get_width() const; -</i> Return the width of the
      current image.<br>
      <i><br>
        unsigned int Image::get_height() const; -</i> Return the height of the
      current image.<br>
      <br>
      <i>
        size_t Image::get_length() const; -</i> Return length of the image
      buffer
      in bytes.<br>
      <br>
      <i>
        Image *Image::get_handle(); -</i> Return the handle to the image loader.<br>
      <i><br>
        void Image::destroy_image(); -</i> Destroy the current image and free
      the image buffer.<br>
      <u><br>
        Important remark</u><br>
      <br>
      A new image will replace the current image if the current image already
      exists. An incorrect image will be ignored and won't load.<br>
      The source image will be converted to <a href="https://en.wikipedia.org/wiki/RGBA">RGBA</a>
      format. Pixels equal to the
      top-left pixel will be marked as transparent.<br>
      <u><br>
        Supported format</u><br>
      <br>
      All loading images must have the correct specification. You can load an
      image from a 24-bit <a href="https://en.wikipedia.org/wiki/Truevision_TGA">Truevision
        TGA</a> picture.<br>
      <u><br>
        Recommend software</u><br>
      <br>
      You can use a wide range of graphics software to convert your images to
      the correct format. I recommend using <a href="https://www.gimp.org">GIMP</a>
      to do it. It is a powerful
      image editor.<br>
    </big>
    <h2><a id="mozTocId845590" class="mozTocH2"></a><big>
        Chapter 16. Camera</big></h2>
    <big><u>
        A few words about the camera</u><br>
      <br>
      The 2D camera defines the size of the visible area. It will be
      stretched to the screen resolution before rendering the game scene.<br>
      <u><br>
        Work with the camera</u><br>
      <br>
      The <i>Camera</i> class provides simple access to the camera subsystem.
      Let's look at the publicly available methods.<br>
      <br>
      <i>
        Camera *Camera::get_handle(); -</i> Return the handle to the camera subsystem.<br>
      <br>
      <i>
        unsigned int Camera::increase_x(); -</i> Increase the x-coordinate of
      the camera offset and return it.<br>
      <i><br>
        unsigned int Camera::decrease_x(); -</i> Decrease the x-coordinate of
      the camera offset and return it.<br>
      <i><br>
        unsigned int Camera::increase_y(); -</i> Increase the y-coordinate of
      the camera offset and return it.<br>
      <i><br>
        unsigned int Camera::decrease_y(); -</i> Decrease the y-coordinate of
      the camera offset and return it.<br>
      <br>
      <i>
        unsigned int Camera::increase_x(const unsigned int increment); -</i>
      Increase the x-coordinate of the camera offset with the user value and
      return it.<br>
      <i><br>
        unsigned int Camera::decrease_x(const unsigned int decrement); -</i>
      Decrease the x-coordinate of the camera offset with the user value and
      return it.<br>
      <i><br>
        unsigned int Camera::increase_y(const unsigned int increment); -</i>
      Increase the y-coordinate of the camera offset with the user value and
      return it.<br>
      <i><br>
        unsigned int Camera::decrease_y(const unsigned int decrement); -</i>
      Decrease the y-coordinate of the camera offset with the user value and
      return it.<br>
      <br>
      <i>
        unsigned int Camera::get_x() const; -</i> Return the x-coordinate of the
      camera offset.<br>
      <br>
      <i>
        unsigned int Camera::get_y() const; -</i> Return the y-coordinate of the
      camera offset.<br>
      <br>
      <i>
        unsigned int Camera::get_screen_width() const; -</i> Return the screen
      width in pixels.<br>
      <i><br>
        unsigned int Camera::get_screen_height() const; -</i> Return the screen
      height in pixels.<br>
      <br>
      <i>
        unsigned int Camera::get_viewport_width() const; -</i> Return the
      viewport width in pixels.<br>
      <i><br>
        unsigned int Camera::get_viewport_height() const; -</i> Return the
      viewport height in pixels.<br>
      <br>
      <i>
        unsigned int Camera::get_highest_x() const; -</i> Return the highest
      allowable x-coordinate of the current visible area.<br>
      <i><br>
        unsigned int Camera::get_highest_y() const; -</i> Return the highest
      allowable y-coordinate of the current visible area.<br>
      <i><br>
        unsigned int Camera::get_highest_x_offset() const; -</i> Return the
      highest allowable x-offset of the camera.<br>
      <i><br>
        unsigned int Camera::get_highest_y_offset() const; -</i> Return the
      highest allowable y-offset of the camera.<br>
      <i><br>
        unsigned int Camera::get_world_x(const unsigned screen_int x) const; -</i>
      Convert the screen x-coordinate to the world x-coordinate.<br>
      <i><br>
        unsigned int Camera::get_world_y(const unsigned screen_int y) const; -</i>
      Convert the screen y-coordinate to the world y-coordinate.<br>
      <br>
      <i>
        unsigned int Camera::set_x(const unsigned int x); -</i> Set the
      x-coordinate of the camera offset and return it.<br>
      <br>
      <i>
        unsigned int Camera::set_y(const unsigned int y); -</i> Set the
      y-coordinate of the camera offset and return it.<br>
      <br>
      <i>
        void Camera::initialize(const unsigned int width, const unsigned int
        height); -</i> Initialize the subsystem and set the screen size.<br>
      <br>
      <i>
        void Camera::initialize(Screen *screen); -</i> Initialize the subsystem
      and set the screen size.<br>
      <br>
      <i>
        void Camera::initialize(Screen &amp;screen); -</i> Initialize the
      subsystem and set the screen size.<br>
      <br>
      <i>
        void Camera::set_viewport(const unsigned int width, const unsigned int
        height); -</i> Set the viewport settings.<br>
      <br>
      <i>
        void Camera::set_offset(const unsigned int x, const unsigned int y); -</i>
      Set the camera offset.<br>
      <br>
      <i>
        bool Camera::check_horizontal_border(const BIRD2D::BOX target) const; -</i>
      Return true if a game object has collided with the horizontal visible
      area border.<br>
      <br>
      <i>
        bool Camera::check_vertical_border(const BIRD2D::BOX target) const; -</i>
      Return true if a game object has collided with the vertical visible area
      border.<br>
      <br>
      <i>
        void Camera::update(); -</i> Update the camera.<br>
      <br>
      <i>
        void Camera::reset(); -</i> Reset the camera settings.<br>
      <br>
      <u>
        Important remark</u><br>
      <br>
      Always set the viewport size after initializing the camera. Always
      update the camera before drawing.<br>
    </big>
    <h1><a id="mozTocId516694" class="mozTocH1"></a><big>
        Part 4. Transformation</big></h1>
    <h2><a id="mozTocId771051" class="mozTocH2"></a><big>
        Chapter 1. The sub-namespace</big></h2>
    <big>
      All classes in this section are declared in the <i>Transformation</i>
      sub-namespace.<br>
    </big>
    <h2><a id="mozTocId197525" class="mozTocH2"></a><big>
        Chapter 2. Cartesian coordinates and screen coordinates</big></h2>
    <big>
      <u>
        Cartesian coordinates</u><br>
      <br>
      The Cartesian coordinates start at the center of the screen. Look at
      this picture to understand it.<br>
      <br>
      <img alt="" src="cartesian_system.png" height="111" width="107"><br>
      <br>
      <u>
        Coordinates conversion</u><br>
      <br>
      You can convert the Cartesian coordinates to the screen coordinates.
      You can also convert the screen coordinates to the Cartesian
      coordinates.<br>
      <br>
      Just use the <i>Coordinates</i> class to do it. Let's look at the
      publicly available methods.<br>
      <i><br>
        Coordinates *Coordinates::get_handle(); -</i> Return the handle to the
      coordinates conversion subsystem.<br>
      <i><br>
        void Coordinates::initialize(const int viewport_width, const int
        viewport_height); -</i> Initialize the subsystem.<br>
      <br>
      <i>
        int Coordinates::get_viewport_width() const; -</i> Return the viewport
      width in pixels.<br>
      <br>
      <i>
        int Coordinates::get_viewport_height() const; -</i> Return the viewport
      height in pixels.<br>
      <i><br>
        int Coordinates::get_lowest_cartesian_x() const; -</i> Return the lowest
      allowable Cartesian x-coordinate.<br>
      <i><br>
        int Coordinates::get_highest_cartesian_x() const; -</i> Return the
      highest allowable Cartesian x-coordinate.<br>
      <br>
      <i>
        int Coordinates::get_lowest_cartesian_y() const; -</i> Return the lowest
      allowable Cartesian y-coordinate.<br>
      <br>
      <i>
        int Coordinates::get_highest_cartesian_y() const; -</i> Return the
      highest allowable Cartesian y-coordinate.<br>
      <i><br>
        bool Coordinates::check_cartesian_x(const int x) const; -</i> Return
      true if the Cartesian x-coordinate is valid.<br>
      <i><br>
        bool Coordinates::check_cartesian_y(const int y) const; -</i> Return
      true if the Cartesian y-coordinate is valid.<br>
      <br>
      <i>
        int Coordinates::get_screen_x(const int x) const; -</i> Convert the
      Cartesian x-coordinate to the screen x-coordinate.<br>
      <br>
      <i>
        int Coordinates::get_screen_y(const int y) const; -</i> Convert the
      Cartesian y-coordinate to the screen y-coordinate.<br>
      <br>
      <i>
        int Coordinates::get_cartesian_x(const int x) const; -</i> Convert the
      screen x-coordinate to the Cartesian x-coordinate.<br>
      <br>
      <i>
        int Coordinates::get_cartesian_y(const int y) const; -</i> Convert the
      screen y-coordinate to the Cartesian y-coordinate.<br>
    </big>
    <h2><a id="mozTocId176902" class="mozTocH2"></a><big>
        Chapter 3. Cartesian coordinates and isometric coordinates</big></h2>
    <big>
      <u>
        A few words about isometric games</u><br>
      <br>
      <a href="https://en.wikipedia.org/wiki/Isometric_projection">Isometry</a>
      is a very popular way for pseudo-3D games. Many old-school
      games are isometric games.<br>
      <br>
      <u>
        Coordinates conversion</u><br>
      <br>
      You can convert the Cartesian coordinates to the isometric coordinates.
      You can also convert the isometric coordinates to the Cartesian
      coordinates. Just use the <i>Isometric</i> class to do it. Let's look at
      the publicly available methods.<br>
      <i><br>
        static int Isometric::get_isometric_x(const int x, const int y); -</i>
      Convert the x-coordinate from the Cartesian system to the isometric
      system.<br>
      <i><br>
        static int Isometric::get_isometric_y(const int x, const int y); -</i>
      Convert the y-coordinate from the Cartesian system to the isometric
      system.<br>
      <i><br>
        static int Isometric::get_cartesian_x(const int x, const int y); -</i>
      Convert the x-coordinate from the isometric system to the Cartesian
      system.<br>
      <i><br>
        static int Isometric::get_cartesian_y(const int x, const int y); -</i>
      Convert the y-coordinate from the isometric system to the Cartesian
      system.<br>
    </big>
    <h2><a id="mozTocId684253" class="mozTocH2"></a><big>
        Chapter 4. Isometric level</big></h2>
    <big>
      The isometric level subsystem is intended to help you create an
      isometric level. Just use the <i>Level</i> class to do it. Let's look at
      the publicly available methods.<br>
      <br>
      <i>
        Level *Level::get_handle(); -</i> Return the handle to the isometric
      level subsystem.<br>
      <i><br>
        void Level::initialize(const int tile_width, const int tile_height); -</i>
      Initialize the subsystem.<br>
      <br>
      <i>
        void Level::set_offset(const int x_offset, const int y_offset); -</i>
      Set the coordinates offset.<br>
      <br>
      <i>
        int Level::get_x_offset() const; -</i> Return the x-offset.<br>
      <br>
      <i>
        int Level::get_y_offset() const; -</i> Return the y-offset.<br>
      <br>
      <i>
        int Level::get_x(const int row, const int column) const; -</i> Return
      the target x-coordinate.<br>
      <i><br>
        int Level::get_y(const int row, const int column) const; -</i> Return
      the target y-coordinate.<br>
    </big>
    <h1><a id="mozTocId411027" class="mozTocH1"></a><big>
        Part 5. Common things</big></h1>
    <h2><a id="mozTocId370034" class="mozTocH2"></a><big>
        Chapter 1. The sub-namespace</big></h2>
    <big>
      All classes in this section are declared in the <i>Common</i> sub-namespace.<br>
    </big>
    <h2><a id="mozTocId50801" class="mozTocH2"></a><big>
        Chapter 2. Abnormal program termination</big></h2>
    <big>
      You can use the <i>Halt</i> function to terminate a program. This
      function is declared in the BIRD2D namespace.<br>
      <br>
      <i>
        void BIRD2D::Halt(const char *message); -</i> Terminate the program.
      Write an error message to the log file if logging is enabled.<br>
    </big>
    <h2><a id="mozTocId287426" class="mozTocH2"></a><big>
        Chapter 3. Timer</big></h2>
    <big>
      A timer is a very useful thing. Just use the <i>Timer</i> class to work
      with the timer. Let's look at the publicly available methods.<br>
      <br>
      <i>
        Timer *Timer::get_handle(); -</i> Return the handle to the timer.<br>
      <br>
      <i>
        void Timer::set_timer(const double seconds); -</i> Set the timer
      interval and initialize the start point.<br>
      <br>
      <i>
        double Timer::get_interval() const; -</i> Return the current timer interval.<br>
      <i><br>
        bool Timer::check_timer(); -</i> Return true and reinitialize the start
      point if the interval between the stop and start points is larger than or
      equal to a specific number of seconds.<br>
    </big>
    <h2><a id="mozTocId340292" class="mozTocH2"></a><big>
        Chapter 4. Collision</big></h2>
    <big>
      <u>
        An important thing for any game</u><br>
      <br>
      What is an important thing for a video game? A collision.<br>
      <br>
      <u>
        Collision detail</u><br>
      <br>
      The detector uses the bounding box collision method to detect a
      collision. The collision-related information is stored in a custom data type.<br>
      <br>
      <i>
        typedef struct<br>
        {<br>
        unsigned int x;<br>
        unsigned int y;<br>
        unsigned int width;<br>
        unsigned int height;<br>
        } BOX;</i><br>
      <u><br>
        Work with a collision detector</u><br>
      <br>
      The <i>Collision</i> class provides easy access to collision detectors.
      It is a simple class with a few methods. Let's look at the publicly available methods.<br>
      <br>
      <i>
        Collision *Collision::get_handle(); -</i> Return the handle to the
      collision detector.<br>
      <br>
      <i>
        void Collision::set_target(const BIRD2D::BOX first_target, const
        BIRD2D::BOX second_target); -</i> Set the targets for the collision detector.<br>
      <br>
      <i>
        bool Collision::check_collision() const; -</i> Return true if the
      collision between two objects is accepted.<br>
      <br>
      <i>
        bool Collision::check_collision(const BIRD2D::BOX first_target, const
        BIRD2D::BOX second_target); -</i> Set the targets and check collisions
      between them.<br>
    </big>
    <h2><a id="mozTocId237921" class="mozTocH2"></a><big>
        Chapter 5. Tile map</big></h2>
    <big>
      <u>
        A few words about tile maps</u><br>
      <br>
      The tile map is a tile matrix. A tile is a small, non-transparent
      sprite. A tile map is a very useful thing for the background.<br>
      <u><br>
        Rows and columns</u><br>
      <br>
      The first row index is 0. The first column index is 0.<br>
      <br>
      <u>
        Work with the tile map</u><br>
      <br>
      The <i>Tilemap</i> class provides easy access to the tile map. It is a
      simple class with few methods. Let's look at the publicly available methods.<br>
      <br>
      <i>
        Tilemap *Tilemap::get_handle(); -</i> Return the handle to the tile-map subsystem.<br>
      <br>
      <i>
        void Tilemap::initialize(const unsigned int tile_width, const unsigned
        int tile_height); -</i> Initialize the subsystem.<br>
      <br>
      <i>
        unsigned int Tilemap::get_tile_width() const; -</i> Return the tile
      width in pixels.<br>
      <i><br>
        unsigned int Tilemap::get_tile_height() const; -</i> Return the tile
      height in pixels.<br>
      <i><br>
        unsigned int Tilemap::get_x(const unsigned int row) const; -</i> Get the
      x-coordinate from the target row.<br>
      <i><br>
        unsigned int Tilemap::get_y(const unsigned int column) const; -</i> Get
      the y-coordinate from the target column.<br>
      <br>
      <i>
        unsigned int Tilemap::get_row(const unsigned int x) const; -</i> Get the
      row from the x-coordinate.<br>
      <i><br>
        unsigned int Tilemap::get_column(const unsigned int y) const; -</i> Get
      the column from the y-coordinate.<br>
      <i><br>
        unsigned int Tilemap::get_row_amount(const unsigned int viewport_width)
        const; -</i> Get the maximum number of the visible rows.<br>
      <br>
      <i>
        unsigned int Tilemap::get_column_amount(const unsigned int
        viewport_width) const; -</i> Get the maximum number of the visible
      columns.<br>
      <br>
      <i>
        unsigned int Tilemap::get_tile_amount(const unsigned int
        viewport_width, const unsigned int viewport_height) const; -</i> Get the
      maximum number of the visible tiles.<br>
      <br>
      <i>
        bool Tilemap::check_row(const unsigned int row,const unsigned int
        viewport_width) const; -</i> Return true if the row is valid.<br>
      <br>
      <i>
        bool Tilemap::check_column(const unsigned int column,const unsigned int
        viewport_height) const; -</i> Return true if the column is valid.<br>
      <br>
      <i>
        BIRD2D::BOX Tilemap::get_box(const unsigned int row,const unsigned int
        column) const; -</i> Return the collision-related information.<br>
    </big>
    <h1><a id="mozTocId147043" class="mozTocH1"></a><big>
        Part 6. Other important things</big></h1>
    <h2><a id="mozTocId53728" class="mozTocH2"></a><big>
        Chapter 1. The sub-namespace</big></h2>
    <big>
      All classes in this section are declared in the <i>Misc</i>
      sub-namespace.<br>
    </big>
    <h2><a id="mozTocId749487" class="mozTocH2"></a><big>
        Chapter 2. Memory</big></h2>
    <big>
      RAM is an important resource. Just use the <i>Memory</i> class to get the
      total memory size and free memory size. Let's look at the publicly
      available methods.<br>
      <br>
      <i>
        unsigned long long int Memory::get_total_physical(); -</i> Return the
      total physical memory size in bytes.<br>
      <br>
      <i>
        unsigned long long int Memory::get_free_physical(); -</i> Return the
      free physical memory size in bytes.<br>
      <br>
      <i>
        unsigned long long int Memory::get_total_virtual(); -</i> Return the
      total virtual memory size in bytes.<br>
      <br>
      <i>
        unsigned long long int Memory::get_free_virtual(); -</i> Return the free
      virtual memory size in bytes.<br>
      <br>
      <i>
        unsigned long long int Memory::get_physical_usge(); -</i> Return the
      physical memory usage in bytes.<br>
      <br>
      <i>
        unsigned long long int Memory::get_virtual_usge(); -</i> Return the
      virtual memory usage in bytes.<br>
    </big>
    <h2><a id="mozTocId407036" class="mozTocH2"></a><big>
        Chapter 3. Audio</big></h2>
    <big>
      <u>
        A few words about the audio subsystem</u><br>
      <br>
      This subsystem is intended for playing music and sounds.<br>
      <br>
      <u>
        Working with audio</u><br>
      <br>
      Just use the <i>Audio</i> class to work with audio. Let's look at the
      publicly available methods.<br>
      <br>
      <i>
        void Audio::initialize(); -</i> Initialize the subsystem.<br>
      <br>
      <i>
        void Audio::initialize(const char *target); -</i> Initialize the
      subsystem and load a sound file.<br>
      <br>
      <i>
        void Audio::load(const char *target); -</i> Load a sound file.<br>
      <br>
      <i>
        void Audio::play(); -</i> Play a sound.<br>
      <br>
      <i>
        void Audio::play_loop(); -</i> Checking the playback status and
      restarting playback if needed.<br>
      <br>
      <i>
        void Audio::play(const bool loop); -</i> Play a sound. You can set loop
      mode if you want.<br>
      <i><br>
        void Audio::stop(); -</i> Stop playing the content of the target file.<br>
      <i><br>
        bool Audio::check_playing(); -</i> Return true if the sound resource is playing.<br>
    </big>
    <h1><a id="mozTocId15273" class="mozTocH1"></a><big>
        Part 7. Misc</big></h1>
    <h2><a id="mozTocId631611" class="mozTocH2"></a><big>
        Chapter 1. File system</big></h2>
    <big>
      This module is implemented as two simple functions. All these functions
      are declared in the <i>Filesystem</i> sub-namespace.<br>
      <br>
      <i>
        file_exist</i> check the target file to see if one exists.<br>
      <br>
      <i>
        delete_file</i> delete the target file.<br>
      <br>
      All functions take the target file name as an argument and return false
      if the operation failed.<br>
    </big>
    <h2><a id="mozTocId920039" class="mozTocH2"></a><big>
        Chapter 2. Tools</big></h2>
    <big>
      This module is implemented as a few functions. All these functions are
      declared in the <i>Tools</i> sub-namespace.<br>
      <br>
      <i>
        void quit(); -</i> Exit from your program and return the user to the
      operating system.<br>
      <br>
      <i>
        bool enable_logging(const char *name); -</i> Enable redirecting error
      messages to a log file and return false if the operation failed.<br>
      <br>
      <i>
        void randomize(); -</i> Initialize the random number generator.<br>
      <i><br>
        unsigned int get_random(const unsigned int number); -</i> Return a
      random value between zero and the number.<br>
      <br>
      <i>
        unsigned int get_texture_size(); -</i> Return the maximum width or
      height of the texture.<br>
      <br>
      <i>
        BIRD2D::BOX generate_box(const unsigned int x,const unsigned int
        y,const unsigned int width,const unsigned int height); -</i> Generate
      the collision-related information.<br>
    </big>
    <h2><a id="mozTocId258567" class="mozTocH2"></a><big>
        Chapter 3. Resource Manager</big></h2>
    <big>
      A resource is an instance of a user-defined class or structure. The
      resource manager is implemented as a few template functions. All these
      functions are declared in the <i>Resource</i> sub-namespace.<br>
      <br>
      <i>
        create</i> creates a resources. The first form of this function creates
      a single resource. It takes a handle to a resource handle as an argument.
      The second form creates an array of resources. It takes a handle to a
      resource handle and a resource amount.<br>
      <br>
      <i>
        destroy</i> delete a resource if it already exists. This function takes
      a resource handle as an argument.<br>
      <br>
      destroy_array delete the resource array if it already exists. This
      function takes a resource array handle as an argument.<br>
    </big>
    <h1><a id="mozTocId242557" class="mozTocH1"></a><big>
        Part 8. Binary files</big></h1>
    <h2><a id="mozTocId843024" class="mozTocH2"></a><big>
        Chapter 1. The sub-namespace</big></h2>
    <big>
      All classes in this section are declared in the <i>File</i>
      sub-namespace.<br>
    </big>
    <h2><a id="mozTocId302257" class="mozTocH2"></a><big>
        Chapter 2. Base binary file subsystem</big></h2>
    <big>
      <u>
        Work with the binary files</u><br>
      <br>
      The <i>Binary_File</i> class provides simple access to the base binary
      subsystem. Don't use it directly. Let's look at the publicly available
      methods.<br>
      <br>
      <i>
        void Binary_File::close(); -</i> Close the file.<br>
      <br>
      <i>
        void Binary_File::set_position(const long int offset); -</i> Set the
      file position.<br>
      <br>
      <i>
        long int Binary_File::get_position(); -</i> Return the current file position.<br>
      <br>
      <i>
        long int Binary_File::get_length(); -</i> Return the file length in bytes.<br>
      <br>
      <i>
        bool Binary_File::check_error(); -</i> Return true if the last file
      operation failed.<br>
      <br>
      <i>
        bool Binary_File::is_open() const; -</i> Return true if the file was
      successfully opened.<br>
      <br>
      <u>
        Important notice</u><br>
      <br>
      The target file size limit is 2 gigabytes.<br>
    </big>
    <h2><a id="mozTocId983262" class="mozTocH2"></a><big>
        Chapter 3. File reader</big></h2>
    <big>
      The file reader is intended to read data from the binary files. The
      <i>Input_File</i> class provides access to a file reader. It is derived from
      the <i>Binary_File</i> class. Let's look at the publicly available methods.<br>
      <i><br>
        Input_File* Input_File::get_handle(); -</i> Return the handle to the
      file reader.<br>
      <br>
      <i>
        void Input_File::open(const char *name); -</i> Open a file to read.<br>
      <br>
      <i>
        void Input_File::read(void *buffer,const size_t length); -</i> Read data
      from the file.<br>
    </big>
    <h2><a id="mozTocId541605" class="mozTocH2"></a><big>
        Chapter 4. File writer</big></h2>
    <big>
      The file writer is intended to write data to the binary files. The
      <i>Output_File</i> class provides access to a file writer. It is derived from
      the <i>Binary_File</i> class. Let's look at the publicly available methods.<br>
      <br>
      <i>
        Output_File* Output_File::get_handle(); -</i> Return the handle to the
      file writer.<br>
      <br>
      <i>
        void Output_File::open(const char *name); -</i> Open a file to write.<br>
      <br>
      <i>
        void Output_File::create_temp(); -</i> Create a temporary file. This
      file will be deleted when it is closed.<br>
      <br>
      <i>
        void Output_File::write(const void *buffer,const size_t length); -</i>
      Write data to the file.<br>
      <br>
      void Output_File::flush(); - Force writing internal buffer data to the
      file.<br>
    </big>
    <h1><a id="mozTocId579355" class="mozTocH1"></a><big>
        Part 9. Input</big></h1>
    <h2><a id="mozTocId524142" class="mozTocH2"></a><big>
        Chapter 1. The sub-namespace</big></h2>
    <big>
      All classes in this section are declared in the <i>Input</i>
      sub-namespace.<br>
    </big>
    <h2><a id="mozTocId579252" class="mozTocH2"></a><big>
        Chapter 2. Keyboard</big></h2>
    <big>
      <u>
        Low–level input</u><br>
      <br>
      Any keyboard has a built-in chip. It generates a special code when the
      user presses or releases the key. This code is called a «scan code».<br>
      <br>
      <u>
        Working with the keyboard</u><br>
      <br>
      Just use the <i>Keyboard</i> class to work with a keyboard. Let's look at
      the publicly available methods.<br>
      <i><br>
        void Keyboard::initialize(); -</i> Initialize the subsystem.<br>
      <br>
      <i>
        bool Keyboard::check_hold(const unsigned char code); -</i> Return true
      if a key with a specific scan code is pressed or held.<br>
      <br>
      <i>
        bool Keyboard::check_press(const unsigned char code); -</i> Return true
      if a key with a specific scan code was pressed.<br>
      <br>
      <i>
        bool Keyboard::check_release(const unsigned char code); -</i> Return
      true if a key with a specific scan code was released.<br>
      <br>
      <i>
        bool Keyboard::is_ready() const; -</i> Return true if the subsystem has
      already been initialized.<br>
      <br>
      <u>
        List of supported scan codes</u><br>
      <br>
      You can see a list of scan codes below.<br>
      <br>
    </big>
    <table border="1">
      <tbody>
        <tr>
          <td><big>Key</big></td>
          <td><big>Code</big></td>
          <td><big>Key</big></td>
          <td><big>Code</big></td>
          <td><big>Key</big></td>
          <td><big>Code</big></td>
        </tr>
        <tr>
          <td><big>Escape</big></td>
          <td><big>1</big></td>
          <td><big>A</big></td>
          <td><big>30</big></td>
          <td><big>F1</big></td>
          <td><big>59</big></td>
        </tr>
        <tr>
          <td><big>! or 1</big></td>
          <td><big>2</big></td>
          <td><big>S</big></td>
          <td><big>31</big></td>
          <td><big>F2</big></td>
          <td><big>60</big></td>
        </tr>
        <tr>
          <td><big>@ or 2</big></td>
          <td><big>3</big></td>
          <td><big>D</big></td>
          <td><big>32</big></td>
          <td><big>F3</big></td>
          <td><big>61</big></td>
        </tr>
        <tr>
          <td><big># or 3</big></td>
          <td><big>4</big></td>
          <td><big>F</big></td>
          <td><big>33</big></td>
          <td><big>F4</big></td>
          <td><big>62</big></td>
        </tr>
        <tr>
          <td><big>$ or 4</big></td>
          <td><big>5</big></td>
          <td><big>G</big></td>
          <td><big>34</big></td>
          <td><big>F5</big></td>
          <td><big>63</big></td>
        </tr>
        <tr>
          <td><big>% or 5</big></td>
          <td><big>6</big></td>
          <td><big>H</big></td>
          <td><big>35</big></td>
          <td><big>F6</big></td>
          <td><big>64</big></td>
        </tr>
        <tr>
          <td><big>^ or 6</big></td>
          <td><big>7</big></td>
          <td><big>J</big></td>
          <td><big>36</big></td>
          <td><big>F7</big></td>
          <td><big>65</big></td>
        </tr>
        <tr>
          <td><big>&amp; or 7</big></td>
          <td><big>8</big></td>
          <td><big>K</big></td>
          <td><big>37</big></td>
          <td><big>F8</big></td>
          <td><big>66</big></td>
        </tr>
        <tr>
          <td><big>* or 8</big></td>
          <td><big>9</big></td>
          <td><big>L</big></td>
          <td><big>38</big></td>
          <td><big>F9</big></td>
          <td><big>67</big></td>
        </tr>
        <tr>
          <td><big>( or 9</big></td>
          <td><big>10</big></td>
          <td><big>: or ;</big></td>
          <td><big>39</big></td>
          <td><big>F10</big></td>
          <td><big>68</big></td>
        </tr>
        <tr>
          <td><big>0 or )</big></td>
          <td><big>11</big></td>
          <td><big>" or '</big></td>
          <td><big>40</big></td>
          <td><big>F11</big></td>
          <td><big>133</big></td>
        </tr>
        <tr>
          <td><big>_ or |</big></td>
          <td><big>12</big></td>
          <td><big>~ or `</big></td>
          <td><big>41</big></td>
          <td><big>F12</big></td>
          <td><big>134</big></td>
        </tr>
        <tr>
          <td><big>+ or =</big></td>
          <td><big>13</big></td>
          <td><big>Left Shift</big></td>
          <td><big>42</big></td>
          <td><big>Num Lock</big></td>
          <td><big>69</big></td>
        </tr>
        <tr>
          <td><big>Backspace</big></td>
          <td><big>14</big></td>
          <td><big>| or \</big></td>
          <td><big>43</big></td>
          <td><big>Scroll Lock</big></td>
          <td><big>70</big></td>
        </tr>
        <tr>
          <td><big>Tab</big></td>
          <td><big>15</big></td>
          <td><big>Z</big></td>
          <td><big>44</big></td>
          <td><big>Home or 7</big></td>
          <td><big>71</big></td>
        </tr>
        <tr>
          <td><big>Q</big></td>
          <td><big>16</big></td>
          <td><big>X</big></td>
          <td><big>45</big></td>
          <td><big>Up or 8</big></td>
          <td><big>72</big></td>
        </tr>
        <tr>
          <td><big>W</big></td>
          <td><big>17</big></td>
          <td><big>C</big></td>
          <td><big>46</big></td>
          <td><big>Page up or 9</big></td>
          <td><big>73</big></td>
        </tr>
        <tr>
          <td><big>E</big></td>
          <td><big>18</big></td>
          <td><big>V</big></td>
          <td><big>47</big></td>
          <td><big>Gray –</big></td>
          <td><big>74</big></td>
        </tr>
        <tr>
          <td><big>R</big></td>
          <td><big>19</big></td>
          <td><big>B</big></td>
          <td><big>48</big></td>
          <td><big>Left or 4</big></td>
          <td><big>75</big></td>
        </tr>
        <tr>
          <td><big>T</big></td>
          <td><big>20</big></td>
          <td><big>N</big></td>
          <td><big>49</big></td>
          <td><big>Center or 5</big></td>
          <td><big>76</big></td>
        </tr>
        <tr>
          <td><big>Y</big></td>
          <td><big>21</big></td>
          <td><big>M</big></td>
          <td><big>50</big></td>
          <td><big>Right or 6</big></td>
          <td><big>77</big></td>
        </tr>
        <tr>
          <td><big>U</big></td>
          <td><big>22</big></td>
          <td><big>&lt; or ,</big></td>
          <td><big>51</big></td>
          <td><big>Gray +</big></td>
          <td><big>78</big></td>
        </tr>
        <tr>
          <td><big>I</big></td>
          <td><big>23</big></td>
          <td><big>&gt; or .</big></td>
          <td><big>52</big></td>
          <td><big>End or 1</big></td>
          <td><big>79</big></td>
        </tr>
        <tr>
          <td><big>O</big></td>
          <td><big>24</big></td>
          <td><big>?</big></td>
          <td><big>53</big></td>
          <td><big>Down or 2</big></td>
          <td><big>80</big></td>
        </tr>
        <tr>
          <td><big>P</big></td>
          <td><big>25</big></td>
          <td><big>Right shift</big></td>
          <td><big>54</big></td>
          <td><big>Page down or 3</big></td>
          <td><big>81</big></td>
        </tr>
        <tr>
          <td><big>{ or [</big></td>
          <td><big>26</big></td>
          <td><big>Print Surface or *</big></td>
          <td><big>55</big></td>
          <td><big>Insert or 0</big></td>
          <td><big>82</big></td>
        </tr>
        <tr>
          <td><big>} or ]</big></td>
          <td><big>27</big></td>
          <td><big>Alt</big></td>
          <td><big>56</big></td>
          <td><big>Delete or .</big></td>
          <td><big>83</big></td>
        </tr>
        <tr>
          <td><big>Enter</big></td>
          <td><big>28</big></td>
          <td><big>Spacebar</big></td>
          <td><big>57</big></td>
          <td colspan="1" rowspan="2"><br>
          </td>
          <td colspan="1" rowspan="2"><br>
          </td>
        </tr>
        <tr>
          <td><big>Control</big></td>
          <td><big>29</big></td>
          <td><big>Caps Lock</big></td>
          <td><big>58</big></td>
        </tr>
      </tbody>
    </table>
    <big><br>
    </big>
    <h2><a id="mozTocId512643" class="mozTocH2"></a><big>
        Chapter 3. Mouse</big></h2>
    <big>
      <u>
        A few words about mice</u><br>
      <br>
      A mouse is very useful for interaction with a graphical user interface.
      But the mouse can also be used in video games.<br>
      <br>
      <u>
        Working with the mouse</u><br>
      <br>
      Just use the <i>Mouse</i> class to work with a mouse. Let's look at the
      publicly available methods.<br>
      <br>
      <i>
        void Mouse::initialize(); -</i> Initialize the subsystem.<br>
      <i><br>
        void Mouse::show(); -</i> Show the mouse cursor.<br>
      <br>
      <i>
        void Mouse::hide(); -</i> Hide the mouse cursor.<br>
      <br>
      <i>
        unsigned int Mouse::get_x(); -</i> Return the x-position of the mouse.<br>
      <br>
      <i>
        unsigned int Mouse::get_y(); -</i> Return the y-position of the mouse.<br>
      <br>
      <i>
        void Mouse::set_position(const unsigned int x,const unsigned int y); -</i>
      Set the position of the mouse.<br>
      <br>
      <i>
        bool Mouse::check_hold(const BIRD2D::MOUSE_BUTTON button); -</i> Return
      true if a mouse button is pressed or held.<br>
      <i><br>
        bool Mouse::check_press(const BIRD2D::MOUSE_BUTTON button); -</i> Return
      true if a mouse button was pressed.<br>
      <br>
      <i>
        bool Mouse::check_release(const BIRD2D::MOUSE_BUTTON button); -</i>
      Return true if a mouse button was released.<br>
      <br>
      <u>
        Mouse buttons</u><br>
      <br>
      The mouse button codes look like the predefined constants. You can see
      it below.<br>
      <br>
    </big>
    <table border="1">
      <tbody>
        <tr>
          <td><big>Mouse button code</big></td>
          <td><big>Button</big></td>
        </tr>
        <tr>
          <td><big>MOUSE_LEFT</big></td>
          <td><big>Left button</big></td>
        </tr>
        <tr>
          <td><big>MOUSE_RIGHT</big></td>
          <td><big>Right button</big></td>
        </tr>
        <tr>
          <td><big>MOUSE_MIDDLE</big></td>
          <td><big>Middle button</big></td>
        </tr>
      </tbody>
    </table>
    <big><br>
    </big>
    <h2><a id="mozTocId958601" class="mozTocH2"></a><big>
        Chapter 4. Joystick</big></h2>
    <big>
      The <i>Joystick</i> class provides simple access to a joystick. It is a
      simple class with a few methods.<br>
      <br>
      <i>
        void Joystick::update(); -</i> Update the internal joystick state.<br>
      <br>
      <i>
        void Joystick::initialize(const char *joystick); -</i> Initialize the subsystem.<br>
      <br>
      <i>
        bool Joystick::is_ready() const; -</i> Return true if the subsystem has
      already been initialized.<br>
      <br>
      <i>
        bool Joystick::check_hold(const size_t button) const; -</i> Return true
      if the button is pressed or held.<br>
      <br>
      <i>
        bool Joystick::check_press(const size_t button) const; -</i> Return true
      if the button was pressed.<br>
      <br>
      <i>
        bool Joystick::check_released(const size_t button) const; -</i> Return
      true if the button was released.<br>
      <br>
      <i>
        short int Joystick::get_axis(const size_t target); -</i> Return the
      current value of the joystick axis.<br>
      <br>
      <i>
        size_t Joystick::get_button_amount() const; -</i> Return the number of
      the joystick buttons.<br>
      <i><br>
        size_t Joystick::get_axes() const; -</i> Return the number of the
      joystick axes.<br>
    </big>
    <h1><a id="mozTocId811838" class="mozTocH1"></a><big>
        Part 10. Internal details of the engine subsystems</big></h1>
    <h2><a id="mozTocId841757" class="mozTocH2"></a><big>
        Chapter 1. A few words for a curious programmer</big></h2>
    <big>
      <br>
      The engine subsystems have a different internal structure. It has been
      hidden from you, and you don't have access to it. Do you want to know
      about hidden things? Just read the next chapter.<br>
    </big>
    <h2><a id="mozTocId923720" class="mozTocH2"></a><big>
        Chapter 2. Internal classes</big></h2>
    <big>
      <u>
        Internal classes</u><br>
      <br>
      Some classes are designed for internal use only. Don't touch them. What
      are these strange classes doing?<br>
      <u><br>
        Unix-specific classes</u><br>
      <br>
      All Unix-specific classes are declared in the Internal sub-namespace.<br>
      <br>
      <i>
        Engine</i> creates the game window and does message processing.<br>
      <i>
        Synchronization</i> implements the synchronization timer.<br>
      <br>
      <u>
        Core classes</u><br>
      <br>
      All engine core classes and functions are declared in the <i>Core</i>
      sub-namespace.<br>
      <br>
      <i>
        FPS</i> implements the FPS counter.<br>
      <i>
        Render</i> implements the OPENGL render.<br>
      <i>
        Resizer</i> is intended to calculate the correct texture size.<br>
      <i>
        Rectangle</i> is intended to draw a textured rectangle.<br>
      <i>
        Shape</i> is the base class of the Rectangle class.<br>
    </big>
    <h2><a id="mozTocId889998" class="mozTocH2"></a><big>
        Chapter 3. Base graphics subsystem</big></h2>
    <big>
      <u>
        Visible object</u><br>
      <br>
      Any visible object is a textured rectangle.<br>
      <br>
      <u>
        Textures</u><br>
      <br>
      A texture width must be a power of two. A texture height also must be a
      power of two. Any image will automatically be resized before uploading.<br>
      <br>
      <u>
        Vertex arrays and texture coordinate arrays</u><br>
      <br>
      Any rectangle needs four vertices and four texture coordinates.<br>
      A single vertex represents the following custom data type:<br>
      <br>
      <i>
        typedef struct Vertex<br>
        {<br>
        int x;<br>
        int y;<br>
        };</i><br>
      <br>
      A single texture coordinate represents the following custom data type:<br>
      <br>
      <i>
        typedef struct<br>
        {<br>
        float u;<br>
        float v;<br>
        } Point;</i><br>
      <br>
      All these custom types are declared in the Core sub-namespace.<br>
    </big>
    <h2><a id="mozTocId324625" class="mozTocH2"></a><big>
        Chapter 4. Joystick</big></h2>
    <big>
      The joystick subsystem is working over the <a href="https://www.kernel.org/doc/Documentation/input/joystick-api.txt">Linux
        Joystick API</a>.<br>
    </big>
    <h2><a id="mozTocId446231" class="mozTocH2"></a><big>
        Chapter 5. Input</big></h2>
    <big>
      <u>
        Input backend</u><br>
      <br>
      The keyboard and mouse input subsystems are simple. It works over <a href="https://gitlab.freedesktop.org/xorg/lib/libx11">Xlib</a>.<br>
      <br>
      <u>
        Internal key state</u><br>
      <br>
      The internal states of keyboard keys and mouse buttons look like the
      predefined constants. You can see it below.<br>
      <br>
    </big>
    <table border="1">
      <tbody>
        <tr>
          <td><big>Key/button state</big></td>
          <td><big>Description</big></td>
        </tr>
        <tr>
          <td><big>KEY_PRESSED</big></td>
          <td><big>A key or button is pressed or held.</big></td>
        </tr>
        <tr>
          <td><big>KEY_RELEASED</big></td>
          <td><big>A key or button was released.</big></td>
        </tr>
      </tbody>
    </table>
    <big><br>
    </big>
    <h2><a id="mozTocId606783" class="mozTocH2"></a><big>
        Chapter 6. Audio</big></h2>
    <big>
      The audio subsystem is working over <a href="https://www.videolan.org/vlc/libvlc.html">libVLC</a>.<br>
    </big>
    <h1><a id="mozTocId707314" class="mozTocH1"></a><big>Version history</big></h1>
    <big>
      0.1: Initial version.<br>
      0.1.1-0.3.4: The unstable branch.<br>
      0.3.5: The preview release.<br>
      0.3.6-0.3.7: The small changes.<br>
      0.3.8: The full-screen mode has been implemented.<br>
      0.3.9: The mouse input has improved.<br>
      0.4: The keyboard input has improved.<br>
      0.4.1: The mouse input has improved.<br>
      0.4.2-0.4.3: The small changes.<br>
      0.4.4: The makefile has been updated.<br>
      0.4.5: The new subsystem has been added.<br>
      0.4.5-0.4.9: The small changes.<br>
      0.5-0.5.3: The mouse input has improved.<br>
      0.5.4-0.5.6: The small changes.<br>
      0.5.7: The stable release.<br>
      0.5.8: The small changes.<br>
      0.5.9: The joystick support has been added.<br>
      0.6-0.7.3: The joystick support has improved.<br>
      0.7.4: The small changes.<br>
      0.7.4.1: The documentation has been updated.<br>
      0.7.5: The memory leak has been.<br>
      0.7.6: The memory usage has reduced.<br>
      0.7.7: The sound support has been added.<br>
      0.7.8-0.9.5: The sound support has improved.<br>
      0.9.6-1.0: The small changes.<br>
      1.0.1-1.0.2: A small bug has been.<br>
      1.0.3: The memory usage has reduced.<br>
      1.0.3-1.0.8: The audio loader has improved.<br>
      1.0.9-1.1.1: The small changes.<br>
      1.1.2-1.1.9: The low-level sound subsystem has improved.<br>
      1.2: The memory leak has been.<br>
      1.2.1-1.2.3: The small bug has been fixed.<br>
      1.2.4-1.2.5: The small changes.<br>
      1.2.6: The small bug has been.<br>
      1.2.7-1.2.9: The small changes.<br>
      1.3: The audio subsystem was totally rewritten.<br>
      1.3.1-1.3.3: The audio subsystem has improved.<br>
      1.3.4-1.3.6: The small changes.<br>
      1.3.7: The image resizer is backported from the Simple Windows game framework 7.3.5.<br>
      1.3.8: The image resizer is backported from the Eugene game development kit 7.3.7.<br>
      1.3.9: The tile-map subsystem is backported from the Eugene game development kit 7.4.4.<br>
      1.4: The image resizer is backported from the Eugene game development kit 7.3.5.<br>
      1.4.1: The image resizer is backported from the Eugene game development kit 7.5.<br>
      1.4.2 The coordinates conversion subsystem is backported from the Eugene game development kit 7.5.3.<br>
      1.4.3: The keyboard input has improved.<br>
      1.4.4: The coordinates conversion subsystem is backported from the Eugene game development kit 7.5.4.<br>
      1.4.5: The keyboard input has improved.<br>
      1.4.6 The coordinates conversion subsystem is backported from the Eugene game development kit 7.5.8.<br>
      1.4.7: The source code synced with the Eugene game development kit 7.6.3.<br>
      1.4.8: The tile-map subsystem is backported from the Eugene game development kit 7.6.4.<br>
      1.4.9: The coordinates conversion subsystem is backported from the Eugene game development kit 7.6.5.<br>
      1.5: The base graphics subsystem has improved.<br>
      1.5.1: The image resizer is backported from the Eugene game development kit 7.6.8.<br>
      1.5.2: The image resizer is backported from the Eugene game development kit 7.6.9.<br>
      1.5.3: The image resizer is backported from the Eugene game development kit 7.7.<br>
      1.5.4: The image resizer is backported from the Eugene game development kit 7.7.2<br>
      1.5.5: The image resizer is backported from the Eugene game development kit 7.7.3.<br>
      1.5.6: The image resizer is backported from the Eugene game development kit 7.7.4.<br>
      1.5.7: The image resizer is backported from the Eugene game development kit 7.7.5.<br>
      1.5.8: The image resizer is backported from the Eugene game development kit 7.7.6.<br>
      1.5.9: The synchronization timer has improved.<br>
      1.6: The isometric subsystem is backported from the Eugene game development kit 7.8.<br>
      1.6.1: The isometric subsystem is backported from the Eugene game development kit 7.8.1.<br>
      1.6.2: The isometric level subsystem is backported from the Eugene game development kit 7.8.4.<br>
      1.6.3: The animation subsystem is backported from the Eugene game development kit 7.8.6.<br>
      1.6.4: The sprite sheet subsystem is backported from the Eugene game development kit 7.8.8.<br>
      1.6.5: The base sprite subsystem is backported from the Eugene game development kit 7.8.9.<br>
      1.6.6: The text drawing subsystem is backported from the Eugene game development kit 7.9.<br>
      1.6.7: The base sprite subsystem is backported from the Eugene game development kit 7.9.1.<br>
      1.6.8: The background subsystem is backported from the Eugene game development kit 7.9.2.<br>
      1.6.9: The static sprite subsystem is backported from the Eugene game development kit 7.9.3.<br>
      1.7: The static background subsystem is backported from the Eugene game development kit 7.9.4.<br>
      1.7.1: The source code synced with the Eugene game development kit 7.9.5.<br>
      1.7.2: The source code synced with the Eugene game development kit 7.9.6.<br>
      1.7.3: The base sprite subsystem is backported from the Eugene game development kit 7.9.7.<br>
      1.7.4: The image loader is backported from the Eugene game development kit 7.9.8.<br>
      1.7.5: The image resizer is backported from the Eugene game development kit 8.0.3.<br>
      1.7.6: The source code synced with the Eugene game development kit 8.0.4.<br>
      1.7.7: The source code synced with the Eugene game development kit 8.0.5.<br>
      1.7.8: The source code synced with the Eugene game development kit 8.0.8.<br>
      1.7.9: The source code synced with the Eugene game development kit 8.0.9.<br>
      1.8: The source code synced with the Eugene game development kit 8.1.4.<br>
      1.8.1: The source code synced with the Eugene game development kit 8.1.5.<br>
      1.8.2: The source code synced with the Eugene game development kit 8.1.6.<br>
      1.8.3: The source code synced with the Eugene game development kit 8.1.7.<br>
      1.8.4: The source code synced with the Eugene game development kit 8.1.8.<br>
      1.8.5: The source code synced with the Eugene game development kit 8.2.1.<br>
      1.8.6: The small changes.<br>
      1.8.7: The source code synced with the Eugene game development kit 8.2.2.<br>
      1.8.8: The source code synced with the Eugene game development kit 8.2.3.<br>
      1.8.9: The source code synced with the Eugene game development kit 8.2.6.<br>
      1.9: The source code synced with the Eugene game development kit 8.2.8.<br>
      1.9.1: The source code synced with the Eugene game development kit 8.3.<br>
      1.9.2: The source code synced with the Eugene game development kit 8.3.1.<br>
      1.9.3: The source code synced with the Eugene game development kit 8.3.2.<br>
      1.9.4: The source code synced with the Eugene game development kit 8.3.3.<br>
      1.9.5: The source code synced with the Eugene game development kit 8.3.4.<br>
      1.9.6: The source code synced with the Eugene game development kit 8.4.2.<br>
      1.9.7: The source code synced with the Eugene game development kit 8.4.4.<br>
      1.9.8: The source code synced with the Eugene game development kit 8.4.5.<br>
      1.9.8.1: The documentation has been updated.<br>
      1.9.9: The source code synced with the Eugene game development kit 8.4.6.<br>
      2.0: The source code synced with the Eugene game development kit 8.4.8.<br>
      2.0.1: The source code synced with the Eugene game development kit 8.5.<br>
      2.0.2: The source code synced with the Eugene game development kit 8.5.5.<br>
      2.0.3: The source code synced with the Eugene game development kit 8.5.6.<br>
      2.0.4: The source code synced with the Eugene game development kit 8.5.7.<br>
      2.0.5: The source code synced with the Eugene game development kit 8.5.8.<br>
      2.0.6: The source code synced with the Eugene game development kit 8.5.9.<br>
      2.0.7: The source code synced with the Eugene game development kit 8.6.<br>
      2.0.8: The source code synced with the Eugene game development kit 8.6.1.<br>
      2.0.9: The source code synced with the Eugene game development kit 8.6.2.<br>
      2.1: The source code synced with the Eugene game development kit 8.6.5.<br>
      2.1.1: The source code synced with the Eugene game development kit 8.6.6.<br>
      2.1.2: The source code synced with the Eugene game development kit 8.6.8.<br>
      2.1.3: The small changes.<br>
      2.1.4: The source code synced with the Eugene game development kit 8.7.1.<br>
      2.1.5: The source code synced with the Eugene game development kit 8.7.2.<br>
      2.1.6: The source code synced with the Eugene game development kit 8.7.8.<br>
      2.1.7: The source code synced with the Eugene game development kit 8.8.5.<br>
      2.1.8: The source code synced with the Black Game Development Kit 5.8.2.<br>
      2.1.9: The source code synced with the Eugene game development kit 8.8.7.<br>
      2.2: The source code synced with the Eugene game development kit 8.8.8.<br>
      2.2.1: The source code synced with the Black Game Development Kit 5.8.7.<br>
      2.2.2: The source code synced with the Black Game Development Kit 5.8.8.<br>
      2.2.3: The source code synced with the Black Game Development Kit 5.9.<br>
      2.2.4: The source code synced with the Black Game Development Kit 5.9.4.<br>
      2.2.5: The source code synced with the Black Game Development Kit 5.9.6.<br>
      2.2.6: The small changes.<br>
      2.2.7: The source code synced with the Eugene game development kit 8.9.9.<br>
      2.2.8: The keyboard input subsystem is backported from the Neon game development kit 7.9.1.<br>
      2.2.9: The source code synced with the Eugene game development kit 9.0.3.<br>
      2.3: The source code synced with the Eugene game development kit 9.0.4.<br>
      2.3.1: The source code synced with the Eugene game development kit 9.0.5.<br>
      2.3.2: The source code synced with the Eugene game development kit 9.0.6.<br>
      2.3.3: The source code synced with the Eugene game development kit 9.0.7.<br>
      2.3.4: The source code synced with the Eugene game development kit 9.0.8.<br>
      2.3.5: The source code synced with the Eugene game development kit 9.0.9.<br>
      2.3.5.1-2.3.5.1: The documentation has been updated.<br>
      2.3.6: The memory subsystem has improved.<br>
      2.3.7: The source code synced with the Eugene game development kit 9.1.<br>
      2.3.8: The source code synced with the Eugene game development kit 9.2.1.<br>
      2.3.9: The source code synced with the Eugene game development kit 9.2.2.<br>
      2.3.9.1: The documentation has been updated.<br>
      2.4: The source code synced with the Eugene game development kit 9.2.3.<br>
      2.4.0.1-2.4.0.4: The documentation has been updated.<br>
      2.4.1: The small changes.<br>
      2.4.1.1: The documentation has been updated.<br>
      2.4.2: The source code synced with the Eugene game development kit 9.2.6.<br>
      2.4.3: The source code synced with the Eugene game development kit 9.2.7.<br>
      2.4.3.1: The documentation has been updated.<br>
      2.4.4: The source code synced with the Eugene game development kit 9.2.8.<br>
      2.4.5: The makefile has been updated.<br>
      2.4.6: The source code synced with the Eugene game development kit 9.2.9.<br>
      2.4.7: The source code synced with the Eugene game development kit 9.3.<br>
      2.4.8: The source code synced with the Eugene game development kit 9.3.1.<br>
      2.4.9: The source code synced with the Eugene game development kit 9.3.5.<br>
      2.5: The source code synced with the Eugene game development kit 9.3.6.<br>
      2.5.1: The source code synced with the Eugene game development kit 9.3.9.<br>
      2.5.2: The source code synced with the Eugene game development kit 9.4.<br>
      2.5.3: The source code synced with the Eugene game development kit 9.4.1.<br>
      2.5.4: The source code synced with the Eugene game development kit 9.4.2.<br>
      2.5.5: The source code synced with the Eugene game development kit 9.4.3.<br>
      2.5.6: The source code synced with the Eugene game development kit 9.4.4.<br>
      2.5.7: The source code synced with the Eugene game development kit 9.4.5.<br>
      2.5.8: The source code synced with the Eugene game development kit 9.4.6.<br>
      2.5.9: The source code synced with the Eugene game development kit 9.4.7.<br>
      2.6: The source code synced with the Eugene game development kit 9.4.8.<br>
      2.6.1: The source code synced with the Eugene game development kit 9.4.9.<br>
      2.6.2: The source code synced with the Eugene game development kit 6.4.7.<br>
      2.6.2.1: The small changes.<br>
      2.6.3: The source code synced with the Black game development kit 6.4.9.<br>
      2.6.4: The source code synced with the Black game development kit 6.5.1.<br>
      2.6.5: The source code synced with the Eugene game development kit 9.5.3.<br>
      2.6.6: The source code synced with the Eugene game development kit 9.5.4.<br>
      2.6.7: The source code synced with the Eugene game development kit 9.5.5.<br>
      2.6.8: The source code synced with the Eugene game development kit 9.5.6.<br>
      2.6.9: The source code synced with the Eugene game development kit 9.5.7.<br>
      2.7: The small changes.<br>
      2.7.1: The source code synced with the Black game development kit 7.3.3.<br>
      2.7.2: The source code synced with the Black game development kit 7.3.5.<br>
      2.7.3: The source code synced with the Black game development kit 7.3.8.<br>
      2.7.4: The source code synced with the Black game development kit 7.3.9.<br>
      2.7.5: The source code synced with the Eugene game development kit 9.6.2.<br>
      2.7.6: The source code synced with the Black game development kit 7.4.8.<br>
      2.7.6.1: The documentation has been updated.<br>
      2.7.7: The source code synced with the Black game development kit 7.5.<br>
      2.7.8: The source code synced with the Black game development kit 7.5.1.<br>
      2.7.8.1: The documentation has been updated.<br>
      2.7.9: The source code synced with the Black game development kit 7.5.2.<br>
      2.7.9.1-2.7.9.2: The documentation has been updated.<br>
      2.8: The synchronization timer has improved.<br>
      2.8.1: The small changes.<br>
    </big>
  </body>
</html>